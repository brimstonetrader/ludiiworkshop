robots

(define "NumRobots" <Robots:num>)
(define "NumSafeTeleportation" <SafeTeleportation:num>)

(define "CloserToHuman" 
    (> 
        (count Steps Orthogonal (site) (where (id "Human"))) 
        (count Steps Orthogonal (ahead (site) #1) (where (id "Human")))
    )
)

(define "MoveRobot"
    (if ("IsPieceAt" "Rubble" Neutral (ahead (site) #1))
        (remove (site))
        (fromTo
            (from (site)) 
            (to 
                (ahead (site) #1)
                (apply 
                    (if ("IsPieceAt" "Human" P1 (to))
                        (remove (to))
                    )
                )
            )
        )
    )
)

(define "GoCloser"
    (if ("CloserToHuman" #1)
        ("MoveRobot" #1)
        #2
    )
)

(define "RobotThreat"
    (forEach Site 
        (sites Occupied by:Shared)
        ("GoCloser" NE 
            ("GoCloser" NW 
                ("GoCloser" SW 
                    ("GoCloser" SE 
                        ("GoCloser" E 
                            ("GoCloser" W 
                                ("GoCloser" N 
                                    ("GoCloser" S)
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(define "KillRobotsIfColliding"
    (forEach Site 
        (sites Occupied by:Shared)
        (if (>= (count at:(site)) 2)
            (and
                (remove (site))
                (add (piece "Rubble0") (to (site)))
            )
        )
    )
)

(define "Teleportation"
    (fromTo 
        (from (where (id "Human"))) 
        (to (sites Random)) 
        (then ("RobotThreat"))
    )
)

(define "SafeTeleportation"
    (fromTo 
        (from (where (id "Human"))) 
        (to 
            (sites Random 
                (difference 
                    (sites Empty) 
                    (sites Around (sites Occupied by:Shared))
                )
            )
        ) 
        (then ("RobotThreat"))
    )
)

//------------------------------------------------------------------------------

(game "Chase" 
    (players 1) 
    (equipment { 
        (board (rectangle <Rows:num> <Columns:num>)) 
        (piece "Human" P1 
            ("StepToEmpty" ~
                (then
                    ("RobotThreat")
                )
            )
        )
        (piece "Robot" Shared)
        (piece "Rubble" Neutral)
    }) 
    (rules 
        (start {
            (place Random {"Human"})
            (place Random {"Robot"} count:("NumRobots"))
            (set Score P1 ("NumSafeTeleportation"))
        })
        (play
            (or {
                (forEach Piece)
                (move Pass (then ("Teleportation")))
                (if (< 0 (score P1))
                    (move Select
                        (from (where (id "Human")))
                        (then
                            (and
                                (set Score Mover (- (score P1) 1))
                                ("SafeTeleportation")
                            )
                        )
                    )
                )
                }
                (then
                    ("KillRobotsIfColliding")
                )
            )
        )
        (end {
            (if (no Pieces Mover) (result Mover Loss))
            (if (no Pieces "Robot") (result Mover Win))
        })
    )
)

//------------------------------------------------------------------------------

(option "Rows" <Rows> args:{ <num> }
    {
    (item "1" <1> "The board has 1 row.") 
    (item "2" <2> "The board has 2 rows.") 
    (item "3" <3> "The board has 3 rows.") 
    (item "4" <4> "The board has 4 rows.") 
    (item "5" <5> "The board has 5 rows.") 
    (item "6" <6> "The board has 6 rows.") 
    (item "7" <7> "The board has 7 rows.") 
    (item "8" <8> "The board has 8 rows.") 
    (item "9" <9> "The board has 9 rows.") 
    (item "10" <10> "The board has 10 rows.")* 
    (item "11" <11> "The board has 11 rows.") 
    (item "12" <12> "The board has 12 rows.") 
    (item "13" <13> "The board has 13 rows.") 
    (item "14" <14> "The board has 14 rows.") 
    (item "15" <15> "The board has 15 rows.") 
    (item "16" <16> "The board has 16 rows.") 
    (item "17" <17> "The board has 17 rows.") 
    (item "18" <18> "The board has 18 rows.") 
    (item "19" <19> "The board has 19 rows.") 
    (item "20" <20> "The board has 20 rows.") 
    (item "21" <21> "The board has 21 rows.") 
    (item "22" <22> "The board has 22 rows.") 
    (item "23" <23> "The board has 23 rows.") 
    (item "24" <24> "The board has 24 rows.") 
    (item "25" <25> "The board has 25 rows.") 
    (item "26" <26> "The board has 26 rows.") 
    (item "27" <27> "The board has 27 rows.") 
    (item "28" <28> "The board has 28 rows.") 
    (item "29" <29> "The board has 29 rows.") 
    (item "30" <30> "The board has 30 rows.") 
    }
)
(option "Columns" <Columns> args:{ <num> }
    {
    (item "2" <2> "The board has 2 columns.") 
    (item "3" <3> "The board has 3 columns.") 
    (item "4" <4> "The board has 4 columns.") 
    (item "5" <5> "The board has 5 columns.") 
    (item "6" <6> "The board has 6 columns.") 
    (item "7" <7> "The board has 7 columns.") 
    (item "8" <8> "The board has 8 columns.") 
    (item "9" <9> "The board has 9 columns.") 
    (item "10" <10> "The board has 10 columns.") 
    (item "11" <11> "The board has 11 columns.") 
    (item "12" <12> "The board has 12 columns.") 
    (item "13" <13> "The board has 13 columns.") 
    (item "14" <14> "The board has 14 columns.") 
    (item "15" <15> "The board has 15 columns.") 
    (item "16" <16> "The board has 16 columns.") 
    (item "17" <17> "The board has 17 columns.") 
    (item "18" <18> "The board has 18 columns.") 
    (item "19" <19> "The board has 19 columns.") 
    (item "20" <20> "The board has 20 columns.")* 
    (item "21" <21> "The board has 21 columns.") 
    (item "22" <22> "The board has 22 columns.") 
    (item "23" <23> "The board has 23 columns.") 
    (item "24" <24> "The board has 24 columns.") 
    (item "25" <25> "The board has 25 columns.") 
    (item "26" <26> "The board has 26 columns.") 
    (item "27" <27> "The board has 27 columns.") 
    (item "28" <28> "The board has 28 columns.") 
    (item "29" <29> "The board has 29 columns.") 
    (item "30" <30> "The board has 30 columns.") 
    }
)
(option "Safe Teleportations" <SafeTeleportation> args:{ <num> }
    {
    (item "2" <2> "The player has 2 safe teleportations.") 
    (item "3" <3> "The player has 3 safe teleportations.") 
    (item "4" <4> "The player has 4 safe teleportations.") 
    (item "5" <5> "The player has 5 safe teleportations.")* 
    (item "6" <6> "The player has 6 safe teleportations.") 
    (item "7" <7> "The player has 7 safe teleportations.") 
    (item "8" <8> "The player has 8 safe teleportations.") 
    (item "9" <9> "The player has 9 safe teleportations.") 
    (item "10" <10> "The player has 10 safe teleportations.") 
    }
)
(option "Robots" <Robots> args:{ <num> }
    {
    (item "2" <2> "2 robots.") 
    (item "3" <3> "3 robots.") 
    (item "4" <4> "4 robots.") 
    (item "5" <5> "5 robots.") 
    (item "6" <6> "6 robots.") 
    (item "7" <7> "7 robots.") 
    (item "8" <8> "8 robots.") 
    (item "9" <9> "9 robots.") 
    (item "10" <10> "10 robots.") 
    (item "11" <11> "11 robots.") 
    (item "12" <12> "12 robots.") 
    (item "13" <13> "13 robots.") 
    (item "14" <14> "14 robots.") 
    (item "15" <15> "15 robots.") 
    (item "16" <16> "16 robots.") 
    (item "17" <17> "17 robots.") 
    (item "18" <18> "18 robots.") 
    (item "19" <19> "19 robots.") 
    (item "20" <20> "20 robots.")* 
    (item "21" <21> "21 robots.") 
    (item "22" <22> "22 robots.") 
    (item "23" <23> "23 robots.") 
    (item "24" <24> "24 robots.") 
    (item "25" <25> "25 robots.") 
    (item "26" <26> "26 robots.") 
    (item "27" <27> "27 robots.") 
    (item "28" <28> "28 robots.") 
    (item "29" <29> "29 robots.") 
    (item "30" <30> "30 robots.") 
    }
)

//------------------------------------------------------------------------------
(metadata 
    
    (info
        {
        (description "Chase is a turn-based computer game in which players are tasked with escaping from robots programmed to pursue and kill them. The player attempts to destroy the robots by moving in such a way that the robots collide with each other or other obstacles.")
        (rules "Chase is played on a two-dimensional rectangular grid. The objective of the game is to escape from a number of robots, which have been programmed to kill the player.
            
            The game is turn-based. The player character and the robots start at randomly selected locations. Every time the player character moves a square in any direction (horizontally, vertically, or diagonally), each robot moves one square closer to their new location, in whichever direction is the shortest path. If the player character collides with a robot, they die and the game ends.
            
            The player attempts to survive by causing the robots to kill themselves by colliding with other objects on the map. When two robots collide each other a pile of rubble is created.
            
            The player can also teleport into a randomly selected location. Teleportation counts as a move, and the robots will respond by moving towards the new location. Because the location is randomly selected, it is possible that the player teleports right into the path of a robot. A safe teleport is also possible for the player but can be used only a limited number of times.
            
            The game is won when all of the robots are destroyed. 
            
        In Ludii, the number of safe teleportations available is the score of the player. In clicking on the player a safe teleportation will be applied. To make a non safe teleportation, the button Pass has to be pressed.")
        (id "685")
        (source "<a href=\"https://en.wikipedia.org/wiki/Chase_(video_game)\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (version "1.3.11")
        (classification "puzzle/planning")
        (credit "Eric Piette")
        (date "1970")
        }
    )
    
    (graphics {
        (no Sunken)
        (board Colour Phase0 (colour White))
        (board Colour InnerEdges (colour White))
        (board Colour OuterEdges (colour Black))
    })
    (ai
        "Chase_ai"
    )
)


(game "Breakthru"
    (players 2)
    (equipment {
        (board (square 11))
        (piece "Disc" Each 
            (or 
                (if ("NewTurn") ("StepToEnemy" Diagonal))
                (move Slide Orthogonal (then (if ("NewTurn") (moveAgain))))
            )
        )
        (piece "Commander" P1 
            (if ("NewTurn") 
                (or 
                    ("StepToEnemy" Diagonal)
                    (move Slide Orthogonal)
                )
            )
        )
        (hand Each)
        (regions "CentreSites" (expand (sites Centre) steps:2))
    })
    (rules
        (start {
            (place "Commander1" (sites Centre))
            (place "Disc1" (handSite P1) count:12)
            (place "Disc2" (handSite P2) count:20)
        })
        phases:
        {
        (phase "PlacementP1"
            (play 
                (move 
                    (from (handSite P1))
                    (to (intersection (sites "CentreSites") (sites Empty)))
                    (then (if (is Occupied (handSite P1)) (moveAgain)))
                )
            )
            (nextPhase (is Empty (handSite P1)) "PlacementP2")
        )
        
        (phase "PlacementP2"
            (play 
                (move 
                    (from (handSite P2))
                    (to (difference (sites Empty) (sites "CentreSites")))
                    (then (if (is Occupied (handSite P2)) (moveAgain)))
                )
            )
            (nextPhase (is Empty (handSite P2)) "Movement")
        )
        
        ("PhaseMovePiece" "Movement"
            (end {
                ("PieceTypeReachWin" "Commander1" (sites Outer) P1)
                (if ("IsOffBoard" (where "Commander" P1)) (result P2 Win))
            })
        )
        }
    )
)

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Breakthru is a modern member of the Hnefatafl family of games, where the players have unequal forces and different objectives. ")
        (rules "Objectives
            One player has a gold fleet consisting of one large flagship and twelve escorts, with the objective of evading capture while breaking through his or her opponent's blockade to transport the flagship to the perimeter of the board. The other player has a silver fleet of twenty ships, and forms a blockade to trap the gold flagship and destroy the gold fleet's escorts with the objective of capturing the flagship.
            
            Setup
            Gold player places the flagship on the center square of the game board, and positions the rest of the ships anywhere within the boldly ruled central area of the board.
            
            Silver player then positions the silver ships on twenty squares in the lightly ruled peripheral area of the board.
            
            Play
            Gold player chooses who goes first. Players move alternately by making two moves or one capture anywhere on the board. When the flagship is moved, only one move or capture is made (thus only the flagship).
            
            Moves
            A player may move two of the smaller playing pieces any number of vacant squares either horizontally or vertically on the board (as a rook in Chess, except that no captures can be made with this move), although if the flagship is moved, the gold player may not move another playing piece.
            
            Captures
            A player may move any playing piece (including the flagship) one square diagonally to capture one of his opponent's playing pieces. (This move is similar to the capture-move of the pawn in Chess, except that captures can be made on any of the four diagonals.)
            
            This game uses displacement capture (like Chess), rather than custodial capture (like Hnefatafl), thus when a capture is made, the captured piece is removed from the board and the vacated square is occupied by the captor.
            
        Play continues until one player achieves his or her objective. If the flagship of the gold fleet reaches one of the outermost squares on the board, gold player wins. If the flagship is captured before it reaches the outer edge of the board, silver player wins.")
        (id "1537")
        (source "<a href=\"https://www.boardgamegeek.com/boardgame/335/breakthru\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />BGG</a>")
        (version "1.3.11")
        (classification "board/war/custodial")
        (author "Alex Randolph")
        (credit "Eric Piette")
        (date "1965")
        }
    )
    
    (graphics {
        (piece Scale "Disc" 0.6)
        (piece Rotate "Commander" degrees:45)
        (player Colour P1 (colour Yellow))
        (player Colour P2 (colour Grey))
        
        (board Colour Phase0 (colour Black))
        (board Colour InnerEdges (colour Grey))
        (board Colour OuterEdges (colour Grey))
        (region Colour Edge (expand (sites Centre) steps:2) regionSiteType:Cell (colour White) scale:2)
    })
    
    (ai
        "Breakthru_ai"
    )
)


conway's game of life

(define "Nbors"
    (count Sites 
        in:(intersection 
            (sites Around #1) 
            (sites Occupied by:All) 
        )
    )
)

(define "Grow"
    (forEach Site (sites Board) 
        (if (and 
                (is Empty (to)) 
                (= 3 ("Nbors" (to)))
            ) 
            (add (piece "Disc") (to (to))) 
            (if (and 
                    (is Occupied (to)) 
                    (or (< ("Nbors" (to)) 2) (> ("Nbors" (to)) 3))
                ) 
                (remove (to)) 
            )
        )
    )
)

//------------------------------------------------------------------------------

(game "Game of Life" 
    (players 0) 
    (equipment { 
        (board <Board>) 
        (piece "Disc" Shared) 
    }) 
    (rules 
        (start (place "Disc" (sites {<Start>}))) 
        (play 
            ("Grow")
        )
        (end (if (= (count Moves) 100) (result Mover Draw)))
    )
)

//------------------------------------------------------------------------------

(option "Board" <Board> args:{ <board> } {
    (item "Square 8x8" <(square 8)> "Square 8x8 board.") 
    (item "Square 12x12" <(square 12)> "Square 12x12 board.")* 
    (item "Hex 5"  <(hex 5)> "Hex 5 board.") 
})

(option "Start" <Start> args:{ <start> } {
    (item "Glider"  
        <"B4" "C4" "D4" "D3" "C2">
        "Self-perpetuating glider pattern."
    )
    (item "Lightweight Spaceship"  
        <"C3" "D3" "E3" "F3" "B4" "F4" "F5" "C6" "E6">
        "Self-perpetuating Lightweight spaceship pattern."
    )*
    (item "Blinker"  
        <"B3" "C3" "D3">
        "Oscillating blinker pattern."
    )
    (item "Toad"  
        <"B3" "C3" "D3" "C4" "D4" "E4">
        "Oscillating toad pattern."
    )
    (item "Beacon"  
        <"B2" "C2" "B3" "C3" "D4" "E4" "D5" "E5">
        "Oscillating beacon pattern."
    )
    (item "Block"  
        <"B2" "C2" "B3" "C3">
        "Static block pattern."
    )
})

//------------------------------------------------------------------------------

(metadata
    (info
        {
        (description "Board game version of Conway's Game of Life.")
        (rules "At each tick, a set of rules are applied to every board cell, which determine whether a piece 'lives' or 'dies' at each cell. Any live cell with two or three live neighbours survives.
            Any dead cell with three live neighbours becomes a live cell.
        All other live cells die in the next generation. Similarly, all other dead cells stay dead.")
        (id "708")
        (source "<a href=\"https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (version "1.3.11")
        (classification "simulation")
        (author "John Horton Conway")
        (credit "Eric Piette and Cameron Browne")
        (date "1970")
        }
    )
)



havannah

(game "Havannah" 
    (players 2) 
    (equipment { 
        (board (hex <Board>)) 
        (piece "Marker" Each) 
    }) 
    (rules 
        <Meta:rule>
        (play (move Add (to (sites Empty))))
        (end 
            (if 
                (or {
                    (is Loop) 
                    (is Connected 3 SidesNoCorners) 
                    (is Connected 2 Corners) 
                })
                (result Mover Win)
            )
        ) 
    )
)

//------------------------------------------------------------------------------

(option "Board Size" <Board> args:{ <size> }
    {
    (item "4x4"  <4>  "The game is played on a 4x4 board") 
    (item "5x5"  <5>  "The game is played on a 5x5 board") 
    (item "6x6"  <6>  "The game is played on a 6x6 board") 
    (item "7x7"  <7>  "The game is played on a 7x7 board") 
    (item "8x8"  <8>  "The game is played on a 8x8 board")** 
    (item "9x9"  <9>  "The game is played on a 9x9 board") 
    (item "10x10" <10> "The game is played on a 10x10 board") 
})

(option "Swap Rules" <Meta> args:{ <rule>} {
    (item "On" <(meta (swap))> "The game uses the swap rule.") 
    (item "Off" <> "The game does not use the swap rule.")* 
})

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Havannah is a connection game invented by Christian Freeling and played on a hexagonal board.")
        (rules "Players take turns placing pieces on the board. There are three winning conditions: 1. Connect any three edges (without corner points), or 2. Make a bridge connection between any two corners, or 3. loop around any site.")
        (source "<a href=\"https://en.wikipedia.org/wiki/Havannah\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (id "391")
        (version "1.3.11")
        (classification "board/space/connection")
        (author "Christian Freeling")
        (credit "Eric Piette")
        (date "1981")
        }
    )
    
    (ai 
        "Havannah_ai"
    )
    
)


lines of action

(define "DistInColumn" (count Sites in:(difference (sites Column (column of:(from))) (sites Empty))))

(define "DistInRow" (count Sites in:(difference (sites Row (row of:(from))) (sites Empty))))

(define "DistInNESW" (count Sites in:(difference (sites Direction from:(from) (directions {NE SW}) included:True) (sites Empty))))

(define "DistInNWSE" (count Sites in:(difference (sites Direction from:(from) (directions {NW SE}) included:True) (sites Empty))))

(define "MoveTo" 
    (move Hop
        #1 
        (between 
            (exact (- #2 1))
            if:(not ("IsEnemyAt" (between)))
        )
        (to 
            if:(not ("IsFriendAt" (to)))
            (apply (if ("IsEnemyAt" (to)) (remove (to))))
        )
    )
)

//------------------------------------------------------------------------------

(game "Lines of Action" 
    (players 2) 
    
    (equipment { 
        (board (square 8)) 
        (piece "Disc" Each 
            (or {
                ("MoveTo" (directions {N S}) "DistInColumn")
                ("MoveTo" (directions {W E}) "DistInRow")
                ("MoveTo" (directions {NE SW}) "DistInNESW")
                ("MoveTo" (directions {NW SE}) "DistInNWSE")
            })
        )
    }) 
    
    (rules 
        (meta (no Suicide))
        (start { 
            (place "Disc1" (difference (union (sites Top) (sites Bottom)) (sites Corners)))
            (place "Disc2" (difference (union (sites Right) (sites Left)) (sites Corners)))
        })
        
        (play (forEach Piece))
        
        (end { 
            (if (and (= 1 (count Groups if:(= (who at:(to)) P1))) (= 1 (count Groups if:(= (who at:(to)) P2)))) (result Mover <End:result>)) 
            (if (= 1 (count Groups if:(= (who at:(to)) P1))) (result P1 Win)) 
            (if (= 1 (count Groups if:(= (who at:(to)) P2))) (result P2 Win)) 
        }) 
    )
)

//------------------------------------------------------------------------------

(option "End rules" <End> args:{ <result> }
    {
    (item "Simultaneous Group = Draw" <Draw> "If the two players make a group in the same turn, the game ends in a draw.")* 
    (item "Simultaneous Group = Mover Win" <Win> "If the two players make a group in the same turn, the mover wins.") 
})

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Lines of Action was invented by Claude Soucie in 1969. It is played on an 8x8 board with twelve pieces per player.")
        (rules "A player wins by connecting all of one's pieces into a contiguous body so that they are connected orthogonally or diagonally. Players alternate moves. Pieces move orthogonally or diagonally. A piece moves exactly as many spaces as there are pieces (belonging to both the player and their opponent) on the line in which it is moving. A piece may jump over the player's own pieces, but not over one belonging to the opponent. A piece can capture piece belonging to the opponent by landing on it.")
        (source "<a href=\"https://en.wikipedia.org/wiki/Lines_of_Action\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (id "394")
        (version "1.3.11")
        (classification "board/space/group")
        (author "Claude Soucie")
        (credit "Eric Piette")
        (date "1988")
        }
    )
    
    (graphics {
        (board Style Chess)
        (player Colour P1 (colour VeryDarkGrey))
        (player Colour P2 (colour White))
    })
    
    (ai 
        "Lines of Action_ai"
    )
    
)


pente

(define "Custodial" 
    (custodial 
        (from (last To)) 
        All
        (between 
            if:(is Next (who at:(between)))
            (apply (remove (between)))
        )
        (to if:(and (= 3 (count Steps Vertex All (last To) (to))) (is Mover (who at:(to)))))
        (then (addScore Mover 1))
    )
)

//------------------------------------------------------------------------------

(game "Pente" 
    (players 2) 
    (equipment { 
        (board <Board> use:Vertex) 
        (piece "Ball" Each) 
    }) 
    (rules 
        (start (set Score Each 0))
        <Play>
        (end 
            {
            (if (is Line 5 All) (result Mover Win))
            (if (> (score Mover) 9) (result Mover Win))
            //(if (is Full) (result Draw))
            }
        ) 
    )
)

//------------------------------------------------------------------------------

(option "Board Size" <Board> args:{ <size> }
    { 
    (item "19x19" <(square 19)> "Played on a 19x19 board.") 
    }
)

(option "Opening" <Play> args:{ <rules> }
    {
    (item "Standard Pente" 
        <
        phases:{
        (phase "Opening"
            (play (move Add (to (sites "J10"))))
            (nextPhase "General")
        )
        (phase "General"
            (play 
                (move Add (to (sites Empty))
                    (then "Custodial")
                )
            )
        )
        }
        >
        "Open at the centre point."
    )*
    (item "Freestyle" 
        <
        (play (move Add (to (sites Empty))))
        > 
        "Open anywhere."
    )
    (item "Pro Pente" 
        <
        phases:{
        (phase "First Move"
            (play (move Add (to (sites "J10"))))
            (nextPhase "Second Move")
        )
        (phase "Second Move"
            (play (move Add (to (sites Empty))))
            (nextPhase "Third Move")
        )
        (phase "Third Move"
            (play (move Add (to (intersection
                            (sites Empty)
            (sites Distance All from:(coord "J10") (range 3 15))))))
            (nextPhase "General")
        )
        (phase "General"
            (play (move Add (to (sites Empty))))
        )
        }
        > 
        "White's second move must be 3 points away from the centre."
    )
    }
)

//-------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Pente was invented by Gary Gabriel in 1983, and was inspired by Ninuki-Renju.  In Pente, players compete to be the first to form an orthogonal or diagonal line of five stones, or to capture ten opposing stones.  Pente does not have the complex opening protocol or specific positional restrictions of Ninuki-Renju.  The first player has a strong advantage, but the Pro Pente opening variation gives Black more even winning chances.")
        (rules "Pente is played on a 19x19 Go board.  White goes first, and plays their first move on the centre point (unless playing Freestyle).  In the Pro Pente variation, White's second move must be at least 3 points away from the centre.  After the opening, players alternate playing one stone of their colour onto any empty point.  If their placement results in a pair of enemy stones being sandwiched between two of their own stones, those enemy stones are captured.  The first player to form an orthogonal or diagonal line of five (or more) of their stones, or to capture 10 enemy stones, wins the game.")
        (id "1412")
        (source "<a href=\"https://pente.org/help/helpWindow.jsp?file=playGameRules\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Pente.org</a>")
        (version "1.3.11")
        (classification "board/space/line")
        (author "Gary Gabriel")
        (credit "Eric Silverman")
        (date "1977")
        }
    )
    
    (graphics {
        (board Style Go)
        (player Colour P1 (colour White))
        (player Colour P2 (colour Black))
    })
    
    (ai
        "Pente_ai"
    )
) 




othello

(define "ReverseBoundedPieces" 
    (custodial
        (from (site))
        (between 
            if:(is Enemy (state at:(between))) 
            (apply 
                (allCombinations 
                    (add (piece "Disc0" state:(mover)) (to (site))) 
                    (flip (between)) 
                )
            )
        )
        (to if:(is Friend (state at:(to))))
    )
)

//------------------------------------------------------------------------------

(game "Reversi" 
    (players 2) 
    (equipment { 
        (board (square <Board:size>))
        (piece "Disc" Neutral (flips 1 2))
    }) 
    (rules 
        
        <Rules:start> 
        
        phases:{ 
        <Rules:play>
        (phase "Playing" 
            (play (forEach Site 
                    (sites Empty)
                    (append 
                        "ReverseBoundedPieces" 
                        (then
                            (and
                                (set Score 
                                    P1 
                                    (count Sites in:(sites State 1))
                                )
                                (set Score 
                                    P2 
                                    (count Sites in:(sites State 2))
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        
        (end
            (if (all Passed)
                (byScore)
            )
        )
    )
)

//------------------------------------------------------------------------------

(option "Start Rules" <Rules> args:{ <start> <play> }
    {
    (item "Fixed Start"  
        < (start { 
            (place "Disc0" (difference (sites Centre) (sites Phase 1)) state:1)
            (place "Disc0" (difference (sites Centre) (sites Phase 0)) state:2)
        })
        >
        <>
        "The pieces are placed on the board."
    )** 
    
    (item "Not Fixed Start" 
        <>
        <
        (phase "Placement"
            (play
                (move
                    Add
                    (piece
                        "Disc0" 
                        state:(mover)
                    )
                    (to 
                        (intersection 
                            (sites Empty) 
                            (sites Centre)
                        )
                    )
                )
            ) 
            (nextPhase Mover (>= (count Moves) 3) "Playing")
        )
        >
        "The pieces are placed on the board."
    )
    
})

//------------------------------------------------------------------------------

(option "Board Size" <Board> args:{ <size> }
    {
    (item "4x4" <4> "The board is a square board of size 4x4.") 
    (item "6x6" <6> "The board is a square board of size 6x6.") 
    (item "8x8" <8> "The board is a square board of size 8x8.")** 
    (item "10x10" <10> "The board is a square board of size 10x10.") 
    (item "12x12" <12> "The board is a square board of size 12x12.") 
    (item "14x14" <14> "The board is a square board of size 14x14.") 
    (item "16x16" <16> "The board is a square board of size 16x16.") 
    (item "18x18" <18> "The board is a square board of size 18x18.") 
    (item "20x20" <20> "The board is a square board of size 20x20.") 
    (item "22x22" <22> "The board is a square board of size 22x22.") 
    (item "24x24" <24> "The board is a square board of size 24x24.") 
})

//------------------------------------------------------------------------------

(metadata
    
    (info
        {
        (description "Reversi is a game purportedly invented in the early nineteenth century by either Lewis Waterman or John W. Mollett, but may actually be an older game. It is currently sold and marketed as Othello worldwide.")
        (aliases {"Othello"})
        (rules "Reversi is played on an 8x8 board. Pieces are double-sided, with each side distinct in some way from the other. Each side designates ownership of that pieces to a certain player when face-up. Play begins with the players taking turns placing pieces into the central four squares until they are full. Then players may place their pieces next to an opponent's piece, a long as a straight line can be drawn between the new piece and an existing piece belonging to that player that goes through the opponent's piece. The opponent's pieces between the new piece and the old piece are then flipped and now belong to the player who just played. If a player cannot make a legal move, they pass. Play continues until the board is full or neither player cannot make a legal move. The player with the most pieces on the board wins.")
        (source "<a href=\"https://en.wikipedia.org/wiki/Reversi\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (id "104")
        (version "1.3.11")
        (classification "board/space/territory")
        (credit "Eric Piette")
        }
    )
    
    (graphics {
        (piece Colour state:1 fillColour:(colour Black))
        (piece Colour state:2 fillColour:(colour White))
        (board Colour OuterEdges (colour Black))
        (board Colour InnerEdges (colour Black))
        (board StyleThickness InnerEdges 0.5)
        (board Colour Symbols (colour Black))
        (board Colour Phase0 (colour 52 158 52))
        (player Colour P1 (colour Black))
        (player Colour P2 (colour White))
        (useFor "Board Size/4x4" (show Symbol "dot" Vertex {16 18 6 8} scale:0.2))
        (useFor "Board Size/6x6" (show Symbol "dot" Vertex {36 40 12 8} scale:0.2))
        (useFor "Board Size/8x8" (show Symbol "dot" Vertex {20 24 56 60} scale:0.2))
        (useFor "Board Size/10x10" (show Symbol "dot" Vertex {90 96 30 24} scale:0.2))
        (useFor "Board Size/12x12" (show Symbol "dot" Vertex {132 140 36 28} scale:0.2))
        (useFor "Board Size/14x14" (show Symbol "dot" Vertex {182 192 42 32} scale:0.2))
        (useFor "Board Size/16x16" (show Symbol "dot" Vertex {240 252 48 36} scale:0.2))
        (useFor "Board Size/18x18" (show Symbol "dot" Vertex {306 320 54 40} scale:0.2))
        (useFor "Board Size/20x20" (show Symbol "dot" Vertex {380 396 60 44} scale:0.2))
        (useFor "Board Size/22x22" (show Symbol "dot" Vertex {462 48 480 66} scale:0.2))
        (useFor "Board Size/24x24" (show Symbol "dot" Vertex {552 572 72 52} scale:0.2))
    })
    
    (ai 
        "Reversi_ai"
    )
    
)



go

(define "CaptureSurroundedPiece"
    (enclose 
        (from (last To)) 
        Orthogonal 
        (between 
            if:("IsEnemyAt" (between)) 
            (apply    
                (and 
                    (addScore Mover 1) 
                    (remove (between)) 
                )
            ) 
        )
    )
)

//------------------------------------------------------------------------------

(game "Go" 
    (players 2) 
    (equipment { 
        (board <Board> use:Vertex) 
        (piece "Marker" Each)
    })
    
    (rules 
        (meta (no Repeat))
        (play 
            (or
                (do
                    (move Add
                        (to (sites Empty))
                        (then "CaptureSurroundedPiece")
                    )
                    ifAfterwards:("HasFreedom" Orthogonal)
                )
                (move Pass)
            )
        )
        
        (end
            (if (all Passed)
                (byScore {
                    (score P1 (+ (score P1) (size Territory P1))) 
                    (score P2 (+ (score P2) (size Territory P2)))
                })
            )
        )
    )
)

//------------------------------------------------------------------------------

(option "Board Size" <Board> args:{ <size> }
    {
    (item "9x9"  <(square 9)>  "The game is played on a 9x9 board") 
    (item "13x13" <(square 13)> "The game is played on a 13x13 board") 
    (item "15x15" <(square 15)> "The game is played on a 15x15 board") 
    (item "19x19" <(square 19)> "The game is played on a 19x19 board")** 
})

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Also known as Weiqi in China, Go is one of the most popular board games, and one of the oldest continuously played games in the world. From an early date, it spread from China to Japan and Korea, and more recently it has become a popular game worldwide. It is a game of configuration, where the goal is to gain points by controlling territory on the board. ")
        (aliases {"Shudan"})
        (rules "Played on a 19x19 board. The board begins empty. One player plays as black, the other as white. The black player begins by placing a piece on one of the intersections on the board. Players alternate turns placing a piece on the board. A player may pass at any time. A piece or a group of pieces are captured when they are completely surrounded on all sides on adjacent intersections by the opposing player. Stones cannot be placed to recreate a previous position. The game ends when both players pass consecutively. Players total the number of intersections their pieces occupy or surround. The player with the highest total wins. ")
        (source "<a href=\"https://en.wikipedia.org/wiki/Rules_of_Go#Concise_statement\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (id "144")
        (version "1.3.11")
        (classification "board/space/territory")
        (credit "Eric Piette")
        (origin "This game was played in China, from around 694 to 710.")
        }
    )
    
    (graphics {
        (board Style Go)
        (player Colour P1 (colour Black))
        (player Colour P2 (colour White))
    })
    
    (ai 
        "Go_ai"
    )
    
)


chess

//**** Defines used to model the castling Moves. ****
(define "HasNeverMoved"
    (= (state at:(mapEntry #1 (mover))) 1) 
)

(define "PieceHasMoved"
    (set State at:#1 0) 
)

(define "RememberPieceHasMoved"
    (then 
        (if 
            (= (state at:(last To)) 1) 
            ("PieceHasMoved" (last To))
        ) 
    ) 
)

(define "KingNotCheckedAndToEmpty"
    (and 
        (is Empty (to)) 
        (not ("IsInCheck" "King" Mover at:(to)))
    ) 
)

(define "DecideToCastle"
    (move Slide 
        (from (mapEntry #1 (mover))) 
        #2 
        (between 
            (exact #3) 
            if:#4
        ) 
        (to 
            if:True
            (apply ("PieceHasMoved" (from)))
        )
        #5
    )
)

(define "CastleRook"
    (slide 
        (from (mapEntry #1 (mover))) 
        #2 
        (between 
            (exact #3) 
            if:#4
        ) 
        (to 
            if:True
            (apply ("PieceHasMoved" (from)))
        )
    )
)

(define "SmallCastling"
    ("DecideToCastle" "King" E 2 "KingNotCheckedAndToEmpty" (then ("CastleRook" "RookRight" W 2 True)))
)

(define "BigCastling"
    ("DecideToCastle" "King" W 2 "KingNotCheckedAndToEmpty" (then ("CastleRook" "RookLeft" E 3 True)))
)

(define "Castling"
    (if (and 
            ("HasNeverMoved" "King")
            (not ("IsInCheck" "King" Mover)) 
        )
        (or
            (if (and 
                    ("HasNeverMoved" "RookLeft")
                    (can Move ("CastleRook" "RookLeft" E 3 (is Empty (to))))
                )
                "BigCastling"
            )
            (if (and 
                    ("HasNeverMoved" "RookRight")
                    (can Move ("CastleRook" "RookRight" W 2 (is Empty (to))))
                )
                "SmallCastling"
            )
        )
    )
)

//**** Defines used to model the extra Pawn moves. ****
(define "SetEnPassantLocation"
    (then 
        (set Pending (ahead (last To) Backward))
    )
)

(define "InLocationEnPassant"
    (and 
        (is Pending) 
        (= (to) (value Pending)) 
    )
)

(define "EnPassant"
    (move Step 
        (directions {FR FL}) 
        (to if:"InLocationEnPassant") 
        (then 
            (remove 
                (ahead (last To) Backward)
            )
        )
    )
)

(define "InitialPawnMove"
    (if (is In (from) (sites Start (piece (what at:(from)))))
        ("DoubleStepForwardToEmpty" "SetEnPassantLocation")
    )
)

//------------------------------------------------------------------------------

(game "Chess" 
    ("TwoPlayersNorthSouth") 
    (equipment { 
        (board (square 8)) 
        
        ("ChessPawn" "Pawn"
            (or 
                "InitialPawnMove"
                "EnPassant"
            )
            (then 
                (and
                    ("ReplayInMovingOn" (sites Mover "Promotion"))
                    (set Counter)
                )
            )
        )
        ("ChessRook" "Rook" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessKing" "King" (then (set Counter)) ("RememberPieceHasMoved"))
        ("ChessBishop" "Bishop" (then (set Counter)))
        ("ChessKnight" "Knight" (then (set Counter)))
        ("ChessQueen" "Queen" (then (set Counter)))
        
        (map "King" {(pair 1 "E1") (pair 2 "E8")})
        (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")})
        (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})
        (regions "Promotion" P1 (sites Top))
        (regions "Promotion" P2 (sites Bottom))
    }) 
    (rules 
        (start { 
            (place "Pawn1" (sites Row 1))
            (place "Pawn2" (sites Row 6))
            (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) 
            (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1) 
        })
        
        (play 
            (if "SameTurn"
                (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover)
                (do 
                    (or 
                        (forEach Piece)
                        ("Castling")
                    )
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                )
            )
        )
        
        (end {
            ("Checkmate" "King")
            (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw)) 
        })
    )
)

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Ultimately originates from Indian Chaturanga, arrived in Western Europe during the Middle Ages as Shatranj. Over several centuries, after seeming experimentation with movement, the adoption of the modern movement of the queen and bishop made chess what it is today. Modern Chess appeared sometimes during the fourteenth or fifteenth Century, when the vizier piece was replaced by the queen. It since has become perhaps the most popular game in the world, with massive international competitions.")
        (aliases {"Mad Queen's Chess" "Queen's Chess" "Ã‰checs" "Schach" "Ajedrez" "Xadrez" "Scacchi"})
        (rules "Played on an 8x8 board with pieces with specialized moves: Pawns (8): can move one space forward; Rooks (2): can move any number of spaces orthogonally; Bishops (2): can move any number of spaces diagonally; Knight (2): moves in any direction, one space orthogonally with one space forward diagonally; Queens (1): can move any number of spaces orthogonally or diagonally; Kings (1): can move one space orthogonally or diagonally. Players capture pieces by moving onto a space occupied by an opponent's piece. Player wins when they checkmate the other player's king.")
        (source "<a href=\"https://en.wikipedia.org/wiki/Rules_of_chess\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (id "44")
        (version "1.3.11")
        (classification "board/war/replacement/checkmate/chess")
        (credit "Eric Piette")
        (origin "This game was played in Europe, from around 1475 to 2022.")
        }
    )
    
    (graphics {
        (show Check "King")
        (piece Scale "Pawn" 0.825)
        (piece Families {"Defined" "Microsoft" "Pragmata" "Symbola"})
        (board Style Chess)
    })
    
    (ai 
        "Chess_ai"
    )
    
)



symple

(define "Plant"
    (move Add
        (to 
            (sites Empty)
            if:(= 0
                (count Sites
                    in:(sites Around (to) Own Orthogonal)
                )
            )
        )
        (then ("UpdateScore"))
    )
)

(define "PlaceGrey"
    (do
        (move Add
            (piece "Marker0")
            (to
                (sites Empty)
                if:(< 0
                    (count Sites
                        in:(sites Around (to) Own Orthogonal)
                    )
                )
            )
        )
        ifAfterwards:(all Groups Orthogonal of:(is Mover (who at:(to)))
            if:(> 2
                (count Sites
                    in:(intersection
                        (sites Around (sites) NotEmpty Orthogonal)
                        (sites Occupied by:Neutral)
                    )
                )
            )
        )
        #1
    )
)

(define "ReplaceAllGrey"
    (add 
        (to 
            (sites Occupied by:Neutral)
            (apply (remove (to)))
        )
        (then 
            (if 
                (!= 1 (var "HasGrown"))
                (and
                    (   "HasGrown" 1)
                    (if 
                        (= (id P2) (mover))
                        (and
                            (set Var "MoveThatMustBePlant" (count Moves))
                            (moveAgain)
                        )
                    )
                )
            )
        )
    )
)

(define "Grow"
    ("PlaceGrey"
        (then 
            (if
                (can Move ("PlaceGrey" ~))
                (moveAgain)
                (do
                    ("ReplaceAllGrey")
                    next:("UpdateScore")
                )
            )
        )
    )
)

(define "UpdateScore"
    (set Score Mover
        (-
            (count Sites in:(sites Occupied by:Mover))
            (* <P>
                (count Groups Orthogonal if:(is Mover (who at:(to))))
            )
        )
    )
)

//-------------------------------------------------------------------------

(game "Symple"
    (players 2)
    (equipment {
        (board (square <Size>) use:Vertex)
        (piece "Marker" Each)
        (piece "Marker" Neutral)
    })
    (rules
        (play
            (if
                (= (count Moves) (var "MoveThatMustBePlant"))
                ("Plant")
                (if
                    (= 0 (count MovesThisTurn))
                    (or
                        ("Plant")
                        ("Grow")
                    )
                    ("Grow")
                )
            )
        )
        (end 
            (if (is Full) 
                (byScore)
            )
        )
    )
)

//-------------------------------------------------------------------------

(option "Board Size" <Size> args:{ <size> }
    {
    (item "7" <7> "A size 7 board is currently selected")
    (item "9" <9> "A size 9 board is currently selected")
    (item "11" <11> "A size 11 board is currently selected")
    (item "13" <13> "A size 13 board is currently selected")
    (item "15" <15> "A size 15 board is currently selected")
    (item "17" <17> "A size 17 board is currently selected")
    (item "19" <19> "A size 19 board is currently selected")*
    }
)

(option "Group Penalty" <P> args:{ <p> }
    {
    (item "0" <0> "A group penalty of 0 points is currently selected")
    (item "2" <2> "A group penalty of 2 points is currently selected")
    (item "4" <4> "A group penalty of 4 points is currently selected")
    (item "6" <6> "A group penalty of 6 points is currently selected")
    (item "8" <8> "A group penalty of 8 points is currently selected")
    (item "10" <10> "A group penalty of 10 points is currently selected")*
    (item "12" <12> "A group penalty of 12 points is currently selected")
    }
)

//-------------------------------------------------------------------------

(metadata
    (info
        {
        (description "Symple is an abstract strategy game in which two players strive to get as much area as possible with as few groups as possible.")
    (rules "Players alternate making a move. White plays with the white stones and makes the first move, Black plays with the black stones. On his turn, a player may choose either a) to place a stone on the board without contact to other stones of his color in order to start a new group, or b) to grow all possible groups by one stone. When you grow your groups in this implementation, you place grey stones adjacent to your groups until each of your groups is adjacent to exactly one grey stone. At no point may a group of yours be adjacent to more than one grey stone. When your turn ends, all grey stones are replaced with stones of your color.
    
    For balancing, there is an extra rule: Black is allowed to grow all his groups and place a single stone as long as neither player has not yet grown any groups.
    
The game ends when the board is filled in. The score is the number of stones each player has on the board minus 'P' times the number of groups he has, where 'P' is en even number of 4 or higher (the Ludii implementation also allows 0 and 2 as values of 'P'). With an even penalty and an odd boardsize, draws are not possible.")
(id "1962")
(source "<a href=\"https://boardgamegeek.com/boardgame/106341/symple\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />BGG</a>")
(version "1.3.11")
(classification "board/space/group")
(author "Christian Feeling, Benedick Rosenau")
(credit "Michael Amundsen")
(date "2010")
}
)

(graphics {
    (player Colour P1 (colour White))
    (player Colour P2 (colour Black))
    (player Colour Neutral (colour Grey))
    (board Colour InnerEdges (colour 178 151 100))
    (board Colour OuterEdges (colour 178 151 100))
    (board Colour Phase0 (colour 250 210 148))
    (board Colour Phase1 (colour 250 210 148))
    (board Style Board)
})
)



dominos

(game "Block" 
    (players 2) 
    (equipment { 
        (boardless Square) 
        (hand Each size:21)
        (dominoes)
    }) 
    (rules 
        (start {
            (deal Dominoes 7) 
            (set Hidden What (sites Hand P1) to:P2)
            (set Hidden What (sites Hand P2) to:P1)
        })
        (play
            (priority 
                {
                (do (move 
                        (from 
                            (forEach 
                                (sites Hand Mover) 
                                if:(is Occupied (site))
                            )
                        ) 
                        (to (sites LineOfPlay)) 
                        (then 
                            (and
                                (set Hidden What at:(last To) False to:P1)
                                (set Hidden What at:(last To) False to:P2)
                            )
                        )
                    ) 
                    ifAfterwards:(is PipsMatch)
                )
                (move Pass 
                    (then 
                        (if 
                            (!= (count Pieces "Bag") 0)
                            (and {
                                (take Domino)
                                (set Hidden What (sites Hand Mover) to:Next)
                                (moveAgain)
                            })
                        )
                    )
                )
                }
            )
        )
        (end {
            (if ("HandEmpty" Mover) (result Mover Win)) 
            (if (all Passed) (result Mover Draw)) 
        }) 
    )
)

//------------------------------------------------------------------------------

(metadata 
    (info
        {
        (description "One of the most commonly played Dominoes game, Block uses most of the rules shared by other Dominoes games worldwide.")
        (aliases {"Block Dominoes" "the Block Game" "Allies"})
        (rules "At the beginning of the game, each player has 7 dominoes. The goal of the game is to use all the dominoes on his hand. A Domino can be played only if it can be placed in the line of play. If this is not possible, the player has to take another domino from the remaining dominoes and add it to his hand until he is able to place one. If the two players can not play, this is a draw.")
        (source "Dominoes, Jennifer A. Kelley & Miguel Lugo, Sterling New york / London.")
        (id "554")
        (version "1.3.11")
        (classification "dominoes")
        (credit "Eric Piette")
        }
    )
    (ai 
        "Block_ai"
    )
)



quarto

(game "Quarto"
    (players 2)
    (equipment {
        (board (square 4) use:Vertex)
        (piece "Disc" Each)
        (piece "Square" Each)
        (hand Shared size:16)
    })
    (rules 
        (start {
            (place "Disc1" (handSite Shared 0))
            (place "Disc1" (handSite Shared 1) value:1)
            (place "Disc1" (handSite Shared 2) state:1)
            (place "Disc1" (handSite Shared 3) state:1 value:1)
            (place "Disc2" (handSite Shared 4))
            (place "Disc2" (handSite Shared 5) value:1)
            (place "Disc2" (handSite Shared 6) state:1)
            (place "Disc2" (handSite Shared 7) state:1 value:1)
            (place "Square1" (handSite Shared 8))
            (place "Square1" (handSite Shared 9) value:1)
            (place "Square1" (handSite Shared 10) state:1)
            (place "Square1" (handSite Shared 11) state:1 value:1)
            (place "Square2" (handSite Shared 12))
            (place "Square2" (handSite Shared 13) value:1)
            (place "Square2" (handSite Shared 14) state:1)
            (place "Square2" (handSite Shared 15) state:1 value:1)
        })
        phases:{
        (phase "Select" 
            (play 
                (move Select 
                    (from 
                        Cell
                        (difference 
                            (sites Hand Shared) 
                            (sites Empty 1)
                        )
                    )
                )
            )
            (nextPhase "Place")
        )
        (phase "Place" 
            (play
                (move 
                    (from Cell (last From))
                    (to (sites Empty))
                    (then (moveAgain))
                )
            )
            (end { 
                // Shape line (what)
                (if (is Line 4 All whats:{(id "Disc" P1) (id "Disc" P2)}) (result Mover Win))
                (if (is Line 4 All whats:{(id "Square" P1) (id "Square" P2)}) (result Mover Win))
                
                // Colour line (who)
                (if (is Line 4 All P1) (result Mover Win))
                (if (is Line 4 All P2) (result Mover Win))
                
                // State line (state)
                (if (is Line 4 All whats:{(id "Disc" P1) (id "Disc" P2) (id "Square" P1) (id "Square" P2)} if:(= 0 (state at:(to)))) (result Mover Win))
                (if (is Line 4 All whats:{(id "Disc" P1) (id "Disc" P2) (id "Square" P1) (id "Square" P2)} if:(= 1 (state at:(to)))) (result Mover Win))
                
                // Value line (value)
                (if (is Line 4 All whats:{(id "Disc" P1) (id "Disc" P2) (id "Square" P1) (id "Square" P2)} if:(= 0 (value Piece at:(to)))) (result Mover Win))
                (if (is Line 4 All whats:{(id "Disc" P1) (id "Disc" P2) (id "Square" P1) (id "Square" P2)} if:(= 1 (value Piece at:(to)))) (result Mover Win))
            })
            (nextPhase "Select")
        )
        }
    )
)

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Quarto has a 4Ãƒâ€”4 board and 16 pieces. Each piece has four dichotomous attributes Ã¢â‚¬â€œ color, height, shape, and consistency Ã¢â‚¬â€œ so each piece is either black or white, tall or short, square or round, and hollow or solid.")
        (rules "Each piece has four dichotomous attributes Ã¢â‚¬â€œ color, height, shape, and consistency Ã¢â‚¬â€œ so each piece is either black or white, tall or short, square or round, and hollow or solid. The object is to place the fourth piece in a row in which all four pieces have at least one attribute in common. The twist is that your opponent gets to choose the piece you place on the board each turn.")
        (id "1536")
        (source "<a href=\"https://boardgamegeek.com/boardgame/681/quarto\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />BGG</a>")
        (version "1.3.11")
        (classification "board/space/line")
        (author "Blaise Muller")
        (publisher "<a href=\"https://www.gigamic.com/\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Gigamic</a> (used with permission)")
        (credit "Eric Piette")
        (date "1991")
        }
    )
    
    (graphics {
        (piece Scale "Disc" 0.7)
        (piece Scale "Square" 0.7)
        (piece Foreground state:1 image:"Disc" fillColour:(colour Hidden) edgeColour:(colour Orange) scale:0.5)
        (piece Foreground value:1 image:"Square" fillColour:(colour Hidden) edgeColour:(colour Orange) scale:0.3)
        
        (show Edges Hidden)
        (show Symbol "Disc" (sites Board) fillColour:(colour 185 130 85) edgeColour:(colour 225 182 130)) 
        (board Placement scale:0.8)
        (board Background image:"square.svg" fillColour:(colour 185 130 85) edgeColour:(colour 185 130 85) scale:1.45)
    })
    
    (ai
        "Quarto_ai"
    )
)





oware


(define "PiecesOwnedBy" (+ (count at:(mapEntry #1)) (count in:(sites #1))))

//------------------------------------------------------------------------------

(game "Oware" 
    (players 2) 
    (equipment { 
        (mancalaBoard 2 6
            (track "Track" "1,E,N,W" loop:True)
        )
        (regions P1 (sites Bottom))      // P1 home
        (regions P2 (sites Top))      // P2 home
        (map {(pair P1 FirstSite) (pair P2 LastSite)}) // kalahs (storage pits)
        (piece "Seed" Shared)
    }) 
    
    (rules 
        (start (set Count 4 to:(sites Track)))		 
        (play 
            (if (is Proposed "End")
                (or (move Vote "End") (move Vote "No"))
                (or
                    (if (is Cycle) (move Propose "End")) 
                    (do 
                        (move Select 
                            (from 
                                (sites Mover) 
                                if:(< 0 (count at:(from)))
                            )
                            (then 
                                (sow 
                                    if:(and 
                                        (is In (to) (sites Next)) 
                                        (or 
                                            (= (count at:(to)) 2) 
                                            (= (count at:(to)) 3)
                                        )
                                    ) 
                                    apply:(fromTo 
                                        (from (to)) 
                                        (to (mapEntry (mover))) 
                                        count:(count at:(to))
                                    )
                                    includeSelf:False
                                    <Skip>
                                    backtracking:True
                                )
                            )
                        )
                        ifAfterwards:(< 0 (count in:(sites Next)))
                    )
                )
            )
        )
        <End:rule>
    )
)

//------------------------------------------------------------------------------

(option "Play Rules" <Skip> args:{ <rule> }
    {
    (item "No limit by hole" 
        <
        >  
        ""
    )
    (item "12 counters max by hole" 
        <
        skipIf:(>= (count at:(to)) 12)
        >  
        "12 counters max by hole."
    )
})

(option "End Rules" <End> args:{ <rule> }
    {
    (item "No Piece" 
        <
        (end
            (if (or (no Moves Mover) (is Decided "End"))
                (byScore {
                    (score P1 ("PiecesOwnedBy" P1)) 
                    (score P2 ("PiecesOwnedBy" P2))
                })
            )
        )
        >  
        "The game ended when a player has no piece on his side or if the two players are agree on the end of the game in case a cycle."
    ) 
    (item "25 Counters" 
        <
        (end
            {
            (if (>= (count at:(mapEntry P1)) 25)
                (result P1 Win)
            )
            (if (>= (count at:(mapEntry P2)) 25)
                (result P2 Win)
            )
            }
        )
        >  
        "A player wins when he captures 25 (or more) counters."
    ) 
})

//------------------------------------------------------------------------------

(rulesets { 
    
    (ruleset "Ruleset/Wari (Observed)" {
        "Play Rules/No limit by hole" "End Rules/No Piece"
    })*
    
    (ruleset "Ruleset/Awari (Suggested)" {
        "Play Rules/12 counters max by hole" "End Rules/25 Counters"
    })
    
})

//------------------------------------------------------------------------------

(metadata 
    (info
        {
        (description "Oware is two-row mancala-style game originating and very popular in West Africa. It is also widely played in the Caribbean. It is played on a board with two rows of six holes, sometimes with a larger hole on both ends.")
        (aliases {"AyÃƒÂ²" "Ayoayo" "AwalÃƒÂ©" "Wari" "Ouri" "Ourii" "Uri" "Warri" "Wall" "Adji" "Ncho" "OkwÃƒÂ¨" "Awale" "Awari"})
        (useFor "Ruleset/Wari (Observed)" (rules "2x6 board, with a storage hole on either end. The game starts with four counters in each hole. A player picks up all of the counters in one of the holes in their row and sows them one-by-one in a counterclockwise direction in consecutive holes from the hole the pieces originated. The starting hole is always left empty, even if a player sows in a complete circuit of the board, the original house is skipped and sowing continues in the next hole after it. Players capture counters when the final counter is sown in the opponent's row and the hole containing it has two or three counters (counting the counter just dropped into it). If the hole before it also has two or three counters, these are also captured and so on until reaching a hole without two or three counters or one not belonging to the opponent. A move which would capture all of the opponent's counters is not allowed. If an opponent's holes are all empty, the other player must make a move placing counters in the opponent's row. If not possible, the player captures all the counters in their row. Play continues until all of the counters are captured. The player who has captured the most counters wins. If the game continues in a repeating loop, the players can agree to end the game and capture the counters remaining in their row."))
        (useFor "Ruleset/Wari (Observed)" (source "Bennett 1927: 382-385."))
        (useFor "Ruleset/Wari (Observed)" (id "69"))
        (useFor "Ruleset/Awari (Suggested)" (rules "Counters cannot be sown in holes with 12 or more counters in them. Instead, the counter that would have been sown is sown in the following hole. The player who captures 25 counters wins."))
        (useFor "Ruleset/Awari (Suggested)" (source "https://en.wikipedia.org/wiki/Oware"))
        (useFor "Ruleset/Awari (Suggested)" (id "628"))
        (source "Murray 1951: 181Ã¢â‚¬â€œ182.")
        (id "69")
        (version "1.3.11")
        (classification "board/sow/two rows")
        (credit "Eric Piette")
        (origin "This game was played in West Africa, around 1927.")
        }
    )
    
    (graphics {
        (board Style Mancala)
    })
    
    (ai 
        "Oware_ai"
    )
)


2048

(define "CanSlide"
    (not (all Sites (difference (sites Occupied by:Shared) (sites #1))
            if:(and
                (= 0 (count Sites in:(sites LineOfSight Farthest at:(site) #2)))
                (!= 
                    (what at:(site))
                    (what at:(regionSite (sites LineOfSight Piece at:(site) #2) index:0))
                )
            )
        )
    )
)

(define "CanSlideW" ("CanSlide" Left W))
(define "CanSlideE" ("CanSlide" Right E))
(define "CanSlideN" ("CanSlide" Top N))
(define "CanSlideS" ("CanSlide" Bottom S))

(define "SlideW" (move Select (from 6) (to 5) (then #1)))
(define "SlideE" (move Select (from 5) (to 6) (then #1)))
(define "SlideN" (move Select (from 6) (to 10) (then #1)))
(define "SlideS" (move Select (from 10) (to 6) (then #1)))

(define "LineOfSightPiece" (regionSite (sites LineOfSight Piece at:(site) #1) index:0))
(define "LineOfSightEmpty" (sites LineOfSight Farthest at:(site) #1))

(define "ApplySlideLine"
    (forEach Site (sites #1 #2)
        (if (is Occupied (site))
            (if 
                (and
                    (= 
                        (what at:(site))
                        (what at:("LineOfSightPiece" #3))
                    )
                    (= 0 (state at:("LineOfSightPiece" #3)))
                )
                (and {
                    (remove (site))
                    (remove ("LineOfSightPiece" #3))
                    (add 
                        (piece (mapEntry "Promotion" (what at:(site))))
                        (to ("LineOfSightPiece" #3))
                    )
                    (set State at:("LineOfSightPiece" #3) 1)
                    (addScore P1 (mapEntry "Score" (mapEntry "Promotion" (what at:(site)))))
                })
                (if (!= 0 (count Sites in:("LineOfSightEmpty" #3)))
                    (fromTo (from (site)) (to ("LineOfSightEmpty" #3)))
                )
            )
        )
    )
)

(define "ResetState" (forEach Site (sites State 1) (set State at:(site) 0)))

(define "ApplySlideW"
    (seq {
        ("ApplySlideLine" Column 1 W)
        ("ApplySlideLine" Column 2 W)
        ("ApplySlideLine" Column 3 W)
        ("ResetState")
    })
)

(define "ApplySlideE"
    (seq {
        ("ApplySlideLine" Column 2 E)
        ("ApplySlideLine" Column 1 E)
        ("ApplySlideLine" Column 0 E)
        ("ResetState")
    })
)

(define "ApplySlideN"
    (seq {
        ("ApplySlideLine" Row 2 N)
        ("ApplySlideLine" Row 1 N)
        ("ApplySlideLine" Row 0 N)
        ("ResetState")
    })
)

(define "ApplySlideS"
    (seq {
        ("ApplySlideLine" Row 1 S)
        ("ApplySlideLine" Row 2 S)
        ("ApplySlideLine" Row 3 S)
        ("ResetState")
    })
)

//------------------------------------------------------------------------------

(game "2048"
    (players 1)
    (equipment {
        (board (square 4))
        (piece "Square2" Shared)
        (piece "Square4" Shared)
        (piece "Square8" Shared)
        (piece "Square16" Shared)
        (piece "Square32" Shared)
        (piece "Square64" Shared)
        (piece "Square128" Shared)
        (piece "Square256" Shared)
        (piece "Square512" Shared)
        (piece "Square1024" Shared)
        (piece "Square2048" Shared) 
        (map "Promotion" {
            (pair (id "Square2" Shared) (id "Square4" Shared))
            (pair (id "Square4" Shared) (id "Square8" Shared))
            (pair (id "Square8" Shared) (id "Square16" Shared))
            (pair (id "Square16" Shared) (id "Square32" Shared))
            (pair (id "Square32" Shared) (id "Square64" Shared))
            (pair (id "Square64" Shared) (id "Square128" Shared))
            (pair (id "Square128" Shared) (id "Square256" Shared))
            (pair (id "Square256" Shared) (id "Square512" Shared))
            (pair (id "Square512" Shared) (id "Square1024" Shared))
            (pair (id "Square1024" Shared) (id "Square2048" Shared))
        })
        (map "Score" {
            (pair (id "Square2" Shared) 2)
            (pair (id "Square4" Shared) 4)
            (pair (id "Square8" Shared) 8)
            (pair (id "Square16" Shared) 16)
            (pair (id "Square32" Shared) 32)
            (pair (id "Square64" Shared) 64)
            (pair (id "Square128" Shared) 128)
            (pair (id "Square256" Shared) 256)
            (pair (id "Square512" Shared) 512)
            (pair (id "Square1024" Shared) 1024)
            (pair (id "Square2048" Shared) 2048)
        })
    })
    (rules
        (start (place Random {"Square2"} count:2))
        (play 
            (or {
                (if ("CanSlideW")
                    ("SlideW"
                        ("ApplySlideW")
                    )
                )
                (if ("CanSlideE")
                    ("SlideE"
                        ("ApplySlideE")
                    )
                )
                (if ("CanSlideN")
                    ("SlideN"
                        ("ApplySlideN")
                    )
                )
                (if ("CanSlideS")
                    ("SlideS"
                        ("ApplySlideS")
                    )
                )
                }
                (then
                    (if (< (value Random (range 1 8)) 2)
                        (add (piece "Square4") (to (sites Random (sites Empty) num:1)))
                        (add (piece "Square2") (to (sites Random (sites Empty) num:1)))
                    )		
                )
            )
        )
        (end {
            (if ("IsNotOffBoard" (where "Square2048" Shared)) (result Mover Win))
            (if (no Moves Next) (result Mover Loss))
        })
    )
)

//------------------------------------------------------------------------------

(metadata 
    (info
        {
        (description "2048 is a single-player sliding tile puzzle video game written by Italian web developer Gabriele Cirulli and published on GitHub.")
        (rules "2048 is played on a plain 4Ãƒâ€”4 grid, with numbered tiles that slide when a player moves them. Every turn, a new tile randomly appears in an empty spot on the board with a value of either 2 or 4. Tiles slide as far as possible in the chosen direction until they are stopped by either another tile or the edge of the grid. If two tiles of the same number collide while moving, they will merge into a tile with the total value of the two tiles that collided. The resulting tile cannot merge with another tile again in the same move. The game is won when a tile with a value of 2048 appears on the board.")
        (id "1979")
        (source "<a href=\"https://en.wikipedia.org/wiki/2048_(video_game)\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (version "1.3.11")
        (classification "puzzle/planning")
        (author "Gabriele Cirulli")
        (credit "Eric Piette")
        (date "14-03-2014")
        }
    )
    
    (graphics {
        (board Colour Phase0 (colour 205 193 179))
        (board Colour InnerEdges (colour 187 173 160))
        (board Colour OuterEdges (colour 187 173 160))
        (piece Colour Shared "Square2" fillColour:(colour 238 228 218))
        (piece Colour Shared "Square4" fillColour:(colour 236 224 200))
        (piece Colour Shared "Square8" fillColour:(colour 242 177 121))
        (piece Colour Shared "Square16" fillColour:(colour 245 149 99))
        (piece Colour Shared "Square32" fillColour:(colour 244 125 93))
        (piece Colour Shared "Square64" fillColour:(colour 246 93 59))
        (piece Colour Shared "Square128" fillColour:(colour 237 206 113))
        (piece Colour Shared "Square256" fillColour:(colour 237 204 97))
        (piece Colour Shared "Square512" fillColour:(colour 236 200 80))
        (piece Colour Shared "Square1024" fillColour:(colour 255 178 103))
        (piece Colour Shared "Square2048" fillColour:(colour 241 194 44))
        (piece Foreground "Square2" image:"2" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.4)
        (piece Foreground "Square4" image:"4" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.4)
        (piece Foreground "Square8" image:"8" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.4)
        (piece Foreground "Square16" image:"1" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.4 offsetX:-0.6)
        (piece Foreground "Square16" image:"6" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.4 offsetX:0.4)
        (piece Foreground "Square32" image:"3" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.4 offsetX:-0.6)
        (piece Foreground "Square32" image:"2" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.4 offsetX:0.4)
        (piece Foreground "Square64" image:"6" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.4 offsetX:-0.6)
        (piece Foreground "Square64" image:"4" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.4 offsetX:0.4)
        (piece Foreground "Square128" image:"1" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.3 offsetX:-0.7)
        (piece Foreground "Square128" image:"2" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.3 offsetX:-0.1)
        (piece Foreground "Square128" image:"8" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.3 offsetX:0.5)
        (piece Foreground "Square256" image:"2" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.3 offsetX:-0.7)
        (piece Foreground "Square256" image:"5" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.3 offsetX:-0.1)
        (piece Foreground "Square256" image:"6" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.3 offsetX:0.5)
        (piece Foreground "Square512" image:"5" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.3 offsetX:-0.7)
        (piece Foreground "Square512" image:"1" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.3 offsetX:-0.1)
        (piece Foreground "Square512" image:"2" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.3 offsetX:0.5)
        (piece Foreground "Square1024" image:"1" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.2 offsetX:-0.6)
        (piece Foreground "Square1024" image:"0" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.2 offsetX:-0.2)
        (piece Foreground "Square1024" image:"2" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.2 offsetX:0.2)
        (piece Foreground "Square1024" image:"4" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.2 offsetX:0.6)
        (piece Foreground "Square2048" image:"2" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.2 offsetX:-0.6)
        (piece Foreground "Square2048" image:"0" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.2 offsetX:-0.2)
        (piece Foreground "Square2048" image:"4" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.2 offsetX:0.2)
        (piece Foreground "Square2048" image:"8" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.2 offsetX:0.6)
    })
)




nim

(game "Nim" 
    (players 2) 
    (equipment { 
        (board (rectangle 1 <Size:board>)) 
        (piece "Marker" Neutral)
    }) 
    (rules
        (start  		
            <Size:piles>
        ) 
        
        (play 
            (if "SameTurn"
                (or
                    (move Select 
                        (from (last To))
                        (then 
                            (if (= (count at:(last To)) 1)
                                (remove (last To))
                                (and (set Count at:(last To) (- (count at:(last To)) 1)) (moveAgain)) 
                            )
                        ) 
                    )
                    (move Pass)
                )
                (move Select
                    (from (sites Occupied by:Neutral))
                    (then 
                        (if (= (count at:(last To)) 1)
                            (remove (last To))
                            (and (set Count at:(last To) (- (count at:(last To)) 1)) (moveAgain)) 
                        )
                    ) 
                )
            )
        ) 
        (end (if (no Moves Next) (result <Result> Win)))
    )
)

//------------------------------------------------------------------------------

(option "End Rules" <Result> args:{ <type> }
    {
    (item "Last Mover Loses" <Next>  "The last mover loses.")* 
    (item "Last Mover Wins" <Mover> "The last mover wins.") 
})

(option "Number Piles" <Size> args:{ <board> <piles> }
    {
    (item "3" <3> 
        <{
        (set Count 1 to:(sites {0 2}))
        (set Count 2 at:1)
        }>              
        "The game involves 3 piles."
    ) 
    (item "5" <5> 
        <{
        (set Count 3 to:(sites {0 4}))
        (set Count 4 to:(sites {1 3}))
        (set Count 5 at:2)
        }>             
    "The game involves 5 piles.")*  
    (item "7" <7> 
        <{
        (set Count 4 to:(sites {0 6}))
        (set Count 5 to:(sites {1 5}))
        (set Count 6 to:(sites {2 4}))
        (set Count 7 at:3)
        }>            
    "The game involves 7 piles.")  
    (item "9" <9> 
        <{
        (set Count 5 to:(sites {0 8}))
        (set Count 6 to:(sites {1 7}))
        (set Count 7 to:(sites {2 6}))
        (set Count 8 to:(sites {3 5}))
        (set Count 9 at:4)
        }>           
    "The game involves 9 piles.")  
    (item "11" <11> 
        <{
        (set Count 6 to:(sites {0 10}))
        (set Count 7 to:(sites {1 9}))
        (set Count 8 to:(sites {2 8}))
        (set Count 9 to:(sites {3 7}))
        (set Count 10 to:(sites {4 6}))
        (set Count 11 at:5)
        }>         
        
    "The game involves 11 piles.")  
    (item "13" <13> 
        <{
        (set Count 7 to:(sites {0 12}))
        (set Count 8 to:(sites {1 11}))
        (set Count 9 to:(sites {2 10}))
        (set Count 10 to:(sites {3 9}))
        (set Count 11 to:(sites {4 8}))
        (set Count 12 to:(sites {5 7}))
        (set Count 13 at:6)
        }>       
    "The game involves 13 piles.") 
    (item "15" <15> 
        <{
        (set Count 8 to:(sites {0 14}))
        (set Count 9 to:(sites {1 13}))
        (set Count 10 to:(sites {2 12}))
        (set Count 11 to:(sites {3 11}))
        (set Count 12 to:(sites {4 10}))
        (set Count 13 to:(sites {5 9}))
        (set Count 14 to:(sites {6 8}))
        (set Count 15 at:7)
        }>     
    "The game involves 15 piles.") 
    (item "17" <17> 
        <{
        (set Count 9 to:(sites {0 16}))
        (set Count 10 to:(sites {1 15}))
        (set Count 11 to:(sites {2 14}))
        (set Count 12 to:(sites {3 13}))
        (set Count 13 to:(sites {4 12}))
        (set Count 14 to:(sites {5 11}))
        (set Count 15 to:(sites {6 10}))
        (set Count 16 to:(sites {7 9}))
        (set Count 17 at:8)
        }>   
    "The game involves 17 piles.") 
    (item "19" <19> <{
        (set Count 10 to:(sites {0 18}))
        (set Count 11 to:(sites {1 17}))
        (set Count 12 to:(sites {2 16}))
        (set Count 13 to:(sites {3 15}))
        (set Count 14 to:(sites {4 14}))
        (set Count 15 to:(sites {5 13}))
        (set Count 16 to:(sites {6 12}))
        (set Count 17 to:(sites {7 11}))
        (set Count 18 to:(sites {8 10}))
        (set Count 19 at:9)
        }> 
    "The game involves 19 piles.") 
    }
)

//------------------------------------------------------------------------------

(rulesets { 
    
    (ruleset "Ruleset/Basic (Described)" {
        "Number Piles/5"
        }
        variations:{"Number Piles/3" "Number Piles/7" "Number Piles/9" "Number Piles/11"
        "Number Piles/13" "Number Piles/15" "Number Piles/17"
        }
    )*
    
})

(metadata
    
    (info
        {
        (description "Nim is a game of uncertain origins. It is first mentioned by Luca Paccioli, an Italian mathematician in the early sixteenth or late fifteenth century. It is similar to other games worldwide, but multiple independent inventions may be possible, not necessarily the dispersion of a single game.")
        (rules "Essentially, the game consists of a number of objects in \"heaps,\" and players alternate turns taking any number of objects from one of the heaps. This continues until no objects are left, and the last player to remove an object loses.")
        (source "<a href=\"https://en.wikipedia.org/wiki/Nim\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (id "130")
        (version "1.3.11")
        (classification "math/nim")
        (credit "Eric Piette")
        (origin "This game was played in Europe?, from around 1496 to 1517.")
        }
    )
    
    (graphics {
        (no Board)
    })
    (ai
        "Nim_ai"
    )
)


quoridor


(define "EdgeInCommon" 
    (intersection (sites Incident Edge of:Cell at:#1) 
        (sites Incident Edge of:Cell at:#2)
    ) 
)

(define "NoEdgeBetweenCells"
    (all Sites (sites Occupied by:Shared on:Edge) if:(not (is In (site) ("EdgeInCommon" #1 #2))))
)

(define "ReachedTarget" (and (is LastTo Cell) (is In (last To) (sites Mover))))

(define "SizePath" 
    (count Steps
        (step
            Orthogonal
            (to 
                if:(and 
                    (is Empty (to)) 
                    ("NoEdgeBetweenCells" (from) (to))
                )
            )
        )
        (where "Pawn" #1)
        (sites #1)
    )	
)

(define "NumPlayers" <Players:num>)

//------------------------------------------------------------------------------

(game "Quoridor" 
    (players "NumPlayers")
    (equipment {
        (board (square 9))
        (piece "Pawn" Each
            (or
                (move Step
                    Orthogonal
                    (to 
                        if:(and 
                            (is Empty (to)) 
                            ("NoEdgeBetweenCells" (from) (to))
                        )
                    )
                )
                (move Hop
                    Orthogonal
                    (between if:("IsEnemyAt" (between)))
                    (to if:(and {
                            (is Empty (to))
                            ("NoEdgeBetweenCells" (from) (between))
                            ("NoEdgeBetweenCells" (between) (to))
                        })
                    )
                )
            )
        )
        (piece "Rectangle" Shared)
        (hand Each)
        <Players:regions>
    })
    (rules 
        <Players:start>
        (play 
            (or
                (do
                    (if (is Occupied (handSite Mover))
                        (move 
                            (from (handSite Mover)) 
                            (to Edge (difference (sites Empty Edge) (sites Outer Edge)))
                        )
                    )
                    ifAfterwards:<Players:pathRule>
                )
                (forEach Piece)
            )
        )
        (end (if "ReachedTarget" (result Mover Win))) 
    )
)

//------------------------------------------------------------------------------

(option "Players " <Players> args:{ <num> <regions> <start> <pathRule>} {
    (item "2" <2> 
        <
        (regions P1 (sites Top))
        (regions P2 (sites Bottom))
        >
        <
        (start {
            (place "Rectangle" (handSite P1) count:10)
            (place "Rectangle" (handSite P2) count:10)
            (place "Pawn1" (intersection (sites Bottom) (sites Column (column of:(centrePoint)))))
            (place "Pawn2" (intersection (sites Top) (sites Column (column of:(centrePoint)))))
        })
        >
        <
        (and {
            (!= Infinity ("SizePath" P1))
            (!= Infinity ("SizePath" P2))
        })
        >
    "The game has 2 players")* 
    (item "4" <4> 
        <
        (regions P1 (sites Top))
        (regions P2 (sites Bottom))
        (regions P3 (sites Right))
        (regions P4 (sites Left))
        >
        <
        (start {
            (place "Rectangle" (handSite P1) count:5)
            (place "Rectangle" (handSite P2) count:5)
            (place "Rectangle" (handSite P3) count:5)
            (place "Rectangle" (handSite P4) count:5)
            (place "Pawn1" (intersection (sites Bottom) (sites Column (column of:(centrePoint)))))
            (place "Pawn2" (intersection (sites Top) (sites Column (column of:(centrePoint)))))
            (place "Pawn3" (intersection (sites Left) (sites Row (row of:(centrePoint)))))
            (place "Pawn4" (intersection (sites Right) (sites Row (row of:(centrePoint)))))
        })
        >
        <
        (and {
            (!= Infinity ("SizePath" P1))
            (!= Infinity ("SizePath" P2))
            (!= Infinity ("SizePath" P3))
            (!= Infinity ("SizePath" P4))
        })
        >
    "The game has 4 players.") 
})

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Quoridor is a 2 or 4-player intuitive strategy game designed by Mirko Marchesi and published by Gigamic Games. Quoridor received the Mensa Mind Game award in 1997 and the Game Of The Year in the USA, France, Canada and Belgium")
        (rules "The abstract strategy game Quoridor is surprisingly deep for its simple rules. The object of the game is to advance your pawn to the opposite edge of the board. On your turn you may either move your pawn or place a wall. You may hinder your opponent with wall placement, but not completely block them off. Meanwhile, they are trying to do the same to you. The first pawn to reach the opposite side wins.")
        (id "1539")
        (source "<a href=\"https://boardgamegeek.com/boardgame/624/quoridor\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />BGG</a>")
        (version "1.3.11")
        (classification "board/race/reach")
        (author "Mirko Marchesi")
        (publisher "<a href=\"https://www.gigamic.com/\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Gigamic</a> (used with permission)")
        (credit "Eric Piette")
        (date "1997")
        }
    )
    
    (graphics {
        (player Colour Shared (colour Yellow))
        (board Style PenAndPaper)
        (board Colour InnerVertices (colour Hidden))
        (board Colour OuterVertices (colour Hidden))
        (show Symbol "Square" (sites Board) fillColour:(colour 110 52 52) scale:0.9) 
        
        (piece Scale "Pawn" 0.825)
        (board Placement scale:0.9)
        (hand Placement P1 scale:0.1 offsetX:0.45 offsetY:0.1)
        (hand Placement P2 scale:0.1 offsetX:0.45 offsetY:0.95)
        (hand Placement P3 scale:0.1 offsetX:0.025 offsetY:0.5)
        (hand Placement P4 scale:0.1 offsetX:0.875 offsetY:0.5)
    })
    (ai
        "Quoridor_ai"
    )
)

amazons

(game "Amazons" 
    (players 2) 
    (equipment { 
        (board (square 10)) 
        (piece "Queen" Each (move Slide (then (moveAgain))))
        (piece "Dot" Neutral)
    }) 
    (rules 
        (start { 
            (place "Queen1" {"A4" "D1" "G1" "J4"})
            (place "Queen2" {"A7" "D10" "G10" "J7"})
        })
        
        (play 
            (if (is Even (count Moves))
                (forEach Piece)
                (move Shoot (piece "Dot0"))
            )
        )
        
        (end ("BlockWin"))
    )
)

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Invented in 1988 by Walter Zamkauskas and first published in the Argentine magazine El Acertijo in December 1992.")
        (rules "Played on a 10x10 board. Each player has four Amazons (chess queens), with other pieces used as arrows. Two things happen on a turn: an amazon moves like a Chess queen, but cannot cross or enter a space occupied by another amazon or arrow. Then, it shoots an arrow to any space on the board that is along the path of a queen's move from that place. The last player able to make a move wins.")
        (source "<a href=\"https://en.wikipedia.org/wiki/Game_of_the_Amazons\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (id "79")
        (version "1.3.11")
        (classification "board/space/blocking")
        (author "Walter Zamkauskas")
        (credit "Eric Piette")
        (origin "This game is from Argentina, on 1988.")
        }
    )
    
    (graphics {
        (piece Scale "Dot" 0.333)
        (board Style Chess)
    })
    
    (ai 
        "Amazons_ai"
    )
    
)

stratego 


(define "FlagIsCaptured" (trigger "FlagCaptured" (next)))

(define "FlagWasCaptured" (is Triggered "FlagCaptured" (next)))

(define "RestoredPiecesAndMakeThemVisible"
    (and { 
        (fromTo (from) (to (mapEntry (what at:(from))))) 
        (fromTo (from (to)) (to (mapEntry (what at:(to))))) 
        (set Visible (mapEntry (what at:(from)))) 
        (set Visible (mapEntry (what at:(to))))
    })  
)

(define "CaptureToPieceAndMakeThemVisisible"
    (and { 
        (fromTo (from (to)) (to (mapEntry (what at:(to))))) 
        (fromTo (from) (to)) 
        (set Visible (mapEntry (what at:(to)))) 
        (set Visible (to) Next)
    })  
)

(define "CaptureToPieceAndMoveFromPieceAndMakeThemVisisible"
    (and {
        (fromTo (from (to)) (to (mapEntry (what at:(to))))) 
        (fromTo (from) (to)) 
        (set Visible (mapEntry (what at:(to)))) 
        (set Visible (from) Next)
    }) 
)

(define "CaptureFromPieceAndMakeThemVisisible"
    (and {
        (fromTo (from) (to (mapEntry (what at:(from))))) 
        (set Visible (mapEntry (what at:(from)))) 
        (set Visible (to) Mover)
    }) 
)

(define "Capture" 
    if:(is Enemy (who at:(to))) 
    (if (and 
            (!= (what at:(to)) (id "Bomb" Next)) 
            (!= (what at:(to)) (id "Flag" Next))
        )
        (if (= (value Piece of:(what at:(to))) (value Piece of:(what at:(from))))
            "RestoredPiecesAndMakeThemVisible"
            (if (< (value Piece of:(what at:(to))) (value Piece of:(what at:(from))))
                "CaptureToPieceAndMakeThemVisisible"
                (if (< (value Piece of:(what at:(from))) (value Piece of:(what at:(to))))
                    (if (and 
                            (= (what at:(from)) (id "Spy" Mover)) 
                            (= (what at:(to)) (id "Marshal" Next))
                        )
                        "CaptureToPieceAndMoveFromPieceAndMakeThemVisisible"
                        "CaptureFromPieceAndMakeThemVisisible"
                    )
                )
            )
        )
        (if (= (what at:(to)) (id "Bomb" Next))
            (if (= (what at:(from)) (id "Miner" Mover))
                (and { 
                    (fromTo (from (to)) (to (mapEntry (what at:(to))))) 
                    (set Visible (mapEntry (what at:(to)))) 
                    (fromTo (from) (to)) 
                    (set Visible (from) Next) 
                })
                "CaptureFromPieceAndMakeThemVisisible"
            )
            (if (= (what at:(to)) (id "Flag" Next))
                (and 
                    "FlagIsCaptured" 
                    (remove (to))
                )
            )
        )
    )
)

//------------------------------------------------------------------------------

(game "Stratego"  
    (players 2)  
    
    (equipment { 
        (board 
            (hole 
                (hole 
                    (square 10) 
                    (poly { {2 4} {4 4} {4 6} {2 6} })
                ) 
                (poly { {6 4} {8 4} {8 6} {6 6} })
            )
        ) 
        (hand Each size:12)
        
        (piece "Marshal" Each value:10)
        (piece "General" Each value:9)
        (piece "Colonel" Each value:8)
        (piece "Major" Each value:7)
        (piece "Captain" Each value:6)
        (piece "Lieutenant" Each value:5)
        (piece "Sergeant" Each value:4)
        (piece "Miner" Each value:3)
        (piece "Scout" Each value:2)
        (piece "Spy" Each value:1)
        (piece "Flag" Each)
        (piece "Bomb" Each)
        
        (regions "HomeP1" P1 (expand (sites Bottom) steps:3) )
        (regions "HomeP2" P2 (expand (sites Top) steps:3) )
        (map { (pair 1 92) (pair 2 104) (pair 3 93) (pair 4 105) (pair 5 94) (pair 6 106) (pair 7 95) 
            (pair 8 107) (pair 9 96) (pair 10 108) (pair 11 97) (pair 12 109) (pair 13 98) (pair 14 110) (pair 15 99) (pair 16 111) (pair 17 100) (pair 18 112) (pair 19 101) (pair 20 113) (pair 21 102) 
        (pair 22 114) (pair 23 103) (pair 24 115)})
    })  
    
    (rules 
        (start { <Version> })
        
        phases:{
        (phase "Placement" 
            (play 
                (move 
                    (from (sites Occupied by:Mover container:(mover))) 
                    (to 
                        (intersection 
                            (sites Mover "Home") 
                            (sites Empty)
                        )
                    ) 
                    (then 
                        (if 
                            ("HandEmpty" P2) 
                            (and 
                                (set Masked (sites P2 "Home") P1) 
                                (set Masked (sites P1 "Home") P2)
                            ) 
                        ) 
                    )
                )
            ) 
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        (phase "Movement" 
            (play
                (or 
                    (forEach Piece {"Marshal" "General" "Colonel" "Major" "Captain" "Lieutenant" "Sergeant" "Miner" "Spy"} 
                        (move
                            Step
                            Orthogonal 
                            (to 
                                if:(or (is Empty (to)) (is Enemy (who at:(to)))) 
                                (apply "Capture")
                            )
                        )
                    )
                    (forEach Piece "Scout" 
                        (move
                            Slide
                            Orthogonal 
                            (to
                                if:(is Enemy (who at:(to))) 
                                (apply "Capture")
                            ) 
                        )
                    )
                )
            )
            (end (if (or (no Moves Next) "FlagWasCaptured" ) (result Mover Win))) 
        )
        }
        
    )
)

//------------------------------------------------------------------------------

(option "Version" <Version> args:{ <start> }
    {
    (item "Normal"   
        <
        (place "Marshal1" 92 invisibleTo:{P2}) (place "General1" 93 invisibleTo:{P2}) (place "Colonel1" 94 count:2 invisibleTo:{P2}) (place "Major1" 95 count:3 invisibleTo:{P2}) (place "Captain1" 96 count:4 invisibleTo:{P2})
        (place "Lieutenant1" 97 count:4 invisibleTo:{P2}) (place "Sergeant1" 98 count:4 invisibleTo:{P2}) (place "Miner1" 99 count:5 invisibleTo:{P2}) (place "Scout1" 100 count:8 invisibleTo:{P2}) (place "Spy1" 101 invisibleTo:{P2})
        (place "Flag1" 102 invisibleTo:{P2}) (place "Bomb1" 103 count:6 invisibleTo:{P2})
        
        (place "Marshal2" 104 invisibleTo:{P1}) (place "General2" 105 invisibleTo:{P1}) (place "Colonel2" 106 count:2 invisibleTo:{P1}) (place "Major2" 107 count:3 invisibleTo:{P1}) (place "Captain2" 108 count:4 invisibleTo:{P1})
        (place "Lieutenant2" 109 count:4 invisibleTo:{P1}) (place "Sergeant2" 110 count:4 invisibleTo:{P1}) (place "Miner2" 111 count:5 invisibleTo:{P1}) (place "Scout2" 112 count:8 invisibleTo:{P1}) (place "Spy2" 113 invisibleTo:{P1})
        (place "Flag2" 114 invisibleTo:{P1}) (place "Bomb2" 115 count:6 invisibleTo:{P1})
        >   
        "The game is played with the full set of pieces."
    )**   
    (item "Normal"   
        <
        (place "Marshal1" 92 invisibleTo:{P2}) (place "General1" 93 invisibleTo:{P2})  (place "Miner1" 99 count:2 invisibleTo:{P2}) (place "Scout1" 100 count:2 invisibleTo:{P2}) 
        (place "Spy1" 101 invisibleTo:{P2}) (place "Flag1" 102 invisibleTo:{P2}) (place "Bomb1" 103 count:2 invisibleTo:{P2})
        
        (place "Marshal2" 104 invisibleTo:{P1}) (place "General2" 105 invisibleTo:{P1}) (place "Miner2" 111 count:2 invisibleTo:{P1}) (place "Scout2" 112 count:2 invisibleTo:{P1}) 
        (place "Spy2" 113 invisibleTo:{P1}) (place "Flag2" 114 invisibleTo:{P1}) (place "Bomb2" 115 count:2 invisibleTo:{P1})
        >
        "The game is played with less pieces."
    )  
})

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Stratego was created by Jacques Johan Mogendorff before 1942, but was derived from the game L'Attaque, invented by Hermance Edan.")
        (rules "Played on a board of 10x10 squares. The board has two 2x2 zones which cannot be entered, represented as water on the battlefield. each player controls 40 pieces which have individual army ranks. The goal is to capture the opponent's flag. Pieces can move only one space orthogonally. the Scout piece can move any number of spaces orthogonally. Pieces may attempt to capture an opposing piece; when doing so the ranks are revealed and the lower ranking piece is captured; if they are of equal rank they are both removed. There are bomb pieces which cannot move. Bombs eliminate other pieces attacking it and can only be removed by a miner. The spy can only attack the Marshall or the Flag.")
        (source "<a href=\"https://en.wikipedia.org/wiki/Stratego\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (version "1.0.6")
        (classification "proprietary")
        (author "Jacques Johan Mogendorff")
        (publisher "Jumbo Games")
        (credit "Eric Piette")
        (date "1942")
        }
    )
    
    (graphics {
        (show Piece Value)
        (player Colour P1 (colour Red))
        (player Colour P2 (colour Blue))
        (piece Scale 0.8)
        (piece Colour fillColour:(colour White))
        (piece Background P1 image:"square" fillColour:(colour Red))
        (piece Background P2 image:"square" fillColour:(colour Blue))
    })
    
)








TO IMPLEMENT:

DOMINOS VARIANTS
OSWALD
ARIES? ENTROPY? QUORIDOR? 