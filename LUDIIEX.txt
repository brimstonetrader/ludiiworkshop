(define "CanSlide"
    (not (all Sites (difference (sites Occupied by:Shared) (sites #1))
            if:(and
                (= 0 (count Sites in:(sites LineOfSight Farthest at:(site) #2)))
                (!= 
                    (what at:(site))
                    (what at:(regionSite (sites LineOfSight Piece at:(site) #2) index:0))
                )
            )
        )
    )
)

(define "CanSlideW" ("CanSlide" Left W))
(define "CanSlideE" ("CanSlide" Right E))
(define "CanSlideN" ("CanSlide" Top N))
(define "CanSlideS" ("CanSlide" Bottom S))

(define "SlideW" (move Select (from 6) (to 5) (then #1)))
(define "SlideE" (move Select (from 5) (to 6) (then #1)))
(define "SlideN" (move Select (from 6) (to 10) (then #1)))
(define "SlideS" (move Select (from 10) (to 6) (then #1)))

(define "LineOfSightPiece" (regionSite (sites LineOfSight Piece at:(site) #1) index:0))
(define "LineOfSightEmpty" (sites LineOfSight Farthest at:(site) #1))

(define "ApplySlideLine"
    (forEach Site (sites #1 #2)
        (if (is Occupied (site))
            (if 
                (and
                    (= 
                        (what at:(site))
                        (what at:("LineOfSightPiece" #3))
                    )
                    (= 0 (state at:("LineOfSightPiece" #3)))
                )
                (and {
                    (remove (site))
                    (remove ("LineOfSightPiece" #3))
                    (add 
                        (piece (mapEntry "Promotion" (what at:(site))))
                        (to ("LineOfSightPiece" #3))
                    )
                    (set State at:("LineOfSightPiece" #3) 1)
                    (addScore P1 (mapEntry "Score" (mapEntry "Promotion" (what at:(site)))))
                })
                (if (!= 0 (count Sites in:("LineOfSightEmpty" #3)))
                    (fromTo (from (site)) (to ("LineOfSightEmpty" #3)))
                )
            )
        )
    )
)

(define "ResetState" (forEach Site (sites State 1) (set State at:(site) 0)))

(define "ApplySlideW"
    (seq {
        ("ApplySlideLine" Column 1 W)
        ("ApplySlideLine" Column 2 W)
        ("ApplySlideLine" Column 3 W)
        ("ResetState")
    })
)

(define "ApplySlideE"
    (seq {
        ("ApplySlideLine" Column 2 E)
        ("ApplySlideLine" Column 1 E)
        ("ApplySlideLine" Column 0 E)
        ("ResetState")
    })
)

(define "ApplySlideN"
    (seq {
        ("ApplySlideLine" Row 2 N)
        ("ApplySlideLine" Row 1 N)
        ("ApplySlideLine" Row 0 N)
        ("ResetState")
    })
)

(define "ApplySlideS"
    (seq {
        ("ApplySlideLine" Row 1 S)
        ("ApplySlideLine" Row 2 S)
        ("ApplySlideLine" Row 3 S)
        ("ResetState")
    })
)

//------------------------------------------------------------------------------

(game "2048"
    (players 1)
    (equipment {
        (board (square 4))
        (piece "Square2" Shared)
        (piece "Square4" Shared)
        (piece "Square8" Shared)
        (piece "Square16" Shared)
        (piece "Square32" Shared)
        (piece "Square64" Shared)
        (piece "Square128" Shared)
        (piece "Square256" Shared)
        (piece "Square512" Shared)
        (piece "Square1024" Shared)
        (piece "Square2048" Shared) 
        (map "Promotion" {
            (pair (id "Square2" Shared) (id "Square4" Shared))
            (pair (id "Square4" Shared) (id "Square8" Shared))
            (pair (id "Square8" Shared) (id "Square16" Shared))
            (pair (id "Square16" Shared) (id "Square32" Shared))
            (pair (id "Square32" Shared) (id "Square64" Shared))
            (pair (id "Square64" Shared) (id "Square128" Shared))
            (pair (id "Square128" Shared) (id "Square256" Shared))
            (pair (id "Square256" Shared) (id "Square512" Shared))
            (pair (id "Square512" Shared) (id "Square1024" Shared))
            (pair (id "Square1024" Shared) (id "Square2048" Shared))
        })
        (map "Score" {
            (pair (id "Square2" Shared) 2)
            (pair (id "Square4" Shared) 4)
            (pair (id "Square8" Shared) 8)
            (pair (id "Square16" Shared) 16)
            (pair (id "Square32" Shared) 32)
            (pair (id "Square64" Shared) 64)
            (pair (id "Square128" Shared) 128)
            (pair (id "Square256" Shared) 256)
            (pair (id "Square512" Shared) 512)
            (pair (id "Square1024" Shared) 1024)
            (pair (id "Square2048" Shared) 2048)
        })
    })
    (rules
        (start (place Random {"Square2"} count:2))
        (play 
            (or {
                (if ("CanSlideW")
                    ("SlideW"
                        ("ApplySlideW")
                    )
                )
                (if ("CanSlideE")
                    ("SlideE"
                        ("ApplySlideE")
                    )
                )
                (if ("CanSlideN")
                    ("SlideN"
                        ("ApplySlideN")
                    )
                )
                (if ("CanSlideS")
                    ("SlideS"
                        ("ApplySlideS")
                    )
                )
                }
                (then
                    (if (< (value Random (range 1 8)) 2)
                        (add (piece "Square4") (to (sites Random (sites Empty) num:1)))
                        (add (piece "Square2") (to (sites Random (sites Empty) num:1)))
                    )		
                )
            )
        )
        (end {
            (if ("IsNotOffBoard" (where "Square2048" Shared)) (result Mover Win))
            (if (no Moves Next) (result Mover Loss))
        })
    )
)

//------------------------------------------------------------------------------

(metadata 
    (info
        {
        (description "2048 is a single-player sliding tile puzzle video game written by Italian web developer Gabriele Cirulli and published on GitHub.")
        (rules "2048 is played on a plain 4Ã—4 grid, with numbered tiles that slide when a player moves them. Every turn, a new tile randomly appears in an empty spot on the board with a value of either 2 or 4. Tiles slide as far as possible in the chosen direction until they are stopped by either another tile or the edge of the grid. If two tiles of the same number collide while moving, they will merge into a tile with the total value of the two tiles that collided. The resulting tile cannot merge with another tile again in the same move. The game is won when a tile with a value of 2048 appears on the board.")
        (id "1979")
        (source "<a href=\"https://en.wikipedia.org/wiki/2048_(video_game)\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (version "1.3.11")
        (classification "puzzle/planning")
        (author "Gabriele Cirulli")
        (credit "Eric Piette")
        (date "14-03-2014")
        }
    )
    
    (graphics {
        (board Colour Phase0 (colour 205 193 179))
        (board Colour InnerEdges (colour 187 173 160))
        (board Colour OuterEdges (colour 187 173 160))
        (piece Colour Shared "Square2" fillColour:(colour 238 228 218))
        (piece Colour Shared "Square4" fillColour:(colour 236 224 200))
        (piece Colour Shared "Square8" fillColour:(colour 242 177 121))
        (piece Colour Shared "Square16" fillColour:(colour 245 149 99))
        (piece Colour Shared "Square32" fillColour:(colour 244 125 93))
        (piece Colour Shared "Square64" fillColour:(colour 246 93 59))
        (piece Colour Shared "Square128" fillColour:(colour 237 206 113))
        (piece Colour Shared "Square256" fillColour:(colour 237 204 97))
        (piece Colour Shared "Square512" fillColour:(colour 236 200 80))
        (piece Colour Shared "Square1024" fillColour:(colour 255 178 103))
        (piece Colour Shared "Square2048" fillColour:(colour 241 194 44))
        (piece Foreground "Square2" image:"2" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.4)
        (piece Foreground "Square4" image:"4" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.4)
        (piece Foreground "Square8" image:"8" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.4)
        (piece Foreground "Square16" image:"1" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.4 offsetX:-0.6)
        (piece Foreground "Square16" image:"6" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.4 offsetX:0.4)
        (piece Foreground "Square32" image:"3" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.4 offsetX:-0.6)
        (piece Foreground "Square32" image:"2" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.4 offsetX:0.4)
        (piece Foreground "Square64" image:"6" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.4 offsetX:-0.6)
        (piece Foreground "Square64" image:"4" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.4 offsetX:0.4)
        (piece Foreground "Square128" image:"1" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.3 offsetX:-0.7)
        (piece Foreground "Square128" image:"2" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.3 offsetX:-0.1)
        (piece Foreground "Square128" image:"8" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.3 offsetX:0.5)
        (piece Foreground "Square256" image:"2" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.3 offsetX:-0.7)
        (piece Foreground "Square256" image:"5" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.3 offsetX:-0.1)
        (piece Foreground "Square256" image:"6" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.3 offsetX:0.5)
        (piece Foreground "Square512" image:"5" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.3 offsetX:-0.7)
        (piece Foreground "Square512" image:"1" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.3 offsetX:-0.1)
        (piece Foreground "Square512" image:"2" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.3 offsetX:0.5)
        (piece Foreground "Square1024" image:"1" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.2 offsetX:-0.6)
        (piece Foreground "Square1024" image:"0" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.2 offsetX:-0.2)
        (piece Foreground "Square1024" image:"2" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.2 offsetX:0.2)
        (piece Foreground "Square1024" image:"4" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.2 offsetX:0.6)
        (piece Foreground "Square2048" image:"2" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.2 offsetX:-0.6)
        (piece Foreground "Square2048" image:"0" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.2 offsetX:-0.2)
        (piece Foreground "Square2048" image:"4" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.2 offsetX:0.2)
        (piece Foreground "Square2048" image:"8" fillColour:(colour Hidden) edgeColour:(colour Black) scale:0.2 offsetX:0.6)
    })
)























(game "Block" 
    (players 2) 
    (equipment { 
        (boardless Square) 
        (hand Each size:21)
        (dominoes)
    }) 
    (rules 
        (start {
            (deal Dominoes 7) 
            (set Hidden What (sites Hand P1) to:P2)
            (set Hidden What (sites Hand P2) to:P1)
        })
        (play
            (priority 
                {
                (do (move 
                        (from 
                            (forEach 
                                (sites Hand Mover) 
                                if:(is Occupied (site))
                            )
                        ) 
                        (to (sites LineOfPlay)) 
                        (then 
                            (and
                                (set Hidden What at:(last To) False to:P1)
                                (set Hidden What at:(last To) False to:P2)
                            )
                        )
                    ) 
                    ifAfterwards:(is PipsMatch)
                )
                (move Pass 
                    (then 
                        (if 
                            (!= (count Pieces "Bag") 0)
                            (and {
                                (take Domino)
                                (set Hidden What (sites Hand Mover) to:Next)
                                (moveAgain)
                            })
                        )
                    )
                )
                }
            )
        )
        (end {
            (if ("HandEmpty" Mover) (result Mover Win)) 
            (if (all Passed) (result Mover Draw)) 
        }) 
    )
)

//------------------------------------------------------------------------------

(metadata 
    (info
        {
        (description "One of the most commonly played Dominoes game, Block uses most of the rules shared by other Dominoes games worldwide.")
        (aliases {"Block Dominoes" "the Block Game" "Allies"})
        (rules "At the beginning of the game, each player has 7 dominoes. The goal of the game is to use all the dominoes on his hand. A Domino can be played only if it can be placed in the line of play. If this is not possible, the player has to take another domino from the remaining dominoes and add it to his hand until he is able to place one. If the two players can not play, this is a draw.")
        (source "Dominoes, Jennifer A. Kelley & Miguel Lugo, Sterling New york / London.")
        (id "554")
        (version "1.3.11")
        (classification "dominoes")
        (credit "Eric Piette")
        }
    )
    (ai 
        "Block_ai"
    )
)












(define "NumNonEmptySitesBetween" 
    (= 0 
        (count Sites 
            in:(intersection 
                (difference (sites Occupied by:All) (sites {#1 #2}))
                (forEach 
                    (union (sites #3 (#4 of:#1)) (sites #3 (#4 of:#2)))
                    if:#5
                )
            )
        )
    )
)

(define "IsEmptyLine" 
    (if (> (#3 of:#1) (#3 of:#2)) 
        ("NumNonEmptySitesBetween" #1 #2 #4 #5 
            (and 
                (<= (#3 of:(site)) (#3 of:#1))
                (>= (#3 of:(site)) (#3 of:#2))
            )
        )
        ("NumNonEmptySitesBetween" #1 #2 #4 #5 
            (and 
                (<= (#3 of:(site)) (#3 of:#2))
                (>= (#3 of:(site)) (#3 of:#1))
            )
        )
    )		
)

(define "IsEmptyRectangle" 
    ("IsEmptyLine" #1 #2 column Row row)
    ("IsEmptyLine" #1 #2 row Column column)
)

//------------------------------------------------------------------------------

(game "BoxOff"
    (players 1)
    (equipment {
        (board (rectangle 6 8))
        (piece "Disc1" P1)
        (piece "Disc2" P1)
        (piece "Disc3" P1)
    })
    (rules
        (start {
            (place Random {"Disc1"} count:16)
            (place Random {"Disc2"} count:16)
            (place Random {"Disc3"} count:16)
        })
        (play
            (move Select
                (from (sites Occupied by:All)) 
                (to 
                    (difference (sites Occupied by:All) (from))
                    if:(and {
                        (= (what at:(from)) (what at:(to)))
                        ("IsEmptyRectangle" (from) (to))
                    })
                )
                (then (and (remove (last From)) (remove (last To))))
            )
        )
        (end {
            (if (no Pieces Mover) (result Mover Win))
            (if (no Moves Mover) (result Mover Loss))
        })
    )
)

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Steven Meyers' BoxOff has the feel of a classic solitaire abstract game. Brightly coloured pieces are distributed on a rectangular grid of squares and removed in pairs of like colour until the board is empty. ")
        (rules "Start: The game starts with a piece in each cell, which defines the challenge to be solved. 
            
            Play: The player then makes a series of moves, each involving the removal of a pair of same-coloured pieces that occupy a box (rectangle) that includes no other pieces of any colour.
            
        End: The player wins by removing all pieces from the board. Conversely, the player loses if there are no legal moves at any point while pieces remain on the board.")
        (id "974")
        (source "<a href=\"http://www.abstractgames.org/boxoff.html\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />www.abstractgames.org</a>")
        (version "1.3.11")
        (classification "puzzle/planning")
        (author "Steven Meyers")
        (publisher "Google Play")
        (credit "Eric Piette")
        (date "01-2013")
        }
    )
    
    (graphics {
        (piece Colour "Disc1" fillColour:(colour White))
        (piece Colour "Disc2" fillColour:(colour Black))
        (piece Colour "Disc3" fillColour:(colour Grey))
    })
    (ai
        "BoxOff_ai"
    )
)


















(define "NextCanNotMove"
    (not (can Move (do (forEach Piece Next) ifAfterwards:(not ("IsInCheck" "King" Next)))))
)

//------------------------------------------------------------------------------

(game "Chex" 
    ("TwoPlayersNorthSouth") 
    
    (equipment { 
        (boardless Square) 
        (hand Each)
        
        (tile "Pawn" Each numSides:4
            (or {
                "StepForwardToEmpty" 
                ("StepToEnemy" (directions {FR FL}))
            })
        )
        
        (tile "Rook" Each numSides:4 ("SlideCapture" Orthogonal))
        (tile "King" Each numSides:4 ("StepToNotFriend"))
        (tile "Bishop" Each numSides:4 ("SlideCapture" Diagonal))
        (tile "Knight" Each numSides:4 ("LeapCapture" "KnightWalk"))
        (tile "Queen" Each numSides:4 ("SlideCapture"))
    }) 
    
    (rules 
        (start {
            (place Random 
                { 
                (count "Pawn1" 8) (count "Rook1" 2) (count "Knight1" 2) 
                (count "Bishop1" 2) (count "Queen1" 1) (count "King1" 1) 
                } 
                (handSite 1) 
            )
            (place Random 
                { 
                (count "Pawn2" 8) (count "Rook2" 2) (count "Knight2" 2)
                (count "Bishop2" 2) (count "Queen2" 1) (count "King2" 1) 
                } 
                (handSite 2) 
            )
            (forEach Value min:0 max:(topLevel at:(handSite 1)) 
                (set Hidden What at:(handSite 1) level:(value) to:P1)		
            )
            
            (forEach Value min:0 max:(topLevel at:(handSite 1)) 
                (set Hidden What at:(handSite 1) level:(value) to:P2)		
            )
            
            (forEach Value min:0 max:(topLevel at:(handSite 2)) 
                (set Hidden What at:(handSite 2) level:(value) to:P1)		
            )
            
            (forEach Value min:0 max:(topLevel at:(handSite 2)) 
                (set Hidden What at:(handSite 2) level:(value) to:P2)		
            )
        }) 
        (play 
            (if "SameTurn"
                (if (= (count Moves) 1)
                    (move 
                        (from (handSite (mover))) 
                        (to (centrePoint))
                    )
                    (do (move 
                            (from (handSite (mover))) 
                            (to 
                                (sites Around (union (sites Occupied by:P1 container:"Board") (sites Occupied by:P2 container:"Board")) Empty)
                            )
                        ) 
                        ifAfterwards:(not ("IsInCheck" "King" Mover))
                    )
                )
                (or 
                    (if (is Occupied (handSite (mover)))
                        (move Select
                            (from (handSite (mover))) 
                            (then 
                                (and {
                                    (moveAgain) 
                                    (set Hidden What at:(last To) level:(topLevel at:(last To)) False to:P1)
                                    (set Hidden What at:(last To) level:(topLevel at:(last To)) False to:P2)
                                })
                            )
                        )
                    )
                    (do 
                        (forEach Piece) 
                        ifAfterwards:(and (= 1 (count Groups)) (not ("IsInCheck" "King" Mover)))
                    )
                )
            )	
        )
        
        (end {
            (if (and {
                    (not 
                        (can Move 
                            (if (!= (what at:(handSite (mover))) 0) (move Select (from (handSite (mover)))))
                        )
                    )
                    ("IsNotOffBoard" (where "King" Next))
                    ("IsInCheck" "King" Next)
                    (not 
                        (can Move 
                            (do 
                                (forEach Piece Next) 
                                ifAfterwards:(and 
                                    (= 1 (count Groups)) 
                                    (not ("IsInCheck" "King" Next))
                                )
                            ) 
                        )
                    )
                }) 
                (result Mover Win)
            )
            (if (and { 
                    "SameTurn"
                    ("IsInCheck" "King" Mover) 
                    (not 
                        (can Move 
                            (do 
                                (move 
                                    (from (handSite (mover))) 
                                    (to 
                                        (sites 
                                            Around 
                                            (union 
                                                (sites Occupied by:P1 container:"Board") 
                                                (sites Occupied by:P2 container:"Board")
                                            ) 
                                            Empty
                                        )
                                    )
                                ) 
                                ifAfterwards:(not ("IsInCheck" "King" Mover))
                            )
                        )
                    )
                })
                (result Next Win)
            )
            ("DrawIfNoMoves" Mover)
        })
    )
)

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (aliases {"Chess Cards"})
        (rules "The 32 pieces in Chex represent the 16 chess pieces on each side of a normal chess game. Each player shuffles his own 16 tiles and places them face down, then white draws his top tile and places it, with the piece oriented so it looks upright to him. Black then draws the top tile in his pile and places it so that it touches white's piece, either orthogonally or diagonally, and oriented so that it looks upright to him.
            
            At that point, white can either add another piece or move his piece on the board. A move must be a legal chess move and may not separate any element of the board; all pieces much remain touching, even if just diagonally, when a move has ended. Thus you can \"pin\" a piece by placing a new piece on the far corner of a piece already in play.
            
        The game ends in checkmate or stalemate, with a stalemate occurring when you must place your king into check when you draw it.")
        (id "551")
        (version "1.3.11")
        (classification "board/war/replacement/checkmate/chess")
        (author "David L. Smith")
        (publisher "IQ Products")
        (credit "Eric Piette")
        (date "1982")
        }
    )
    
    (graphics {
        (show Check "King")
        (player Colour P1 (colour VeryLightGrey))
        (piece Foreground "Pawn" image:"Pawn" fillColour:(colour White) scale:0.9)
        (piece Foreground "Knight" image:"Knight" fillColour:(colour White) scale:0.9)
        (piece Foreground "Rook" image:"Rook" fillColour:(colour White) scale:0.9)
        (piece Foreground "Bishop" image:"Bishop" fillColour:(colour White) scale:0.9)
        (piece Foreground "Queen" image:"Queen" fillColour:(colour White) scale:0.9)
        (piece Foreground "King" image:"King" fillColour:(colour White) scale:0.9)
    })
    
    (ai 
        "Chex_ai"
    )
    
)




























(game "Inkblots"
    (players 2)
    (equipment {
        (board (tri Hexagon <Board>))
        (tile "Triangle" Each) 
        (tile "Triangle" Neutral) 
    })
    (rules
        (meta (swap))
        (start (place Random {"Triangle1" "Triangle2" "Triangle0"}))
        (play
            (move Add (to (sites Empty))
                (then
                    (add (piece (id "Triangle" Next))  // assumes both players use Disc
                        (to
                            (intersection
                                (expand (sites Occupied by:Next) Orthogonal)
                                (sites Empty)
                            )
                        )
                    )
                )
            )
        )
        
        (end 
            (if (no Moves Next) 
                (byScore {
                    (score P1 (count Pieces P1)) 
                    (score P2 (count Pieces P2))
                })
            )
        )
    )
)

//------------------------------------------------------------------------------

(option "Board Size" <Board> args:{ <size> }
    {
    (item "3" <3> "Played on a size 3 board.") 
    (item "4" <4> "Played on a size 4 board.") 
    (item "5" <5> "Played on a size 5 board.") 
    (item "6" <6> "Played on a size 6 board.") 
    (item "7" <7> "Played on a size 7 board.")*
    (item "8" <8> "Played on a size 8 board.") 
    (item "9" <9> "Played on a size 9 board.")
    (item "10" <10> "Played on a size 10 board.") 
    (item "11" <11> "Played on a size 11 board.") 
    (item "12" <12> "Played on a size 12 board.") 
    (item "13" <13> "Played on a size 13 board.") 
    (item "14" <14> "Played on a size 14 board.") 
    (item "15" <15> "Played on a size 15 board.") 
    (item "16" <16> "Played on a size 16 board.") 
    (item "17" <17> "Played on a size 17 board.") 
    (item "18" <18> "Played on a size 18 board.") 
    (item "19" <19> "Played on a size 19 board.")*
    }
)

//------------------------------------------------------------------------------

(metadata
    
    (info
        {
        (description "Players steer cellular automata to dominate the board.")
        (rules "Play on an equilateral hexagonal triangle-tessellated grid. The board is seeded randomly with a black stone, a white stone, and a neutral stone. Players take turn seeding new groups. Every placement triggers growth of all enemy groups, where growth is defined as adding a stone to all empty cells adjacent to a group. When the board fills up, the person who has more pieces on the board wins.")
        (id "710")
        (version "1.3.11")
        (classification "board/space/territory")
        (publisher "Michael Zapawa")
        (credit "Designer: Mihaw Zapawa. Implemented by Alek Erickson")
        (date "2020")
        }
    )
    
    (graphics {
        (player Colour Neutral (colour Blue))
    })
    (ai
        "Inkblots_ai"
    )
)


















(game "Lights Out" 
    (players 1) 
    (equipment { 
        (board (square 5)) 
        (piece "Light" Shared)
    }) 
    (rules
        (start (place Random {"Light"} count:(value Random (range 10 20))))
        (play
            (move Select 
                (from (sites Board))
                (then
                    (forEach Site (sites Around (last To) Orthogonal includeSelf:True)
                        (if (is Occupied (site))
                            (remove (site))
                            (add (piece "Light") (to (site)))
                        )
                    )
                )
            )
        )
        (end { 
            (if (all Sites (sites Board) if:(is Empty (site))) (result Mover Win))
            (if (= 98 (counter)) (result Mover Loss))
        })
    )
)

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Lights Out is an electronic game released by Tiger Electronics in 1995.")
        (rules "The game consists of a 5 by 5 grid of lights. When the game starts, some lights are switched on. Pressing any of the lights will toggle it and the four adjacent lights. The goal of the puzzle is to switch all the lights off, preferably in as few button presses as possible.
        Ludii allows 100 moves maximum before losing.")
        (id "1777")
        (source "<a href=\"https://en.wikipedia.org/wiki/Lights_Out_(game)\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (version "1.3.11")
        (classification "puzzle/planning")
        (credit "Eric Piette")
        (date "1995")
        }
    )
    
    (graphics {
        (piece Colour "Light" fillColour:(colour Yellow))
        (board Colour Phase0 (colour 0 102 0))
        (board Colour OuterEdges (colour Black))
        (board Colour InnerEdges (colour Black))
    })
    (ai
        "Lights Out_ai"
    )
)






(game "Monty Hall Problem"
    (players 1)
    (equipment {
        (board (rectangle 1 3))
        (piece "Car" Shared)
        (piece "Goat" Shared)
    })
    
    (rules
        (start {
            (place Random {"Car"})
            (place Random {"Goat"} count:2)
            (set Hidden What (sites Board) to:P1)
        })
        
        phases:{
        (phase "FirstChoice"
            (play 
                (move Select 
                    (from (sites Board))
                    (then
                        (set Hidden What 
                            (sites Random 
                                (forEach 
                                    (sites Board) 
                                    if:(and 
                                        (!= (site) (last To))
                                        (!= (id "Car" Shared) (what at:(site)))
                                    )
                                )
                                num:1
                            ) 
                            False 
                            to:P1
                        )
                    )
                )
            )
            (nextPhase "FinalChoice")
        )
        
        (phase "FinalChoice"
            (play 
                (move Select 
                    (from (sites Board)) 
                    (then 
                        (set Hidden What (sites Board) False to:P1)
                    )
                )
            )
            (end {
                (if 
                    ("IsPieceAt" "Car" Shared (last To))
                    (result P1 Win) 
                )
                (if 
                    ("IsPieceAt" "Goat" Shared (last To))
                    (result P1 Loss) 
                )
            })
        )
        }
    )
)

//------------------------------------------------------------------------------

(metadata
    (info
        {
        (description "The Monty Hall problem is a brain teaser, in the form of a probability puzzle, loosely based on the American television game show Let's Make a Deal and named after its original host, Monty Hall.")
        (rules "Monty Hall asks to choose one of three doors. One of the doors hides a car and the other two doors have a goat. You select which door you pick, but you donâ€™t open it right away.
            
            The game opens one of the other two doors, and there is no prize behind it.
            
        At this moment, there are two closed doors. You can keep the same choice or selecting the other door. If you get the car you win if not you loss.")
        (id "1155")
        (source "<a href=\"https://en.wikipedia.org/wiki/Monty_Hall_problem\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (version "1.3.11")
        (classification "puzzle/planning")
        (author "Steve Selvin")
        (credit "Eric Piette")
        (date "1975")
        }
    )
    
    (graphics {
        (no Board)
        (player Colour Shared (colour Brown))
        (hiddenImage "door")
    })
)





















(define "ThrowValue" (mapEntry "Throw" (count Pips)))
(define "SiteToMoveOnTrack" ("NextSiteOnTrack" #2 #1))

(define "IsSpecialThrow" (is In ("ThrowValue") (sites {10 25 30})))

//------------------------------------------------------------------------------

(game "Pachesi" 
    (players 4) 
    (equipment { 
        ("PachisiBoard" 
            {
            (track "Track1" "96,9,S,W,N,7,W,N,E,51,N,E,S,43,E,S,W,10,S,W1,N7,End" P1 directed:True)
            (track "Track2" "96,26,W,N,E,51,N,E,S,43,E,S,W,10,S,W,N,7,W,N1,W7,End" P2 directed:True)
            (track "Track3" "96,52,N,E,S,43,E,S,W,10,S,W,N,7,W,N,E,51,N,E1,S7,End" P3 directed:True)
            (track "Track4" "96,27,E,S,W,10,S,W,N,7,W,N,E,51,N,E,S,43,E,S1,W7,End" P4 directed:True)
            }
        )
        ("StickDice" 7)
        (piece "Pawn" Each
            (if ("IsEndTrack" ("SiteToMoveOnTrack" from:(from) ("ThrowValue")))
                (move Remove (from) level:(level))
                (if (and ("IsEndTrack" ("SiteToMoveOnTrack" from:(from) 1)) ("IsSpecialThrow"))
                    (move Remove (from) level:(level))
                    (move 
                        (from (from) level:(level))
                        (to
                            ("SiteToMoveOnTrack" from:(from) ("ThrowValue"))
                            if:(not (and (is In (to) (sites "SafeSites")) ("IsEnemyAt" (to))))
                            ("HittingStackCapture" (centrePoint))
                        )
                    )
                )
            )
        )
        (hand Each)
        (regions "SafeSites" (sites {55 63 65 34 15 47 94 84 86 19 38 3}))
        (map "Throw" {(pair 0 7) (pair 1 10) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 25) (pair 6 30) (pair 7 12)})
    }) 
    (rules 
        (start {
            (place Stack "Pawn1" (handSite P1) count:4)
            (place Stack "Pawn2" (handSite P2) count:4)
            (place Stack "Pawn3" (handSite P3) count:4)
            (place Stack "Pawn4" (handSite P4) count:4)
        })
        
        (play 
            ("RollMove"
                (or
                    (if (and (is Occupied (handSite Mover)) ("IsSpecialThrow"))
                        (move
                            (from (handSite Mover))
                            (to (centrePoint))
                        )
                    )
                    (forEach Piece)
                )
            )
        )
        
        (end ("EscapeWin"))
    )
)

//------------------------------------------------------------------------------

(metadata 
    (info
        {
        (description "Pachesi is a race game played on a cross-shaped board, of which there are several versions in South Asia. This version is played near Chitrakoot Dham in central India.")
        (rules "Four 3x8 rectangles, arranged in a cross. The counting from the bottom of each arm, the spaces marked are the fourth square in the outer rows and the first in the central row. Four pieces per player. Seven cowrie shells, used as dice. The throws are as follows: one mouth up = 10; two mouths up = 2; three mouth up = 3; four mouths up = 4; five mouths up. = 25; six mouths up = 30, seven mouths up = 12, zero mouths up = 7. Pieces begin in the large central space of the board, and then proceed down the central row of their arm, then clockwise around the board, back to the central row, and then to the central space again. Pieces may enter the board on throws of 10, 25, or 30. When a player's piece lands on a space that is occupied by an opponent's piece, the opponent's piece is sent back to start. Pieces are safe from being sent to start when they rest on a marked space. To move off the board, a player must make an exact throw to arrive in the central square. When resting on the final square before the central one, a throw of 10, 25, or 30 is required. The first player to place all of their pieces in the central square wins.")
        (source "Humphries 1906: 117-119.")
        (id "895")
        (version "1.3.11")
        (classification "board/race/escape")
        (credit "Eric Piette")
        (origin "This game was played in India, from around 1904 to 1905.")
        }
    )
    
    (graphics {
        (stackType site:96 Ring)
        (stackType 0 Ground)
        (stackType 1 Count)
        (stackType 2 Count)
        (stackType 3 Count)
        (stackType 4 Count)
        (show Symbol "thinCross" {55 63 65 34 15 47 94 84 86 19 38 3} scale:0.9)
        (board Colour Phase0 (colour 223 178 110))
        (board Colour InnerEdges (colour Black))
        (board Colour OuterEdges (colour Black))
        (piece Scale "Pawn" 0.5)
    })
    
)
















(define "DistanceToMove"
    (count Sites 
        in:(sites Around 
            (from) 
            Orthogonal 
            if:("IsFriendAt" (to))
        )
    )
)

//------------------------------------------------------------------------------

(game "Quantum Leap" 
    (players 2) 
    (equipment { 
        (board (hex 5))
        (piece "Marker" Each 
            (move Hop 
                Orthogonal 
                (between 
                    (exact (- "DistanceToMove" 1))
                    if:True
                )
                (to 
                    if:("IsEnemyAt" (to)) 
                    (apply (remove (to)))
                )
            )
        )
    }) 
    (rules 
        (start {
            (place "Marker2" (centrePoint))
            (place Random {"Marker2"} count:29) 
            (place Random {"Marker1"} count:30) 
        })
        phases:{
        (phase "Swap" 
            (play
                (or
                    (move Pass)
                    (move Select
                        (from (sites Occupied by:Mover))
                        (to (sites Occupied by:Next))
                        (then
                            (swap Pieces (last From) (last To))
                        )
                    )
                )
            )
            (nextPhase "Play")		
        )
        (phase "Play" (play (forEach Piece)))
        }
        (end ("NoMoves" Loss)) 
    )
)

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Quantum Leap was invented in 2013 by NÃ©stor Romeral AndrÃ©s. It can be played on a hexagonal grid of any size.")
        (rules "Play begins with the supply of pieces (30 of each colour) randomly distributed on the board, so each cell contains only one stone and there is one free space left. This free space can be anywhere except the centre space. Each player has an allocated colour. Before the game starts, Black can swap the positions of any two stones on the board. White then starts the game. Players alternate turns during the game until one of them cannot make a valid move, thereby losing the game. On a turn, a player must make one capture. A player makes a capture by leaping in a straight line in any of the 6 directions exactly as many spaces as friendly pieces surround its original position, and landing on an enemy piece, which is removed from the game. The player who cannot make a capture loses.")
        (source "<a href=\"https://boardgamegeek.com/boardgame/140782/quantum-leap\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />BGG</a>")
        (id "449")
        (version "1.3.11")
        (classification "board/space/blocking")
        (author "NÃ©stor Romeral AndrÃ©s")
        (publisher "<a href=\"https://www.nestorgames.com\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />nestorgames</a> (used with permission)")
        (credit "Eric Piette")
        (date "2013")
        }
    )
    
    (graphics {
        (player Colour P1 (colour Black))
        (player Colour P2 (colour White))
    })
    
    (ai 
        "Quantum Leap_ai"
    )
    
)
















//------------------------------------------------------------------------------
// Generic

// Sites that contain enemy units that are facing away from the unit at site #1
(define "SitesWithEnemyFacingAway"
    (forEach (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop"})
        if:(not (= (% (+ (rotation at:(site)) 4) 8) (rotation at:(#1))))
    )
)

// Sites that a piece can stand on
(define "SitesCanStandOn"
    (difference (sites Empty) (difference (sites "WaterRegion") "RegionBridge"))
)

// Sites that are currently being attacked by #1 (can't build entrenchment on)
(define "AttackedSites"
    (union {
        (sites Around (sites Occupied by:#1 container:"Board") includeSelf:True)
        (sites Around (sites Direction from:(sites Occupied by:#1 container:"Board" components:{"TinSoldier" "Bishop"}) Forward distance:1) Orthogonal includeSelf:True)
        (sites Around (sites Direction from:(sites Occupied by:#1 container:"Board" components:{"RegimentalOutline"}) Forward distance:1) Orthogonal includeSelf:True)
        (sites Around (sites Direction from:(sites Occupied by:#1 container:"Board" components:{"CannonOutline"}) Forward distance:1) Orthogonal includeSelf:True)
        (sites Around (sites Direction from:(sites Occupied by:#1 container:"Board" components:{"CannonOutline"}) Forward distance:2) Orthogonal includeSelf:True)
    })
)

(define "UnoccupiedUnits"
    (union {
        (forEach (sites Occupied by:All container:"Board" components:{"Triangle"})
            if:(= (value Piece at:(site)) 0)
        )
        (forEach (sites Occupied by:P1 container:"Board" components:{"CannonOutline" "RegimentalOutline" "WagonOutline"})
            if:(= 0 (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P1 container:"Board" components:{"TinSoldier" "Bishop"}))))
        )
        (forEach (sites Occupied by:P2 container:"Board" components:{"CannonOutline" "RegimentalOutline" "WagonOutline"})
            if:(= 0 (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P2 container:"Board" components:{"TinSoldier" "Bishop"}))))
        )
        
    })
)

(define "PanningMove"
    (if (= (state at:(from)) 1)
        (move Set Rotation {0 2 4 6} previous:False next:False)
    )
)

//------------------------------------------------------------------------------
// Entrenchments

// Sets the owner of each entrenchment, checked at the end of each turn phase.
(define "SetOccupiedEntrenchments"
    (and
        (forEach Site (sites Occupied by:All container:"Board" components:{"Triangle"})
            (if 
                (and
                    (not (is In (site) ("AttackedSites" Mover)))
                    (= (value Piece at:(site)) (id Mover))
                )
                (set Value at:(site) 0)
            )
        )
        (forEach Site (sites Occupied by:All container:"Board" components:{"Triangle"})
            (if 
                (and
                    (is In (site) ("AttackedSites" Mover))
                    (= (value Piece at:(site)) 0)
                )
                (set Value at:(site) (id Mover))
            )
        )
    )
)

// Entrenchment sites that protect against attacks against site #1 from site #2 
(define "EntrenchmentProtectingSites"
    (forEach (sites Occupied by:All container:"Board" components:{"Triangle"})
        if:(and
            (= (% (+ (rotation at:(site)) 4) 8) (rotation at:(#2)))
            (= (value Piece at:(site)) (who at:(#1)))
        )
    )
)

// Checks if site #1 is protected by an entrenchment against attacks from site #2
(define "IsSiteProtectedByEntrenchment"
    (= 1 (count Sites in:(intersection (sites Direction from:(#1) (directions Cell from:(ahead (#2)) to:(#2)) distance:1) ("EntrenchmentProtectingSites" #1 #2))))
)

// Move that builds an entrenchment at the rotation specified in #1
(define "BuildEntrenchmentMove"
    (move Select
        (from (from) if:(= (state at:(from)) 1))
        (to
            (difference (intersection (sites Around (from)) "SitesCanStandOn") ("AttackedSites" Enemy))
        )
        (then 
            (and {
                (add 
                    (piece "Triangle0") 
                    (to (last To)) 
                )
                (set Rotation (to (last To)) {#1} previous:False next:False)
                (set Value at:(last To) (id Mover))
            })
        )
    )
)

(define "DemolishEntrenchmentMove"
    (move Select
        (from (from) if:(= (state at:(from)) 1))
        (to
            (intersection 
                (sites Occupied by:All container:"Board" components:{"Triangle"})
                (sites Around (from))
            )
            if:(and
                (= (value Piece at:(to)) (id Mover))
                (not (is In (to) ("AttackedSites" Enemy)))
            )
        )
        (then (remove (last To)))
    )
)

//------------------------------------------------------------------------------
// Bridge Wagon

(define "DemolishBridgeWagonMove"
    (move Select
        (from (from) if:(= (state at:(from)) 1))
        (to
            (intersection {
                (sites Occupied by:All container:"Board" components:{"WagonOutline"})
                (sites Around (from))
                "UnoccupiedUnits"
            })
        )
        (then (remove (last To)))
    )
)

(define "DemolishBridgeMove"
    (move Select
        (from (from) if:(= (state at:(from)) 1))
        (to
            (intersection 
                "RegionBridge"
                (sites Around (from))
            )
            if:(not (is In (to) ("AttackedSites" Enemy)))
        )
        (then (forget Value "Bridges" (last To)))
    )
)

//------------------------------------------------------------------------------
// Bridge

(define "BuildBridge"
    (move Select
        (from (from) 
            if:(and {
                (= (state at:(from)) 1)
                (< 0 (value Piece at:(from)))
                (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))
            })
        )
        (to
            (forEach 
                (union 
                    (sites Around (from))
                    (sites Around
                        (sites Group
                            from:(forEach (sites Around (from))
                                if:(is In (site) "RegionBridge")
                            )
                            if:(is In (to) "RegionBridge")
                        )
                    )
                )
                if:(and {
                    (is In (site) (difference (sites "WaterRegion") "RegionBridge"))
                    (not (is In (site) ("AttackedSites" Enemy)))
                })
            )
        )
        (then 
            (and {
                (remember Value "Bridges" (last To))
                (set Value at:(last From) (- (value Piece at:(last From)) 1))
            })
        )
    )
)

(define "DeconstructBridge"
    (move Select
        (from (from) 
            if:(and {
                (= (state at:(from)) 1)
                (> 4 (value Piece at:(from)))
                (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))
            })
        )
        (to
            (forEach
                (union 
                    (sites Around (from))
                    (sites Around
                        (sites Group
                            from:(forEach (sites Around (from))
                                if:(is In (site) "RegionBridge")
                            )
                            if:(is In (to) "RegionBridge")
                        )
                    )
                )
                if:(and {
                    (is In (site) "RegionBridge")
                    (is In (site) (union (sites Empty) ("UnoccupiedUnits")))
                })
            )
        )
        (then 
            (and {
                (forget Value "Bridges" (last To))
                (set Value at:(last From) (+ (value Piece at:(last From)) 1))
                (remove (last To))
            })
        )
    )
)

(define "BuildBridgeGround"
    (move Select
        (from (from) 
            if:(and {
                (= (state at:(from)) 1)
                (< 0 (value Piece at:(from)))
                (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))
            })
        )
        (to
            (intersection (sites Around (from)) (difference (sites Empty) (sites "WaterRegion")))
        )
        (then 
            (and {
                (add (piece "Square0") (to (last To)))
                (set Value at:(last From) (- (value Piece at:(last From)) 1))
            })
        )
    )
)

(define "DeconstructBridgeGround"
    (move Select
        (from (from) 
            if:(and {
                (= (state at:(from)) 1)
                (> 4 (value Piece at:(from)))
                (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))
            })
        )
        (to
            (intersection (sites Around (from)) (sites Occupied by:Neutral container:"Board" components:{"Square"}))
        )
        (then 
            (and {
                (set Value at:(last From) (+ (value Piece at:(last From)) 1))
                (remove (last To))
            })
        )
    )
)

(define "BurnBridgeMove"
    (move Select
        (from (from) if:(= (state at:(from)) 1))
        (to
            (intersection 
                "RegionBridge"
                (sites Around (from))
            )
        )
        (then ("SetFireRegion" (last To) Mover))
    )
)

//------------------------------------------------------------------------------
// Fire

(define "CheckFireSites"
    (if (= (id #1) 1)
        (forEach Site "RegionFire1" (remove (site)))
        (forEach Site "RegionFire2" (remove (site)))
    )
)

// #1 = fire site, #2 = mover
(define "SetFireRegion"
    (if (= (id #2) 1)
        (remember Value "Fires1" #1)
        (remember Value "Fires2" #1)
    )
)

//------------------------------------------------------------------------------
// Infantry

// Moves that infantry can make.
(define "InfantryMoves"
    
    // Move without any capture
    (move Slide 
        (from (from) if:(= (state at:(from)) 3)	)
        (between 
            (range 1 8)
            if:(or {
                (is In (between) "SitesCanStandOn")
                (is In (between) (sites "TownRegion")) 
            })
        )
        (to
            if:False
            (apply
                if:(if (is Occupied (to)) 
                    (not (is In (to) (sites "TownRegion")))
                    True
                )
            )
        )
        (then
            (and
                (set Var "FromArtillerySite" (last From))
                (set Var "ToArtillerySite" (last To))
            )
        )
    ) 
    
    // Move with capture
    (move Step 
        (from (from) if:(= (state at:(from)) 1))
        (directions {Forward FR FL}) 
        (to 
            if:("IsEnemyAt" (to)) 
            (apply (remove (to)))
        )
    )
    
    // Shoot (normal)
    (move Select
        (from (from) if:(= (state at:(from)) 1))
        (to
            (intersection 
                ("SitesWithEnemyFacingAway" from)
                (expand origin:(ahead (from)) Orthogonal)
            )
            if:(or 
                (not ("IsSiteProtectedByEntrenchment" (to) (from))) 
                (is In (to) (sites Occupied by:Mover container:"Board" components:{"RiderOutline"}))
            )
        )
        (then (remove (last To)))
    )
    
    // Shoot (from entrenchment)
    (move Select
        (from (from) if:(= (state at:(from)) 1))
        (to
            (intersection 
                (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop"})
                (expand origin:(ahead (from)) Orthogonal)
            )
            if:("IsSiteProtectedByEntrenchment" (from) (to))
        )
        (then (remove (last To)))
    )
    
    // Shoot (outnumber the enemy)
    (move Select
        (from (from) 
            if:(and
                (= (state at:(from)) 1)	
                (is In (ahead (from)) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))
            )
        )
        (to
            (intersection 
                (expand origin:(ahead (from)) Orthogonal)
                (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop"})
            )
            if:(or 
                (not ("IsSiteProtectedByEntrenchment" (to) (from))) 
                (is In (to) (sites Occupied by:Mover container:"Board" components:{"RiderOutline"}))
            )
        )
        (then 
            (remove (last To))
        )
    )
    
    // Build entrenchments
    ("BuildEntrenchmentMove" 0)
    ("BuildEntrenchmentMove" 2)
    ("BuildEntrenchmentMove" 4)
    ("BuildEntrenchmentMove" 6)
    
    "PanningMove"
    "DemolishEntrenchmentMove"
    "DemolishArtilleryMove"
    
    "DemolishBridgeWagonMove"
    "DemolishBridgeMove"
    "BurnBridgeMove"
)

//------------------------------------------------------------------------------
// Cavalry

(define "CavalryMoves"
    
    // Move without any capture
    (move Slide 
        (from (from) if:(= (state at:(from)) 3)	)
        (between 
            (range 1 12)
            if:(or {
                (is In (between) "SitesCanStandOn")
                (is In (between) (sites "TownRegion")) 
            })
        )
        (to
            if:False
            (apply
                if:(if (is Occupied (to)) 
                    (not (is In (to) (sites "TownRegion")))
                    True
                )
            )
        )
    )
    
    // Move with capture (against just infantry)
    (move Slide 
        (from (from) if:(= (state at:(from)) 1)	)
        (between 
            (range 1 12)
            if:(or {
                (is In (between) "SitesCanStandOn")
                (is In (between) (sites "TownRegion")) 
                (is In (between) (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "Bishop"}))
            })
            (apply (remove (between)))
        )
        (to
            if:(and
                (< 0 (count Sites in:(intersection (sites Around (to) Orthogonal) (sites Occupied by:Enemy container:"Board"))))
                (is In (to) (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "Bishop"})) 	
            )
            (apply
                if:(and (not (is In (to) (sites "TownRegion"))) (is In (to) (sites Occupied by:Enemy container:"Board")))
                (remove (to))
            )
        )
    ) 
    
    // Move with capture (against cavalry and infantry)
    (move Slide 
        (from (from) if:(= (state at:(from)) 1)	)
        (directions {Forward FR FL}) 
        (between 
            (range 1 12)
            if:(or {
                (is In (between) "SitesCanStandOn")
                (is In (between) (sites "TownRegion")) 
                (is In (between) (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop"}))
            })
            (apply 
                if:(is In (between) (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop"}))
                (remove (between))
            )
        )
        (to
            if:(and
                (< 0 (count Sites in:(intersection (sites Around (to) Orthogonal) (sites Occupied by:Enemy container:"Board"))))
                (is In (to) (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop"})) 	
            )
            (apply
                if:(and (not (is In (to) (sites "TownRegion"))) (is In (to) (sites Occupied by:Enemy container:"Board")))
                (remove (to))
            )
        )
    ) 
    
    "PanningMove"
    "DemolishEntrenchmentMove"
    "DemolishArtilleryMove"
    
    "DemolishBridgeWagonMove"
    "DemolishBridgeMove"
    "BurnBridgeMove"
)

//------------------------------------------------------------------------------
// Artillery

(define "ArtillerySlide"
    (move Slide
        (from (from) 
            if:(and {
                (= (state at:(from)) 3)
                (is In (from) (sites Around (var "FromArtillerySite") Orthogonal))
            })
        )
        Orthogonal
        (between 
            (range 1 #1)
            if:(is In (between) "SitesCanStandOn")
        )
        (to
            if:False
            (apply
                if:(is In (to) (sites Around (var "ToArtillerySite") Orthogonal))
            )
        )
        (then
            (and
                (set Var "FromArtillerySite" -1)
                (set Var "ToArtillerySite" -1)
            )
        )
    ) 
)

// Can attack all pieces if behind an entrenchment
(define "ArtilleryEntrenched"
    (move Select
        (from (from) 
            if:(and {
                (= (state at:(from)) 1)
                (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))
            })
        )
        (to
            (intersection 
                (union
                    (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop" "CannonOutline" "RegimentalOutline" "WagonOutline"})
                    (sites Occupied by:All container:"Board" components:{"Triangle"})
                )
                #1
            )
            if:(and
                (or 
                    (not ("IsSiteProtectedByEntrenchment" (to) (from))) 
                    (is In (to) (sites Occupied by:Mover container:"Board" components:{"RiderOutline"}))
                )
                ("IsSiteProtectedByEntrenchment" (from) (to)) 
            )
        )
        (then (remove (last To)))
    )
)

// Can attack all pieces
(define "ArtilleryShootStrong"
    (move Select
        (from (from) 
            if:(and {
                (= (state at:(from)) 1)
                (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))
            })
        )
        (to
            (intersection 
                (union
                    (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop" "CannonOutline" "RegimentalOutline" "WagonOutline"})
                    (sites Occupied by:All container:"Board" components:{"Triangle"})
                )
                #1
            )
            if:(or 
                (not ("IsSiteProtectedByEntrenchment" (to) (from))) 
                (is In (to) (sites Occupied by:Mover container:"Board" components:{"RiderOutline"}))
            )
        )
        (then (remove (last To)))
    )
)

// Cannot attack the CannonOutline
(define "ArtilleryShootWeak"
    (move Select
        (from (from) 
            if:(and {
                (= (state at:(from)) 1)
                (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))
            })
        )
        (to
            (intersection 
                (union
                    (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop" "RegimentalOutline" "WagonOutline"})
                    (sites Occupied by:All container:"Board" components:{"Triangle"})
                )
                #1
            )
            if:(or 
                (not ("IsSiteProtectedByEntrenchment" (to) (from))) 
                (is In (to) (sites Occupied by:Mover container:"Board" components:{"RiderOutline"}))
            )
        )
        (then (remove (last To)))
    )
)

(define "ArtilleryShootBridge"
    (move Select
        (from (from) 
            if:(and {
                (= (state at:(from)) 1)
                (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))
            })
        )
        (to
            (intersection 
                "RegionBridge"
                #1
            )
            if:(not ("IsSiteProtectedByEntrenchment" (to) (from))) 
        )
        (then (forget Value "Bridges" (last To)))
    )
)

(define "ArtilleryBurnBridge"
    (move Select
        (from (from) 
            if:(and {
                (= (state at:(from)) 1)
                (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))
            })
        )
        (to
            (intersection 
                "RegionBridge"
                #1
            )
            if:(not ("IsSiteProtectedByEntrenchment" (to) (from))) 
        )
        (then 
            // (add (piece (id "Fire" Mover)) (to (last To)))
            ("SetFireRegion" (last To) Mover)
        )
    )
)

(define "ArtilleryPanning"
    (if (and
            (= (state at:(from)) 1)
            (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))
        )
        (move Set Rotation {0 2 4 6} previous:False next:False)
    )
)

(define "DemolishArtilleryMove"
    (move Select
        (from (from) if:(= (state at:(from)) 1))
        (to
            (intersection 
                (sites Occupied by:All container:"Board" components:{"CannonOutline" "RegimentalOutline"})
                (sites Around (from) Orthogonal)
            )
            if:(> (state at:(to)) 0)
        )
        (then (remove (last To)))
    )
)

//------------------------------------------------------------------------------
// Regions

(define "RegionBridge" (sites (values Remembered "Bridges")))
(define "RegionFire1" (sites (values Remembered "Fires1")))
(define "RegionFire2" (sites (values Remembered "Fires2")))
(define "RegionFireTemp" (sites (values Remembered "FireTemp")))

(define "EndBridgePlacementCheck"
    (if 
        ("HandEmpty" P2)
        (and {
            (set Hidden (sites Board) False to:All) 
            (set Var "FromArtillerySite" -1)
            (set Var "ToArtillerySite" -1)
            (forEach Site (sites Occupied by:All container:"Board" components:{"Square"})
                (and
                    (remember Value "Bridges" (site))
                    (remove (site))
                )
            )
        }) 
        (pass)
    )
)

(define "FireSpreadMoves"
    (move Select
        (from #1)
        (to (from))
        (then 
            (and {
                (forEach Site (intersection (sites Around (last From)) "RegionBridge")
                    (remember Value "FireTemp" (site))
                )
                //(forget Value #2 (last From))
                //(forget Value "Bridges" (last From))
                (moveAgain)
            })
        )
    )
    (move Pass
        (then
            (and {
                (forEach Site #1
                    (and
                        (forget Value #2 (site))
                        (forget Value "Bridges" (site))
                    )
                )
                (forEach Site (sites "FireTemp")
                    (and
                        (remember Value #2 (site))
                        (forget Value "FireTemp" (site))
                    )
                )
                (moveAgain)
            })
        )
    )
)

(define "PlacementMove"
    (move 
        (from (sites Occupied by:Mover container:(mover) components:{"TinSoldier" "RiderOutline" "CannonOutline" "RegimentalOutline" "WagonOutline"})) 
        (to 
            (intersection 
                (sites Mover "Home") 
                (difference (sites Empty) (sites "WaterRegion"))
            )
        ) 
        (then
            (set Rotation (to (last To)) #1 previous:False next:False)
        )
    )
)

//------------------------------------------------------------------------------

(game "Kriegsspiel" 
    (players 2) 
    (equipment { 
        (board (rectangle 33 49)) 
        (hand Each size:6)
        (piece "Mountain" Neutral) 
        (piece "Town" Neutral) 
        (piece "Forest" Neutral) 
        (piece "Triangle" Neutral) 
        (piece "Square" Neutral)
        (regions "HomeP1" P1 (expand (sites Left) steps:15))
        (regions "HomeP2" P2 (expand (sites Right) steps:15))
        
        (piece "CannonOutline" Each
            (or {
                ("ArtillerySlide" 6)
                ("ArtilleryShootStrong" (union (expand origin:(ahead (from)) Orthogonal) (expand origin:(ahead (from) steps:2) Orthogonal)))
                ("ArtilleryShootBridge" (union (expand origin:(ahead (from)) Orthogonal) (expand origin:(ahead (from) steps:2) Orthogonal)))
                "ArtilleryPanning"
            })
            maxState:100
            maxValue:10000
        )
        
        (piece "RegimentalOutline" Each
            (or {
                ("ArtillerySlide" 8)
                ("ArtilleryShootWeak" (expand origin:(ahead (from)) Orthogonal))
                ("ArtilleryEntrenched" (expand origin:(ahead (from)) Orthogonal))
                ("ArtilleryShootBridge" (expand origin:(ahead (from)) Orthogonal))
                "ArtilleryPanning"
            })
        )
        
        (piece "TinSoldier" Each
            (or {
                "InfantryMoves"
            })
        )
        
        (piece "Bishop" Each
            (or {
                "InfantryMoves"
                (if (= (state at:(from)) 1)
                    (move Promote (from) (piece {"RiderOutline"}) Mover)
                )
            })
            maxState:100
        )
        
        (piece "RiderOutline" Each 
            (or {
                "CavalryMoves"
                (if (= (state at:(from)) 1)
                    (move Promote (from) (piece {"Bishop"}) Mover)
                )
            })
        )
        
        (piece "WagonOutline" Each 
            (or {
                ("ArtillerySlide" 8)
                "BuildBridge"
                "DeconstructBridge"
                "BuildBridgeGround"
                "DeconstructBridgeGround"
                "ArtilleryPanning"
            })
        )
        
        (regions "WaterRegion" (sites {343 344 345 346 347 348 349 350 301 302 303 254 205 156 107 58 9 10 59 255 256 399 448 497 
                498 547 596 645 694 695 744 793 842 841 840 839 838 837 836 835 834 833 882 883 884 933 934 885 886 935 887 891 940 
                989 1038 1037 1036 1035 1034 1033 1032 1031 1030 1029 1079 1128 1083 1132 1181 1230 1087 1136 1185 1088 1186 1234 1233 
                1232 1281 1282 1283 1332 1331 1330 1379 1380 1381 1430 1431 1479 1528 1529 1578 1577 1569 1570 1571 1572 1573 1574 1575 
                1576 1520 1471 1524 1475 1426 1377 1376 1375 1326 1277 1228 1229 1279 1328 1089 1090 1091 1140 1189 1190 1239 1240 1289 
                1338 1339 1388 1437 1486 1535 1584 1042 1043 1044 1045 1046 997 948 949 950 951 952 953 1002 1003 1004 955 1005 1006 
                1055 1007 1008 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1300 1251 1202 1153 1104 1352 1401 1450 
                1499 1500 1501 1353 1354 1355 1306 1257 1208 1159 1110 1061 1012 963 1356 1357 1358 1359 1360 1361 1362 1411 1460 
                1509 1558 1557 1606 1607 1313 1314 1315 1266 1267 1268 1269 1270 1271 1272 1273 1217 1168 1119 1070 1118 1069 1020 
                971 922 921 872 823 774 775 776 777 778 779 780 781 782 783 734 733 732 731 730 729 725 681 682 683 676 627 578 579 
                580 581 582 583 584 585 586 587 537 488 529 480 431 382 333 284 235 186 137 88 39 87 38 185 40 41 42 43 44 45 46 47 
                96 145 92 141 190 239 288 337 386 435 484 533 236 237 286 335 384 383 334 285 240 241 290 339 388 387 430 528 527 
                526 525 476 427 574 573 572 571 570 619 668 667 666 665 664 663 614 613 612 661 710 759 808 857 906 611 610 561 609 
                608 607 512 426 377 376 327 278 277 276 275 274 273 272 271 270 269 268 267 266 265 264 263 262 261 260 259 258 257 
        463 414 365 316 604 653 555 506 457 408 359 310 215 166 117 116 228 179 130 81 32})) 
        (regions "MountainRegion" (sites {395 444 493 542 591 784 701 702 703 752 751 750 565 516 913 864 865 914 915 866 1299 1250 1296 1247 1394 1443 1492 1397 1446 1495 1502 1551 1503})) 
        (regions "TownRegion" (sites {449 450 451 452 400 351 352 562 513 563 564 515 1052 1101 1053 1054 1103 1264 1265 1216 1167 1166 1165 1164}))
        (regions "ForestRegion" (sites {499 500 501 790 791 1432 1433 1201 1200 1395 1396 415 416 220 221 184 183 825 826 1117 1116 1115})) 
        (regions "EntrenchmentRegion1" (sites {939 988 1086 1135 1184 1180 1131 1082 1425 1474 1523 1527 1478 1429})) 
        (regions "EntrenchmentRegion2" (sites {932 936 888 889 890 1081})) 
        (regions "EntrenchmentRegion3" (sites {677 628 530 481 432 534 485 436 191 142 93 187 138 89})) 
        (regions "EntrenchmentRegion4" (sites {726 727 728 680 684 535})) 
    }) 
    (rules 
        (meta (passEnd NoEnd))
        (start {
            (place "Mountain0" (sites "MountainRegion"))
            (place "Town0" (sites "TownRegion"))
            (place "Forest0" (sites "ForestRegion"))
            (place "Triangle0" (sites "EntrenchmentRegion1") rotation:2 value:0)
            (place "Triangle0" (sites "EntrenchmentRegion2") rotation:4 value:0)
            (place "Triangle0" (sites "EntrenchmentRegion3") rotation:6 value:0)
            (place "Triangle0" (sites "EntrenchmentRegion4") rotation:0 value:0)
            
            (place "TinSoldier1" 1617 count:76 state:3)
            (place "TinSoldier2" 1623 count:76 state:3)
            
            (place "RiderOutline1" 1618 count:20 state:3)
            (place "RiderOutline2" 1624 count:20 state:3)
            
            (place "CannonOutline1" 1619 count:10 state:3)
            (place "CannonOutline2" 1625 count:10 state:3)
            
            (place "RegimentalOutline1" 1620 count:5 state:3)
            (place "RegimentalOutline2" 1626 count:5 state:3)
            
            (place "WagonOutline1" 1621 count:10 state:3)
            (place "WagonOutline2" 1627 count:10 state:3)
            
            (place "Square0" 1622 count:20 state:3)
            (place "Square0" 1628 count:20 state:3)
            
            (set Hidden (sites Hand P1) to:P2)
            (set Hidden (sites Hand P2) to:P1)
            (set Hidden (sites P2 "Home") to:P1) 
            (set Hidden (sites P1 "Home") to:P2) 
        })
        phases:{
        (phase "Placement" 
            (play 
                (or {
                    ("PlacementMove" 0)
                    ("PlacementMove" 2)
                    ("PlacementMove" 4)
                    ("PlacementMove" 6)
                }) 
            )
            (nextPhase (= 20 (count in:(sites Hand P2))) "BridgePlacement")
        )
        (phase "BridgePlacement" 
            (play 
                (or
                    // Add bridge to river
                    (move 
                        (from (sites Occupied by:Neutral container:(mover) components:{"Square"})) 
                        (to 
                            (intersection {
                                (sites Mover "Home") 
                                (sites "WaterRegion") 
                                (sites Empty)
                            })
                        ) 
                        (then 
                            "EndBridgePlacementCheck"
                        )
                    )
                    // Add bridge to bridge wagon
                    (move 
                        Select
                        (from (sites Occupied by:Neutral container:(mover) components:{"Square"})) 
                        (to 
                            (intersection 
                                (sites Mover "Home") 
                                (sites Occupied by:Mover container:"Board" components:{"WagonOutline"})
                            )
                            if:(< (value Piece at:(to)) 4)
                        ) 
                        (then 
                            (do
                                (and
                                    (set Value at:(last To) (+ (value Piece at:(last To)) 1))
                                    (set Count at:(last From) (- (count at:(last From)) 1))
                                )
                                next:"EndBridgePlacementCheck"
                            )
                        )
                    )
                )
            ) 
            (nextPhase ("HandEmpty" P2) "FireSpread")
        )
        (phase "FireSpread" 
            (play 
                (if (= (id Mover) 1)
                    (or ("FireSpreadMoves" "RegionFire1" "Fires1"))
                    (or ("FireSpreadMoves" "RegionFire2" "Fires2"))
                )
                
            )
            (nextPhase (was Pass) "Movement")
        )
        (phase "Movement" 
            (play 
                (or
                    (forEach Piece (then (and {(set State at:(last To) 0) (moveAgain)})))
                    (move Pass
                        (then
                            (and {
                                (forEach Site (sites Occupied by:Mover container:"Board")
                                    (if 
                                        (= (state at:(site)) 3)
                                        (set State at:(site) 1)
                                    )
                                )
                                "SetOccupiedEntrenchments"
                                (moveAgain)
                            })
                        )
                    )
                )
            )
            (nextPhase (was Pass) "Actions")
        )
        (phase "Actions" 
            (play 
                (or
                    (forEach Piece (then (and {(set State at:(last To) 0) (set State at:(last From) 0) (moveAgain)})))
                    (move Pass
                        (then 
                            (and {
                                (forEach Site (sites Occupied by:Mover container:"Board")
                                    (set State at:(site) 3)
                                )
                                "SetOccupiedEntrenchments"
                                ("CheckFireSites" Mover)
                            })
                        )
                    )
                )
            )
            (nextPhase (was Pass) "FireSpread")
        )
        }
        (end {
            (if (is In 1323 (sites Occupied by:P2 container:"Board")) (result P2 Win))
            (if (is In 293 (sites Occupied by:P1 container:"Board")) (result P1 Win))
        })
    )
)

//------------------------------------------------------------------------------

(metadata
    
    (info
        {
        (description "<a href=\"https://en.wikipedia.org/wiki/Johann_Christian_Ludwig_Hellwig\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia Page</a>")
        (rules "<a href=\"https://www.researchgate.net/publication/273947007_Die_Auftritte_des_Krieges_sinnlich_machen_Johann_C_L_Hellwig_und_das_Braunschweiger_Kriegsspiel\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Modern translation of the original rules (German)</a>")
        (id "1466")
        (version "1.3.11")
        (classification "board/war/replacement/eliminate/target")
        (credit "Matthew Stephenson")
        }
    )
    
    (graphics {
        (board Colour Phase0 (colour 208 240 192))
        (board Colour InnerEdges (colour Black))
        (board Colour OuterEdges (colour Black))
        (no Sunken)
        
        (region Colour "ForestRegion" (colour 0 100 0))
        (region Colour "WaterRegion" (colour 28 98 216))
        (region Colour "MountainRegion" (colour 194 154 118))
        (region Colour "TownRegion" (colour 50 50 50))
        
        (region Colour "RegionBridge" (colour 158 190 142))
        (region Colour "RegionFire1" (colour 255 0 0))
        (region Colour "RegionFire2" (colour 200 0 0))
        (region Colour "RegionFireTemp" (colour 230 0 0))
        
        (show Symbol "castle" Cell 1323 scale:0.9)
        (show Symbol "castle" Cell 293 scale:0.9)
        
        (piece Colour "Triangle" value:0 fillColour:(colour Orange))
        (piece Colour "Triangle" value:1 fillColour:(colour Yellow))
        (piece Colour "Triangle" value:2 fillColour:(colour Red))
        
        (piece Scale "Square" 0.8)
        (piece Scale "TinSoldier" 0.6)
        (piece Scale "RegimentalOutline" 0.6)
        (piece Scale "CannonOutline" 0.6)
        (piece Scale "RiderOutline" 0.6)
        (piece Scale "WagonOutline" 0.6)
        
        (piece Colour P1 "TinSoldier" fillColour:(colour Black))
        (piece Colour P2 "TinSoldier" fillColour:(colour White) strokeColour:(colour White))
        (piece Colour P2 "RegimentalOutline" strokeColour:(colour White))
        (piece Colour P2 "RiderOutline" strokeColour:(colour White))
        (piece Colour P2 "CannonOutline" strokeColour:(colour White))
        (piece Colour P2 "WagonOutline" strokeColour:(colour White))
        (piece Background P1 image:"square" fillColour:(colour White) scale:0.8)
        (piece Background P2 image:"square" fillColour:(colour Black) scale:0.8)
    })
    
)















(game "Geister" 
    (players 2) 
    
    (equipment { 
        (board (square 6)) 
        (hand Each size:2)
        
        (piece "GhostGood" Each)
        (piece "GhostEvil" Each)
        
        (regions "HomeP1" P1 (difference (expand (sites Bottom) steps:1) (union (sites Side E) (sites Side W))))
        (regions "HomeP2" P2 (difference (expand (sites Top) steps:1) (union (sites Side E) (sites Side W))))
        
        (regions "EscapeP1" P1 {30 35})
        (regions "EscapeP2" P2 {0 5})
        
        (map "Where" {
            (pair (id "GhostGood" P1) (handSite P1)) (pair (id "GhostEvil" P1) (handSite P1 1)) 
            (pair (id "GhostGood" P2) (handSite P2)) (pair (id "GhostEvil" P2) (handSite P2 1)) 
        })
    }) 
    
    (rules 
        (start { 
            (place "GhostGood1" 36 count:4) (place "GhostEvil1" 37 count:4)
            (set Hidden (sites Hand P1) to:P2)
            
            (place "GhostGood2" 38 count:4) (place "GhostEvil2" 39 count:4)
            (set Hidden (sites Hand P2) to:P1)
        })
        
        phases:{
        (phase "Placement" 
            (play 
                (move 
                    (from (sites Occupied by:Mover container:(mover))) 
                    (to 
                        (forEach 
                            (sites Mover "Home") 
                            if:(is Empty (site))
                        )
                    ) 
                    (then 
                        (if 
                            ("HandEmpty" P2) 
                            (and {
                                (set Hidden (sites P2 "Home") False to:P1) 
                                (set Hidden (sites P1 "Home") False to:P2)
                                (set Hidden What (sites P2 "Home") to:P1) 
                                (set Hidden What (sites P1 "Home") to:P2)
                            }) 
                        ) 
                    )
                )
            ) 
            (nextPhase ("HandEmpty" P2) "Movement")
        )
        (phase "Movement" 
            (play
                (forEach Piece {"GhostGood" "GhostEvil"} 
                    (or
                        (move Step
                            Orthogonal 
                            (to 
                                if:(not ("IsFriendAt" (to))) 
                                (apply 
                                    (if ("IsEnemyAt" (to))
                                        (add 
                                            (piece (what at:(to))) 
                                            (to (mapEntry "Where" (what at:(to))))
                                        )
                                    )
                                ) 
                            )
                        )
                        (move Select (from (intersection (sites Occupied by:Mover component:"GhostGood") (sites Mover "Escape")))
                            (then 
                                (trigger "Escaped" (mover))
                            )
                        )
                    )
                )
            )
            (end {
                (if 
                    (or {
                        (no Pieces Mover "GhostEvil" in:(sites Board))
                        (no Pieces Next "GhostGood" in:(sites Board))
                        (is Triggered "Escaped" Mover)
                    }) 
                    (result Mover Win)
                )
                (if 
                    (or
                        (no Pieces Next "GhostEvil" in:(sites Board))
                        (no Pieces Mover "GhostGood" in:(sites Board))
                    ) 
                    (result Mover Loss)
                )
            })
        )
        }
    )
)

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "In Geister, each player has four good ghosts and four evil ghosts â€“ but only the player who owns a ghost can see whether it's good or evil (as with the pieces in Stratego). These ghosts start the game in the back rows of a 6x6 game board with the corners removed. Each turn, a player moves one of his ghosts one square orthogonally. Moving into an opponent's ghost kills that ghost. To win, you must get rid of your own evil ghosts, kill your opponent's good ghosts, or move one of your good ghosts off the board from one of your opponent's corner squares.")
        (rules "Geister is a two-player board game on a 6Ã—6 game board.
            Each player has four good ghosts and four evil ghosts, whose
            type is not revealed to the opponent player. In each turn
            a player can move one of his ghosts one step vertically or
            horizontally. Moving into a square containing an opponent's
            ghost will capture the opponent's ghost and move it off from
            the board. Moving into a square containing an ally ghost
            is not allowed. A player can also move off one of his good
            ghosts from one of the opponent's corner squares. A player
            wins when one of the three conditions is satisfied:
            â€¢ All the player's evil ghosts are captured.
            â€¢ All the opponent's good ghosts are captured.
            â€¢ One of the player's good ghosts is moved off the board
        from one of the opponent's corner squares.")
        (id "1650")
        (source "<a href=\"https://boardgamegeek.com/boardgame/2290/good-bad-ghosts\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />BGG</a>")
        (version "1.3.11")
        (classification "board/race/reach")
        (author "Alex Randolph")
        (credit "Matthew Stephenson")
        }
    )
    
    (graphics {
        (piece Rename piece:"GhostGood" "disc")
        (piece Rename piece:"GhostEvil" "disc")
        (piece Colour "GhostGood" fillColour:(colour Blue))
        (piece Colour "GhostEvil" fillColour:(colour Red))
        (piece scale 0.2)
        (player Colour P1 (colour White))
        (player Colour P2 (colour White))
        (piece Rotate P2 degrees:180)
        (piece Background P1 image:"triangle" fillColour:(colour White))
        (piece Background P2 image:"triangle" fillColour:(colour White) rotation:180)
        (hiddenImage "null")
        (board Colour Phase0 (colour White))
        (board Colour InnerEdges (colour Black))
        (board Colour OuterEdges (colour Black))
        (region Colour "EscapeP1" (colour LightBlue))
        (region Colour "EscapeP2" (colour LightBlue))
    })
    
)















(define "Hit" 1)

(define "Waves"
    (difference (sites Empty) (sites Hidden to:All))
)

// #1 - Large Piece Name
// #2 - Paths
// #3 - Small Piece Name
(define "DefinePiece"
    (piece #3 Each)
    (tile
        #1
        Each
        #2
        (move
            (from if:(is In (from) (sites Hand Mover)))
            (to (intersection (sites Mover "Defence") (sites Empty)))
            (then
                (do
                    (forEach 
                        Site
                        (sites LargePiece at:(last To))
                        (remember Value (site))
                        (then (remove (last To)))
                    )
                    next:(do
                        (forEach
                            Value
                            (values Remembered)
                            (add
                                (piece (id #3 Mover))
                                (to (value))
                                (then (set State at:(last To) 0))
                            )
                        )
                        next:(forget Value All)
                    )
                )
            )
        )
    )
)

// #1 - then clause
(define "ClearShotSpace"
    (set State at:(last From) ("Hit")
        (then
            (set Hidden at:(last From) False to:Mover
                #1
            )
        )
    )
)

(define "CheckForVictory"
    (if
        (and
            (>= (count Turns) 10)
            (= 0 (count Sites in:(intersection (sites Hidden to:Mover) (sites Occupied by:Next))))
        )
        (set Var (id Mover)
            (then
                (forEach Site (sites Board)
                    (set Hidden at:(site) False to:Next)	
                )
            )
        )
    )
)

// #1 - P1/P2
(define "DeclareVictory"
    (if 
        (= (id #1) (var))
        (result #1 Win)
    )
)

//------------------------------------------------------------------------------

(game "Battleships" 
    (players 2) 
    (equipment { 
        (board (rectangle 10 20))
        ("DefinePiece" "CarrierTemplate" { {F F F F} {L F F F F}} "Carrier")
        ("DefinePiece" "BattleshipTemplate" { {F F F} {L F F F}} "Battleship")
        ("DefinePiece" "DestroyerTemplate" { {F F} {L F F}} "Destroyer")
        ("DefinePiece" "SubmarineTemplate" { {F F} {L F F}} "Submarine")
        ("DefinePiece" "PatrolBoatTemplate" { {F} {L F}} "PatrolBoat")
        (regions "Defence" P1 (expand (sites Left) steps:9))
        (regions "Defence" P2 (expand (sites Right) steps:9))
        (hand Each size:5)
    }) 
    (rules
        (start {
            (set Hidden (sites P1 "Defence") to:P2)
            (set Hidden (sites P2 "Defence") to:P1)
            (set Hidden (sites Hand P1) to:P2)
            (set Hidden (sites Hand P2) to:P1)
            (place "CarrierTemplate1" (handSite P1 0))
            (place "CarrierTemplate2" (handSite P2 0))
            (place "BattleshipTemplate1" (handSite P1 1))
            (place "BattleshipTemplate2" (handSite P2 1))
            (place "DestroyerTemplate1" (handSite P1 2))
            (place "DestroyerTemplate2" (handSite P2 2))
            (place "SubmarineTemplate1" (handSite P1 3))
            (place "SubmarineTemplate2" (handSite P2 3))
            (place "PatrolBoatTemplate1" (handSite P1 4))
            (place "PatrolBoatTemplate2" (handSite P2 4))
        })
        phases: {
        (phase "Setup"
            (play (forEach Piece container:(mover)))
            (nextPhase (>= (count Turns) 10) "Playing")
        )
        (phase "Playing"
            (play
                (move Select
                    (from (intersection (sites Next "Defence") (sites Hidden to:Mover)))
                    (then
                        ("ClearShotSpace"
                            (then
                                ("CheckForVictory")
                            )
                        )
                    )
                )
            )
        )
        }
        (end {
            ("DeclareVictory" P1)
            ("DeclareVictory" P2)
        })
    )
)

//------------------------------------------------------------------------------

(metadata
    
    (info
        {
        (description "Battleships is a strategy type guessing game for two players. It is played on ruled grids (paper or board) on which each player's fleet of ships (including battleships) are marked. The locations of the fleets are concealed from the other player. Players alternate turns calling shots at the other player's ships, and the objective of the game is to destroy the opposing player's fleet.")
        (aliases {"Battleship" "Sea Battle"})
        (rules "The first player (Grey) has their home area on the left; the second player (Black) on the right.
            
            In the initial setup phase players move their pieces from their hand to their home area. By default the pieces will be placed vertically. Press 'r' whilst moving it, to place one horizontally.
            
        Finally the players take turns to guess spaces in their opponent's home area. These are revealed to be either water or a ship according to the following code: <b>C</b>arrier - 5 spaces; <b>B</b>attleship - 4 spaces; <b>D</b>estroyer - 3 spaces; <b>S</b>ubmarine - 3 spaces; <b>P</b>atrol Boat - 2 spaces.")
        (id "1551")
        (source "<a href=\"https://en.wikipedia.org/wiki/Battleship_(game)\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (version "1.3.11")
        (classification "board/war/replacement/eliminate/all")
        (credit "Nicholas Bamber")
        (date "1931")
        }
    )
    
    (graphics {
        (piece Rename piece:"Carrier" state:0 "square")
        (piece Rename piece:"Battleship" state:0 "square")
        (piece Rename piece:"Destroyer" state:0 "square")
        (piece Rename piece:"Submarine" state:0 "square")
        (piece Rename piece:"PatrolBoat" state:0 "square")
        (piece Rename piece:"Carrier" state:("Hit") "rubble")
        (piece Rename piece:"Battleship" state:("Hit") "rubble")
        (piece Rename piece:"Destroyer" state:("Hit") "rubble")
        (piece Rename piece:"Submarine" state:("Hit") "rubble")
        (piece Rename piece:"PatrolBoat" state:("Hit") "rubble")
        (piece Foreground "Carrier" image:"C" edgeColour:(colour Red) scale:0.5)
        (piece Foreground "Battleship" image:"B" edgeColour:(colour Red) scale:0.5)
        (piece Foreground "Destroyer" image:"D" edgeColour:(colour Red) scale:0.5)
        (piece Foreground "Submarine" image:"S" edgeColour:(colour Red) scale:0.5)
        (piece Foreground "PatrolBoat" image:"P" edgeColour:(colour Red) scale:0.5)
        (region Colour "Defence" P1 (colour Blue))
        (region Colour "Defence" P2 (colour VeryLightGrey))
        (player Colour P1 (colour LightGrey))
        (show Symbol "waves" ("Waves"))
    })
)
















(define "NumRow" <Num:row>)
(define "NumColumn" 4)
(define "TopRow" (+ 2 (* 3 (- "NumRow" 1))))
(define "NumTry" (var))
(define "RowToPlace" (- "TopRow" (* 3 ("NumTry"))))
(define "RowToCheck" (- "TopRow" (* 3 (- ("NumTry") 1))))

(define "HintPositions" 
    (union
        (sites Row (+ "RowToPlace" 1))
        (sites Row (- "RowToPlace" 1))
    )
)

(define "RightPositionAndColor"
    (= 
        (what at:(regionSite (sites Row ("RowToPlace")) index:(value))) 
        (what at:(coord row:0 column:(value)))
    )
)

(define "ColorInSolution"
    (is In (what at:(regionSite (sites Bottom) index:(value))) 
        (results from:(sites Row ("RowToPlace")) to:0 (what at:(from)))
    )
)

(define "CombinationPlaced"
    (= 0 (count Sites in:(intersection (sites Empty) (sites Row ("RowToPlace")))))
)

(define "CombinationToFindPlaced"
    (= 0 (count Sites in:(intersection (sites Empty) (sites Bottom))))
)

(define "PositionAndColorOK"
    (= (what at:(site)) (what at:(coord row:0 column:(column of:(site)))))
)

(define "CombinationFound"
    (and
        (= 0 (count Sites in:(intersection (sites Empty) (sites Row ("RowToCheck")))))
        (= "NumColumn" 
            (count Sites in:(forEach (sites Row ("RowToCheck")) if:("PositionAndColorOK")))
        )
    )
)

(define "AddHint" 
    (add (piece #1) (to (regionSite ("HintPositions") index:(value))))		
)

(define "AddBlackHint"
    ("AddHint" "Disc2")
)

(define "AddWhiteHint"
    ("AddHint" "Disc1")
)

//-------------------------------------------------------------------------

(game "Mastermind"
    (players 2)
    (equipment {
        (board
            (merge {
                (rectangle (+ 1 "NumRow") "NumColumn")
                (shift "NumColumn" 0.75 
                    (repeat "NumRow" 1 
                        step:{{1 0} {0 1}} 
                        (poly {{0 0} {0 0.5} {0.5 0.5} {0.5 0}})
                    )
                )
            })
            use:Vertex
        )
        (piece "Marker1" Shared)
        (piece "Marker2" Shared)
        (piece "Marker3" Shared)
        (piece "Marker4" Shared)
        (piece "Marker5" Shared)
        (piece "Marker6" Shared)
        (piece "Marker7" Shared)
        (piece "Marker8" Shared)
        
        (piece "Disc1" Shared)
        (piece "Disc2" Shared)
        
        (hand Shared size:8)
    })
    (rules
        (start {
            (place "Marker1" (handSite Shared))
            (place "Marker2" (handSite Shared 1))
            (place "Marker3" (handSite Shared 2))
            (place "Marker4" (handSite Shared 3))
            (place "Marker5" (handSite Shared 4))
            (place "Marker6" (handSite Shared 5))
            (place "Marker7" (handSite Shared 6))
            (place "Marker8" (handSite Shared 7))
        })
        
        phases:{
        (phase "Placement" P1
            (play 
                (move
                    (from (sites Hand Shared))
                    (to (intersection (sites Empty) (sites Bottom)))
                    copy:True
                    (then
                        (and {
                            (set Hidden at:(last To) to:P2)
                            (if ("CombinationToFindPlaced")
                                (set Var 0) // Init number of try.
                                (moveAgain)
                            )
                        })
                    )
                )
            )
        )
        (phase "Finding" P2
            (play
                (move
                    (from (sites Hand Shared))
                    (to (intersection (sites Empty) (sites Row ("RowToPlace"))))
                    copy:True
                    (then
                        (and 
                            (moveAgain)
                            (if ("CombinationPlaced")
                                (and
                                    (forEach Value min:0 max:(- "NumColumn" 1)
                                        (if ("RightPositionAndColor")
                                            ("AddBlackHint")
                                            (if ("ColorInSolution")
                                                ("AddWhiteHint")
                                            )
                                        )
                                    )
                                    (set Var (+ 1 ("NumTry")))
                                    (then
                                        (if (or ("CombinationFound") (>= "NumTry" "NumRow"))
                                            (forEach Site (sites Bottom)
                                                (set Hidden at:(site) False to:P2)	
                                            )
                                        )		
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (end {
                (if ("CombinationFound") (result P2 Win))
                (if (>= "NumTry" "NumRow") (result P1 Win))
            })
        )
        }
    )
)

//------------------------------------------------------------------------------

(option "Board Size" <Num> args:{ <row> } {
    (item "4 Tries" <4> "P2 has 4 tries.") 
    (item "6 Tries" <6> "The game is played on a 6x6 board.") 
    (item "8 Tries" <8> "The game is played on a 8x8 board.") 
    (item "10 Tries" <10> "The game is played on a 10x10 board.") 
    (item "12 Tries" <12> "The game is played on a 12x12 board.")* 
    (item "14 Tries" <14> "The game is played on a 14x14 board.") 
    (item "16 Tries" <16> "The game is played on a 16x16 board.") 
    (item "18 Tries" <18> "The game is played on a 18x18 board.") 
})

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Mastermind is a code-breaking game for two players.")
        (aliases {"Master Mind"})
        (rules "At the beginning of the game, the first player places 4 pieces of any colour in the bottom row. These pieces will be hidden to the second player during all the game.
            
            The objective of the second player (called codebreaker) is to try to guess the pattern, in both order and color, within a specific number of tries (corresponding to the number of rows). Each guess is made by placing a row of code pegs on the board.
        Once placed, a feedback on his last try is provided by placing from zero to four key pegs in the small holes of the row with the guess. A black key peg is placed for each code peg from the guess which is correct in both color and position. A white key peg indicates the existence of a correct color code peg placed in the wrong position.")
        (id "1157")
        (source "<a href=\"https://en.wikipedia.org/wiki/Mastermind_(board_game)\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (version "1.3.11")
        (classification "math")
        (author "Mordecai Meirowitz")
        (credit "Eric Piette")
        (date "1970")
        }
    )
    
    (graphics {
        (show Edges Hidden)
        (piece Colour "Marker1" fillColour:(colour White))
        (piece Colour "Marker2" fillColour:(colour Black))
        (piece Colour "Marker3" fillColour:(colour Red))
        (piece Colour "Marker4" fillColour:(colour Blue))
        (piece Colour "Marker5" fillColour:(colour Yellow))
        (piece Colour "Marker6" fillColour:(colour Purple))
        (piece Colour "Marker7" fillColour:(colour Green))
        (piece Colour "Marker8" fillColour:(colour Orange))
        
        (piece Colour "Disc1" fillColour:(colour White))
        (piece Colour "Disc2" fillColour:(colour Black))
        
        (piece Scale "Marker" container:1 1)
        (piece Scale "Marker" 1.5)
        (board Colour InnerVertices (colour DarkGrey))
        (board Colour OuterVertices (colour DarkGrey))
        (board Background fillColour:(colour 255 250 220) edgeColour:(colour 100 95 75) scale:2.0)
        (show Line {{3 6}} Edge (colour Black) scale:2.0)
        (show Symbol "disc" (expand (sites Bottom) steps:"NumRow") fillColour:(colour DarkGrey) edgeColour:(colour DarkGrey) scale:0.666)
        (hand Placement Shared scale:0.4 offsetX:0.75 offsetY:0.25 vertical:True)
    })
    
)










(match "Bul" 
    (players <Player:num>)
    (games {
        (subgame "Aj Sayil"  <Player:option> next:1)
        (subgame "Aj T'iwil" <Player:option> next:2)
        (subgame "Aj Sina'anil" <Player:option> next:3)
        (subgame "Aj Sakakil" <Player:option> next:4)
        (subgame "A K'aak'il" <Player:option>  )
    })
    <Player:end>
)

//------------------------------------------------------------------------------

(option "Players" <Player> args:{ <num> <end> <option> }
    {
    (item "6" <6> 
        <
        (end { 
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P4))) (result P1 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P4))) (result P2 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P4))) (result P3 Win))
            
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P4))) (result P4 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P4))) (result P5 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P4))) (result P6 Win))
        })
        >
        <>
    "The game has 6 players.") 
    (item "8" <8> 
        <
        (end { 
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P5))) (result P1 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P5))) (result P2 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P5))) (result P3 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P5))) (result P4 Win))
            
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P5))) (result P5 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P5))) (result P6 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P5))) (result P7 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P5))) (result P8 Win))
        })
        >
        <"Players/8">
    "The game has 8 players.") 
    (item "10" <10> 
        <
        (end { 
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P6))) (result P1 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P6))) (result P2 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P6))) (result P3 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P6))) (result P4 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P6))) (result P5 Win))
            
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P6))) (result P6 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P6))) (result P7 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P6))) (result P8 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P6))) (result P9 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P6))) (result P10 Win))
        })
        >
        <"Players/10">
    "The game has 10 players.") 
    (item "12" <12> 
        <
        (end { 
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P7))) (result P1 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P7))) (result P2 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P7))) (result P3 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P7))) (result P4 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P7))) (result P5 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P7))) (result P6 Win))
            
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P7))) (result P7 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P7))) (result P8 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P7))) (result P9 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P7))) (result P10 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P7))) (result P11 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P7))) (result P12 Win))
        })
        >
        <"Players/12">
    "The game has 12 players.") 
    (item "14" <14> 
        <
        (end { 
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P8))) (result P1 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P8))) (result P2 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P8))) (result P3 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P8))) (result P4 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P8))) (result P5 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P8))) (result P6 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P8))) (result P7 Win))
            
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P8))) (result P8 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P8))) (result P9 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P8))) (result P10 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P8))) (result P11 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P8))) (result P12 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P8))) (result P13 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P8))) (result P14 Win))
        })
        >
        <"Players/14">
    "The game has 14 players.") 
    (item "16" <16> 
        <
        (end { 
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P9))) (result P1 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P9))) (result P2 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P9))) (result P3 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P9))) (result P4 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P9))) (result P5 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P9))) (result P6 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P9))) (result P7 Win))
            (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P9))) (result P8 Win))
            
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P9))) (result P9 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P9))) (result P10 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P9))) (result P11 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P9))) (result P12 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P9))) (result P13 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P9))) (result P14 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P9))) (result P15 Win))
            (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P9))) (result P16 Win))
        })
        >
        <"Players/16">
    "The game has 16 players.") 
})

//------------------------------------------------------------------------------

(rulesets { 
    (ruleset "Ruleset/Bul (Described)" {
        "Players/6"
        }
        variations:{"Players/8" "Players/10" "Players/12" "Players/14" "Players/16"}
    )*
})

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Bul is a game played in the Maya area by men, and which plays an important role in the Vigil of the Maize ceremony. It is a race game that involves capturing and stacking.")
        (rules "Six or more players (even number), played on two teams. The games Aj Sayil, Aj T'iwil, Aj Sina'anil, Aj Sakakil, and A K'aak'il are played in succession.")
        (source "Verbeeck 1998: 87-90.")
        (id "327")
        (version "1.3.11")
        (classification "board/war/replacement/eliminate/all")
        }
    )
    
)













(game "Ataxx" 
    (players 2) 
    (equipment { 
        (board (square 7)) 
        (piece "Marker" Each 
            (or 
                (move 
                    (from) 
                    (to (sites Around (from)) if:(is Empty (to))) 
                    copy:True
                )
                (move 
                    (from) 
                    (to 
                        (difference 
                            (expand origin:(from) steps:2) 
                            (expand origin:(from))
                        ) 
                        if:(is Empty (to))
                    )
                )
                (then
                    (forEach Site 
                        (intersection 
                            (sites Around (last To)) 
                            (sites Occupied by:Next)
                        )
                        (and 
                            (remove (site)) 
                            (add (piece (id "Marker" Mover)) (to (site))) 
                        )
                    )
                )
            )
        )
        }
    ) 
    (rules 
        (start {
            (set Score Each 2)
            (place "Marker1" {"A1" "G7"})
            (place "Marker2" {"A7" "G1"})
        })
        (play (forEach Piece
                (then 
                    (and 
                        (set Score P1 (count Sites in:(sites Occupied by:P1)))	 
                        (set Score P2 (count Sites in:(sites Occupied by:P2)))
                    )
                )	
            )
        )
        
        (end
            (if (or 
                    ("NoSites" (sites Occupied by:Next)) 
                    (is Full)
                )
                (byScore)
            )
        )
    )
)

(metadata
    
    (info
        {
        (description "Ataxx is an arcade game invented in 1990 by the Leland Corporation and was originally called Infection.")
        (aliases {"Infection"})
        (rules "Each player begins with two pieces on the four corners of the board, with each player's pieces in opposite corners. Players move one piece one or two spaces in any direction orthogonally or diagonally. If the piece is moved on space, another piece is added on the origin space. All of the opponent's pieces adjacent to the space to which the player moved now belong to the player who moved. Play ends when all spaces have been filled or one of the players has no remaining pieces. The player with the most pieces wins.")
        (source "<a href=\"https://en.wikipedia.org/wiki/Ataxx\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (id "419")
        (version "1.3.11")
        (classification "board/space/territory")
        (author "Dave Crummack, Craig Galley")
        (publisher "Capcom Co., Ltd., Leland Corporation, Virgin")
        (credit "Eric Piette")
        (date "1990")
        }
    )
    
    (graphics {
        (player Colour P1 (colour Red))
        (player Colour P2 (colour Blue))
    })
    
    (ai 
        "Ataxx_ai"
    )
    
)















(define "NumContagionByTurn" 3)

(define "NumContainmentByTurn" 4)

(define "EdgeInCommon" 
    (intersection (sites Incident Edge of:Cell at:(from)) 
        (sites Incident Edge of:Cell at:(to))
    ) 
)

(define "NoEdgeBetweenCells"
    (not 
        ("NoSites" 
            (sites Around 
                (to) 
                Own 
                Orthogonal 
                if:("NoSites" 
                    (difference 
                        "EdgeInCommon"
                        (sites Empty Edge)
                    )
                )
            )
        )
    )
)

//------------------------------------------------------------------------------

(game "Contagion" 
    (players 2) 
    (equipment {
        (board <Board>)
    }) 
    
    (rules 
        (start (set Score P2 (* (count Rows) (count Columns))))
        
        phases:{
        (phase "InitContagion" P1 
            (play 
                (move Add
                    (to
                        Cell 
                        (sites Empty Cell)
                    )
                    (then 
                        (and 
                            (if (< (count MovesThisTurn) (- "NumContagionByTurn" 1)) (moveAgain)) 
                            (addScore {P1 P2} {1 -1}) 
                        ) 
                    )
                )
            )
            (nextPhase (not (is Next Mover)) "ContagionGrowth")
        )
        
        (phase "ContagionGrowth" P1 
            (play (move Add 
                    (to 
                        Cell 
                        (sites Empty Cell) 
                        if:("NoEdgeBetweenCells")
                    ) 
                    (then 
                        (and 
                            (if (< (count MovesThisTurn) (- "NumContagionByTurn" 1)) (moveAgain)) 
                            (addScore {P1 P2} {1 -1})
                        )
                    )
                )
            )
        )
        
        (phase "Containment" P2
            (play
                (move Add
                    (to
                        Edge 
                        (sites Empty Edge)
                    )
                    (then 
                        (if 
                            (< (count MovesThisTurn) (- "NumContainmentByTurn" 1)) 
                            (moveAgain)
                        )
                    )
                )
            )
        )
        }
        (end {
            (if (> (score P1) (/ (* (count Rows) (count Columns)) 2)) (result P1 Win))
            (if (no Moves P1) (result P2 Win))
        })
    )
)

//------------------------------------------------------------------------------

(option "Board Size" <Board> args:{ <size> }
    {
    (item "2x2" <(rectangle 2 2)> "The game is played on a 2x2 board") 
    (item "3x3" <(rectangle 3 3)> "The game is played on a 3x3 board") 
    (item "4x4" <(rectangle 4 4)> "The game is played on a 4x4 board") 
    (item "5x10" <(rectangle 5 10)> "The game is played on a 5x10 board") 
    (item "5x5" <(rectangle 5 5)> "The game is played on a 5x5 board") 
    (item "6x6" <(rectangle 6 6)> "The game is played on a 6x6 board") 
    (item "7x7" <(rectangle 7 7)> "The game is played on a 7x7 board") 
    (item "8x8" <(rectangle 8 8)> "The game is played on a 8x8 board")** 
    (item "9x9" <(rectangle 9 9)> "The game is played on a 9x9 board") 
    (item "10x5" <(rectangle 10 5)> "The game is played on a 10x5 board") 
    (item "10x10" <(rectangle 10 10)> "The game is played on a 10x10 board") 
    (item "11x11" <(rectangle 11 11)> "The game is played on a 11x11 board") 
    (item "12x12" <(rectangle 12 12)> "The game is played on a 12x12 board") 
    (item "13x13" <(rectangle 13 13)> "The game is played on a 13x13 board") 
    (item "14x14" <(rectangle 14 14)> "The game is played on a 14x14 board") 
    (item "15x15" <(rectangle 15 15)> "The game is played on a 15x15 board") 
})

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Contagion was invented by game designer David King.")
        (rules "The face player places three faces each turn. The edge player places four edges each turn. The face player goes first and can specify any locations on the board on their first turn. On all subsequent turns the face player can only place a face next to another face (orthogonally), that does not pass through an edge. The edge player can place their four lines anywhere. The game is finished when the face player cannot add a piece or if they cover more than half the board.")
        (id "132")
        (version "1.3.11")
        (classification "math/graph")
        (author "David King")
        (credit "Eric Piette")
        (date "01-05-2019")
        }
    )
    
    (graphics {
        (player Colour P1 (colour Black))
        (player Colour P2 (colour Blue))
        (board Style PenAndPaper replaceComponentsWithFilledCells:True)
    })
    
    (ai
        "Contagion_ai"
    )
)











(define "NonpriorityMoves" // arg: "NonMoverHops" see Chosen:nonMoverCaptures
    (or {
        (if
            ("SameTurn")
            (or
                <Passing:afterMovement>  // ("TurnPass") vs ("PlaceDisc")
                ("PlaceHex")
            )
            (or
                {
                <Passing:turn> // ("TurnPass") vs ("PlaceDisc")
                ("PlaceHex")
                ("PlaceDisc")
                ("DiscStep")
                }
        ))
        #1
        #2
    })
)

(define "PriorityHopsOnly" // No friendly hops 
    (priority
        ("NonMoverHops")
        ("NonpriorityMoves" ~ ~)
    )
)

(define "PriorityHops" // Friendly Hops allowed 
    (priority
        ("NonMoverHops")
        ("NonpriorityMoves" ("MoverHops") ~)
    )
) 

(define "MoverHops"
    ("HopChange" <CapOption:friendHops> "MoverSites")
)

(define "NonMoverHops"
    ("HopChange" <CapOption:enemyHops> "NonMoverSites")
)

(define "HopChange" // Options: eg. "Moversites" or "NonMoverSites"
    (if 
        ("SameTurn")
        (if (is Pending)
            (#1 (from (last To)) #2)
        )
        (do (forget Value All) 
            next:(#1 (from) #2)
        )
    )
)

//-------------------------------------------
//Player region defines

(define "MoverSites"
    (sites Occupied by:Mover)
)

(define "NonMoverSites"
    (difference 
        (sites Occupied by:All)
        (sites Occupied by:Mover)
))

//-------------------------------------------
//Integer constants defines

(define "ValueDisc" <DiscPenalty:discVal>)
(define "ValueHex" <TerritoryScore:hexVal>)

//-------------------------------------------
//Procedural functional defines

(define "TurnPass"
    (do 
        (if
            (= 0 (var "FirstNoPlace"))
            (set Var "FirstNoPlace" (mover)) 
            (if
                (= (next) (var "FirstNoPlace"))
                (propose "End")
            )
        )
        next:(move Pass)
    )
)
(define "Yield" // argument where from, who's pieces
    (or
        ("GeneralHop" #1 #2 <Board:piece> <Board:piece> "ValueHex" "ValueHex")
        ("GeneralHop" #1 #2 "Disc" <Board:piece> "ValueDisc" "ValueHex")
    )
)

(define "NoMorph" // argument where from, who's pieces
    (or
        ("GeneralHop" #1 #2 <Board:piece> <Board:piece> "ValueHex" "ValueHex")
        ("GeneralHop" #1 #2 "Disc" "Disc" "ValueDisc" "ValueDisc")
    )
)

(define "Morph" // argument where from, who's pieces
    (or
        ("GeneralHop" #1 #2 "Disc" <Board:piece> "ValueDisc" "ValueHex")
        ("GeneralHop" #1 #2 <Board:piece> "Disc" "ValueHex" "ValueDisc")
    )
)

(define "GeneralHop" // argument where from, who's sites, piece type hopped, piece typ replaced
    (forEach Piece "Disc"
        (move Hop #1 <Board:adj> 
            (between 
                if:(is 
                    In 
                    (between)
                    (difference 
                        (intersection
                            #2
                            (sites Occupied by:All component:#3) 
                        )
                        (sites (values Remembered))
                    )
                )
                (apply 
                    (and 
                        (addScore (player (who at:(between))) (- #5))
                        (set Pending (between))
                    )
                )
            )
            (to if:(is Empty (to)))
        )
        (then
            (and {
                (remember Value (value Pending))
                (remove (value Pending))
                (add (piece (id #4 Mover)) (to (value Pending)))
                (addScore Mover #6)
                }
                (then
                    (and
                        (set Pending)
                        (moveAgain)
                    )
                )
            )
        )
    )
) 

(define "DiscStep"
    (forEach Piece "Disc"
        (move 
            (from (from)) 
            (to (sites Around (from) <Board:adj> ) if:(is Empty (to))) 
            (then (moveAgain))
        )
    )
)

(define "PlaceHex"
    (move 
        Add 
        (piece (id <Board:piece> Mover))
        (to (forEach (sites Empty) if:"HexSite")) 
        (then 
            (and
                (addScore Mover "ValueHex")
                (set Var "FirstNoPlace" 0)
            )
        )
    )
)

(define "PlaceDisc" 
    (move Add 
        (piece (id "Disc" Mover))
        (to (forEach <PlaceDisc:suicideOption> if:<PlaceDisc:location>))
        (then 
            (and
                (addScore Mover "ValueDisc")
                (set Var "FirstNoPlace" 0)
            )
        )
    )
)

(define "NoSuicide" 
    (difference 
        (sites Empty) 
        (sites To
            (forEach 
                Site 
                (intersection
                    "NonMoverSites"
                    (sites Occupied by:All component:"Disc")
                )
                (select 
                    (from 
                        (sites Distance <Board:adj> from:(site) (exact 2))
                        if:(is Empty (from))
                    )
                    (to
                        (sites Between <Board:adj> from:(from) to:(site))
                    )
                )
            )
        )
    )
)

//----------------------------------------------------------

//Defines for Booleans:

(define "HexSite" (= ("NearestPieces" "MoverSites") ("NearestPieces" "NonMoverSites")))
(define "DiscSite" (!= ("NearestPieces" "MoverSites") ("NearestPieces" "NonMoverSites")))

//--------------------------------------------------
//Defines for Integers

(define "NearestPieces" // arg: Site of player to consider
    (count 
        Sites
        in:(intersection {
            (#1)
            (sites Direction from:(site) <Board:adj>  distance:1)
            (sites LineOfSight Piece at:(site) <Board:adj>) 
        })
    )
)

(define "Dist2NearestLoSEnemy" 
    (min
        (results
            from:(site)
            to:(forEach 
                (sites LineOfSight Piece at:(from) <Board:adj>) 
                if:(or (is Mover (who at:(site))) (is In (site) "NonMoverSites"))
            )
            (count Steps <Board:adj> (from) (to))
        )
    )
)

(define "Dist2NearestLoS"
    (min
        (results
            from:(site)
            to:(sites LineOfSight Piece at:(from) <Board:adj>) 
            (count Steps <Board:adj> (from) (to))
        )
    )
)

//---------------------------------------
// Main routine
//---------------------------------------

(game "Equi Game System"
    (players 2)
    (equipment {
        (board <Board:size> use:Vertex)
        (piece "Disc" Each)
        (piece <Board:piece> Each)
    })
    (rules 
        (start (set Score Each 0)) 
        (play
            <ChosenHop:prioritySetting>
        )
        (end 
            {
            (if
                (and 
                    {
                    <Passing:endImplication>
                    (= 1 (var "FirstNoPlace")) 
                    (= (score Mover) (score Next))
                    }
                )
                (result P1 Win)
            )
            
            (if
                (and 
                    {
                    <Passing:endImplication>
                    (= 2 (var "FirstNoPlace")) 
                    (= (score Mover) (score Next))
                    }
                )
                (result P2 Win)
            )
            
            (if
                (and
                    <Passing:endImplication>
                    (!= (score Mover) (score Next))
                )
                (byScore)
            )
            
            }
            
        )
    )
)

//---------------------------------------

(option "Board Size" <Board> args:{ <size> <piece> <adj> <diag> }
    {
    (item "Hex 3-4"        <(tri {3 4 3 4 3})>  <"Hex">     <Orthogonal> <Hidden>  "Board & size: Hexhex with edges alternating 3 and 4")
    (item "Hex 5-6"        <(tri {5 6 5 7 5})>  <"Hex">     <Orthogonal> <Hidden>  "Board & size: Hexhex with edges alternating 5 and 6") // standard strategy
    (item "Hex 7-8"        <(tri {7 8 7 10 6})> <"Hex">     <Orthogonal> <Hidden>  "Board & size: Hexhex with edges alternating 7 and 8")
    (item "Hex 4"          <(tri Hexagon 4)>    <"Hex">     <Orthogonal> <Hidden>  "Board & size: Hexhex 4") 
    (item "Hex 5"          <(tri Hexagon 5)>    <"Hex">     <Orthogonal> <Hidden>  "Board & size: Hexhex 5") 
    (item "Hex 6"          <(tri Hexagon 6)>    <"Hex">     <Orthogonal> <Hidden>  "Board & size: Hexhex 6") 
    (item "Hex 7"          <(tri Hexagon 7)>    <"Hex">     <Orthogonal> <Hidden>  "Board & size: Hexhex 7") 
    (item "Square 5 ortho" <(square 5)>         <"Square">  <Orthogonal> <Hidden>  "Board & size: Orthogonal 5") 
    (item "Square 7 ortho" <(square 7)>         <"Square">  <Orthogonal> <Hidden>  "Board & size: Orthogonal 7") 
    (item "Square 9 ortho" <(square 9)>         <"Square">  <Orthogonal> <Hidden>  "Board & size: Orthogonal 9") 
    (item "Square 4 omni" 
        <(add
            (remove (square 7) vertices:{ 0 1 2 4 5 6 7 8 12 13 14 20 28 34 35 36 40 41 42 43 44 46 47 48})
            edges:{{0 1} {0 3} {3 8} {1 4} {4 9} {8 15} {9 16} {15 20} {16 21} {20 23} {21 24} {23 24}}
        )> 
    <"Square"> <All> <Thin> "Board & size: Orthogonal 4")
    
    (item "Square 5 omni" 
        <(add
            (remove (square 9) vertices:{
                0  1  2  3     5  6  7  8
                9 10 11          15 16 17
                18 19                25 26
                27                      35
                
                45                      53
                54 55                61 62 
                63 64 65          69 70 71
            72 73 74 75    77 78 79 80 })
            
        edges:{{0 1} {0 3} {3 8} {1 4} {4 9} {8 15} {9 16} {15 24} {16 25} {24 31} {25 32} {31 36} {32 37} {36 39} {37 40} {39 40}} )> 
        
    <"Square"> <All> <Thin> "Board & size: Orthogonal 5")
    
    (item "Square 6 omni" 
        <(add 
            (remove (square 11) vertices:{
                0   1   2   3   4       6   7   8   9   10 
                11  12  13  14              18  19  20  21 
                22  23  24                      30  31  32  
                33  34                              42  43  
                44                                      54  
                
                66                                      76  
                77  78                              86  87  
                88  89  90                      96  97  98  
                99 100 101 102             106 107 108 109 
            110 111 112 113 114     116 117 118 119 120 }) 
            
        edges:{{0 1} {0 3} {3 8} {1 4} {4 9} {8 15} {9 16} {15 24} {16 25} {24 35} {25 36} {35 44} {36 45} {44 51} {45 52} {51 56} {52 57} {56 59} {57 60} {59 60}} )>
        
    <"Square"> <All> <Thin> "Board & size: Orthogonal 6") 
    
    (item "Square 7 omni" 
        <(add
            (remove (square 13) vertices:{
                0   1   2   3   4   5       7   8   9  10  11  12  
                13  14  15  16  17              21  22  23  24  25  
                26  27  28  29                      35  36  37  38  
                39  40  41                              49  50  51  
                52  53                                      63  64  
                65                                              77  
                
                91                                             103 
                104 105                                     115 116 
                117 118 119                             127 128 129 
                130 131 132 133                     139 140 141 142 
                143 144 145 146 147             151 152 153 154 155 
            156 157 158 159 160 161     163 164 165 166 167 168 })
            
        edges:{{0 1} {0 3} {3 8} {1 4} {4 9} {8 15} {9 16} {15 24} {16 25} {24 35} {25 36} {35 48} {36 49} {48 59} {49 60} {59 68} {60 69} {68 75} {69 76} {75 80} {76 81} {80 83} {81 84} {83 84}} )>
        
    <"Square"> <All> <Thin> "Board & size: Orthogonal 7") 
    }
)

(option "Capture" <CapOption> args:{ <enemyHops> <friendHops> }
    {
    (item "Morph All"   <"Morph">   <"Morph">   "All hopped pieces change type, Hopped enemies also change ownership")
    (item "Morph Enemy" <"Morph">   <"NoMorph"> "Hopped enemies change type and ownership, Hopped friendly pieces are unaffected")
    (item "Morph Own"   <"NoMorph"> <"Morph">   "Hopped enemies only change ownership, Hopped friendly pieces change type")
    (item "No Morphs"   <"NoMorph"> <"NoMorph"> "Hopped enemies only change ownership, Hopped friendly pieces are unaffected")
    (item "Yields Friendly Territory"   <"Yield"> <"Yield"> "All hopped pieces become friendly territory pieces.")*
    }
)

(option "Hopping" <ChosenHop> args: { <prioritySetting> }
    {
    (item "Mandatory - Can hop own"    <("PriorityHops")>     "An adjacent Enemy must be hopped, a Friend may be.")*
    (item "Mandatory - Cannot hop own" <("PriorityHopsOnly")> "An adjacent Enemy must be hopped, Friends cannot be")    
    (item "Optional - Can hop own"     <("NonpriorityMoves" ("MoverHops") ("NonMoverHops"))> "Hopping is Optional")
    (item "Optional - Cannot hop own"  <("NonpriorityMoves" ("NonMoverHops") ~)>             "Hopping is Optional")
    }
)

(option "Passing" <Passing> args:{ <turn> <afterMovement> <endImplication> }
    {
    (item "Full Turn" <("TurnPass")> <("TurnPass")> <(or (no Moves Mover) (is Proposed "End"))>
        "Disc placement is not allowed if Disc movement was taken. Part or all of a turn may be passed except when there are forced jumps. End when neither player places."
    )
    (item "Partial Turn" < > <("TurnPass")> <(or (no Moves Mover) (is Proposed "End"))>
        "Disc placement is not allowed if Disc movement was taken. Placement may be passed if movement was made. End when neither player places."
    )
    (item "Always must place" < > <("PlaceDisc")> <(no Moves Mover)>
        "Place on every turn. Discs may be placed after a Disc movement was made. No Passing, End when board is full."
    )*
    }
)

(option "Discs" <PlaceDisc> args:{ <location> <suicideOption> }
    {
    (item "Anywhere" <(= 1 1)> <(sites Empty)> "Place Discs at any Empty location")
    (item "Non-Hex" <"DiscSite"> <(sites Empty)> "Place Discs at any Non-Hex location")*
    (item "Safe"  <(= 1 1)> <"NoSuicide"> "Place Discs at any Empty location, except where it can be taken by the next player's first hop") 
    (item "Safe - Non-Hex" <"DiscSite"> <"NoSuicide"> "Place Discs at any Non-Hex location, except where it can be taken by the next player's first hop")
    }
)

(option "Territory Value" <TerritoryScore> args:{ <hexVal> }
    {
    (item "1" <1> "Territory score is 1")*
    (item "3" <3> "Territory score is 3")
    (item "5" <5> "Territory score is 5")
    }
)

(option "Disc Value" <DiscPenalty> args:{ <discVal> }
    {
    (item "0" <0> "Discs penalty is 0")
    (item "1" <-1> "Discs penalty is 1")
    (item "3" <-3> "Discs penalty is 3")*
    (item "5" <-5> "Discs penalty is 5")
    }
)

//----------------------------------------------------------

(rulesets { 
    
    (ruleset "Ruleset/Equi (Described)" {
        "Capture/Yields Friendly Territory" 
        "Hopping/Mandatory - Can hop own"
        "Passing/Always must place"
        "Discs/Non-Hex"
        "Territory Value/1"
        "Disc Value/3"
    })*
    
    (ruleset "Ruleset/Equiversi (Described)" {
        "Capture/No Morphs" 
        "Hopping/Mandatory - Cannot hop own"
        "Passing/Partial Turn"
        "Discs/Safe - Non-Hex"
        "Territory Value/1"
        "Disc Value/1"
    })
    
    (ruleset "Ruleset/Equiversi 2 (Described)" {
        "Capture/No Morphs" 
        "Hopping/Mandatory - Can hop own"
        "Passing/Partial Turn"
        "Discs/Anywhere"
        "Territory Value/1"
        "Disc Value/0"
    })
})

//----------------------------------------------------------

(metadata
    (info
        {
        (description "Equi-based games are games that share the following properties:
            - Scoring based on 2 kinds of pieces:
            -- Mobile pieces (discs) that can move and jump, and that penalise one's score.
            -- Territory pieces (cell shaped - hexes or squares) are stationary and give you points, but can only be placed at locations surrounded by equal numbers of one's own pieces and enemy pieces. 
            - Turns based on the sequence of disc movement, followed by piece placement. 
            (This allows the player to move to create an environment for placing a Territory piece.)
            - Game ends when neither player has placed a piece, or when neither can take a turn. 
            
            This creates a lot of complexity in a small board, but retains simple to understand tactical elements and emergent strategies.
            The game trials tend to fill the board, but some variants have traps that can end the game sooner.
            
            Mutators:
            - how 'surrounding' is defined,
            - where the Discs can be placed,
            - the pieces' relative values,
            - what pieces can be jumped and whether jumps are forced,
            - what happens to each kind of piece when jumped, (including removal, transformation of type and/or ownership),
            - whether placement is mandatory,
            - what restrictions are placed on disc placement, 
            - how the game ends, (no move available / no player has made a placement on their preceding turn)
            - number of players.
            
            These yield Equi, Equiversi, and multiplayer Hops-a-Daisy which is different enough to be considered an entirely separate game.
            
            In the work-in-progress (WIP) version of Equi (Dec 2020), the influencing neighbour pieces were found along 'lines of sight', and included only those pieces that were at the same distance as the nearest of them. This had a high perceptual cost in play, and proved unnecessary because it only makes a difference in the opening stages of the game, which already has a high degree of chaos. Thus, the current implementation is limited to using a comparison of directly adjacent piece counts.
            
            The WIP version also had optional placement with special limitations not discussed here, to reduce cycling. 
            
            Equiversi - an evolution of the WIP (Jan 2021) intended to be easier to play and have less cycling issues.
            It has forced opponent hops, but no friendly hops, hopped enemies change ownership but not type, optional placement (game ends if neither player places, last to place loses in a tie), Hex placement based on 'adjacent neighbour' counts, Discs placed at non-Hex locations that don't force jumps, but only if there was no previous Disc movement in the same turn. Game ends when no preceding player has placed on their last turn.
            
            A second evolution, (Jan 2021) was to explore the concept of allowing a choice of Disc values. A value of 0 is the simplest, leading to Equiversi-2, which additionally allows friendly hops again, and relaxes Disc placements to made be anywhere, but only if there was no previous Disc movement in the same turn. This creates a territorial game, as narrow blocked-in areas will not be fillable, and playing a Disc into larger blocked in areas will usually be advantageous for the owner of the walls.
            
            Both these frequently feature tactical endings in which a player times a favourable score oscillation with a depletion of placement opportunities for the opponent after forcing him to jump.
            
            The latest Equi, (Nov 2022) implemented here, eliminates such surprise endings and focuses on the tactical trade-off of mobility vs score found in the original while avoiding the possibility of ties and playing with fewer moves on the same sized board. The capture-conversion applies to all pieces converting every type to friendly Territory. Forced placement can force adding Discs, and new scoring values incentivise sacrificing the Discs for points or trapping the opponent's Discs. In general, it gives a spread of values to different capture combos, similar in effect to the (1, -1) piece value system without type change found in the WIP version. It has 'adjacent neighbour' based placement rules, forced hopping of enemy pieces and optional friendly hops, all hopped pieces become friendly Territory pieces, Territory value +1, Discs penalise (-3), No passing, Mandatory placement every turn, Hex placement based on neighbour counts, discs only where Hexes are not allowed, suicide placements are OK, Game ends when placement cannot be made. 
            
            Since this version ends with a full board and all pieces have odd values; on a board with odd cells there cannot be a tied score.
            
            The game can also be played with the same rules on orthogonal square grids and square+diagonal grids.
            
            Evolution to Hops-a-Daisy:            
            Nothing in the game prohibits a multi-player implementation, except that king-making could be an issue, and the definition for the Hex placement must be refined as to whose pieces are being compared.  Since the Multiplayer game is a totally different experience aimed at casual, chaotic play, it is implemented separately as an entirely different game on the site. The defaults for that game involve more elaborate piece mutations as a result of the jumps, as well.
            
        These games also inspired Refugia, with different placement restrictions, single piece types, and ownership changes taking place in stages, which has been implemented separately on Ludii.")
        (useFor "Ruleset/Equi (Described)" (rules "Equi is a 2-player strategy game in the Equi game system.
                It may be played:
                -- on a hex grid using hexagonal Territory pieces or
                -- on a square grid using square Territory pieces or 
                -- on a square plus diagonal grid using square Territory pieces.
                
                It also uses Discs or counters as mobile pieces. 
                
                The goal is to maximize your score when the board is full. 
                
                Black starts by placing a black hex anywhere on the empty board, except for a corner. Turns then alternate.
                
                A turn has two parts: first 'The Move', and then 'The Required Placement'.
                
                The Move:
                Only Discs may move. 
                
                A Disc may either:
            - A) move one step to an empty adjacent space, or 
        - B) jump across a single piece belonging to either player onto the empty space directly behind it. 
        -- As soon as any piece is jumped, the jumped piece is converted into a friendly Territory piece.
        -- Multiple consecutive jumps using the same piece are allowed, but no piece can be jumped more than once on the same turn.
        -- If the active Disc lands next to any enemy pieces which it can jump, it must immediately jump one of them.
        
        Forced Movement: 
        If at the beginning of the turn, any enemy pieces can be jumped, the turn must start by jumping one.
        Otherwise, choosing to move a Disc is optional.
        
        The Required Placement:
        Placement is mandatory, may use either type, depending on location, (and is separate from the conversions due to jumping.)
        
        The placement must be made to an empty space on the board (possibly the place that Disc moved from.)
        The type of piece that gets placed depends on the number of pieces on the adjacent locations at the time of placement:
        -- If there are no adjacent pieces, or if the number of adjacent pieces is the same for each player, then a Territory piece is placed. 
        -- Otherwise, a Disc must be placed there.
        
        The game ends when neither player has placed a piece on their previous turn.
        You score 1 point for each of your Territory pieces and deduct 3 points for each Disc.
        
On a board with an odd number of cells there are no ties."))
(useFor "Ruleset/Equi (Described)" (id "2878"))
(useFor "Ruleset/Equiversi (Described)" (rules "Equi is a 2-player strategy game in the Equi game system.
        It may be played:
        -- on a hex grid using hexagonal Territory pieces or
        -- on a square grid using square Territory pieces or 
        -- on a square plus diagonal grid using square Territory pieces.
        
        It also uses Discs or counters as mobile pieces. 
        
        The goal is to maximize your score when the board is full. 
        
        Black starts by placing a black hex anywhere on the empty board, except for a corner. Turns then alternate.
        
        A turn has two parts: first 'The Move', and then 'The Required Placement'.
        
        Passing a turn is not allowed, but passing one part of a turn is allowed.
        
        The Move:
        Only Discs may move. 
        
        A Disc may either:
    - A) move one step to an empty adjacent space, or 
- B) jump across a single piece belonging to either player onto the empty space directly behind it. 
-- As soon as any piece is jumped, the jumped piece is converted into a friendly piece of the same type.
-- Multiple consecutive jumps using the same piece are allowed, but no piece can be jumped more than once on the same turn.
-- If the active Disc lands next to any enemy pieces which it can jump, it must immediately jump one of them.

Forced Movement: 
If at the beginning of the turn, any enemy pieces can be jumped, the turn must start by jumping one.
Otherwise, choosing to move a Disc is optional.

The Placement:
Placement is separate from the conversions due to jumping.
Disc placement is not allowed if Disc movement has occured.

The placement must be made to an empty space on the board (possibly the place that Disc moved from.)
The type of piece that gets placed depends on the number of pieces on the adjacent locations at the time of placement:
-- If a Disc may be placed, it may be placed anywhere.
-- On locations where there are no adjacent pieces, or where the number of adjacent pieces is the same for each player, a Territory piece may be placed, instead. 

The game ends when neither player has placed a piece on their previous turn.
You score 1 point for each of your Territory pieces and deduct 1 point for each Disc.

Ties go to the last player to make a placement."))
(useFor "Ruleset/Equiversi (Described)" (id "2879"))
(useFor "Ruleset/Equiversi 2 (Described)" (rules "Equi is a 2-player strategy game in the Equi game system.
        It may be played:
        -- on a hex grid using hexagonal Territory pieces or
        -- on a square grid using square Territory pieces or 
        -- on a square plus diagonal grid using square Territory pieces.
        
        It also uses Discs or counters as mobile pieces. 
        
        The goal is to maximize your score when the board is full. 
        
        Black starts by placing a black hex anywhere on the empty board, except for a corner. Turns then alternate.
        
        A turn has two parts: first 'The Move', and then 'The Required Placement'.
        
        Passing a turn is not allowed, but passing one part of a turn is allowed.
        
        The Move:
        Only Discs may move. 
        
        A Disc may either:
    - A) move one step to an empty adjacent space, or 
- B) jump across a single piece belonging to the opponent onto the empty space directly behind it. 
-- As soon as any piece is jumped, the jumped piece is converted into a friendly piece of the same type.
-- Multiple consecutive jumps using the same piece are allowed, but no piece can be jumped more than once on the same turn.
-- If the active Disc lands next to any enemy pieces which it can jump, it must immediately jump one of them.

Forced Movement: 
If at the beginning of the turn, any enemy pieces can be jumped, the turn must start by jumping one.
Otherwise, choosing to move a Disc is optional.

The Placement:
Placement is separate from the conversions due to jumping.
Disc placement is not allowed if Disc movement has occured

The placement must be made to an empty space on the board (possibly the place that Disc moved from.)
The type of piece that gets placed depends on the number of pieces on the adjacent locations at the time of placement:
-- If there are no adjacent pieces, or if the number of adjacent pieces is the same for each player, then a Territory piece is placed. 
-- Otherwise, a Disc may be placed there - as long as the placed Disc cannot be immediately jumped.

The game ends when the board is full.
You score 1 point for each of your Territory pieces, Discs have no score value.

Ties go to the last player to make a placement."))
(useFor "Ruleset/Equiversi 2 (Described)" (id "2880"))
(id "2878")
(version "1.3.11")
(classification "experimental")
(author "Dale W. Walton")
(credit "Dale W. Walton")
(date "27-11-2022")
}
)

(graphics 
    {
    (board Style Graph)
    (board Colour InnerEdges (colour 62 72 55))
    (board Colour OuterEdges (colour 62 72 55))
    (board Background image:"square" fillColour:(colour 124 145 111) edgeColour:(colour 124 145 111) scale:1.5)
    (board StyleThickness OuterEdges .25)
    (board StyleThickness InnerEdges .25)
    (show Edges Diagonal <Board:diag> (colour 62 72 55))
    (piece Scale  "Square" 1.05)
    (piece Scale  "Hex" scaleX:1.05 scaleY:1.1)
    (piece Scale P1 "Disc" 0.65)
    (piece Scale P2 "Disc" 0.65)
    (piece Scale P3 "Disc" 0.65)
    (piece Scale P4 "Disc" 0.65)
    (piece Scale P5 "Disc" 0.65)
    }
)

(ai
    (heuristics
        {
        (score weight:.4)
        } 
))
)















//(define "ShallowWater" (sites (values Remembered "ShallowWaterRegion")))
//(set RememberValue "ShallowWaterRegion" (sites Random num:5))

//------------------------------------------------------------------------------
// Moves

(define "Move"
    (move 
        (from 
            (from)
            if:(> (state at:(from)) 1)	
        ) 
        (to 
            (sites Distance 
                (step Orthogonal
                    (to 
                        if:(#1)
                    )
                ) 
                from:(from) 
                (range 1 (- #2 1))
            )
            if:(is Empty (to)) 
            (apply 
                (set State at:(from) #3)
            ) 
        )
    )
)

(define "HumanMove"
    (or
        ("Move" (is In (to) "HumanMoveSpots") (state at:(from)) 1)
        ("Move" (is In (to) "RestrictedHumanMoveSpots") 2 1)				// Mountain move, 1 depth
    )
)

(define "VehicleMove"
    (or
        ("Move" (is In (to) "VehicleMoveSpots") (state at:(from)) #1)
        ("Move" (is In (to) "RestrictedVehicleMoveSpots") 2 #1)				// Forest/Shallow water move, 1 depth
    )
)

(define "AircraftMove"
    ("Move" (is In (to) "AircraftMoveSpots") (state at:(from)) 1)
)

(define "BoatMove"
    ("Move" (is In (to) "BoatMoveSpots") (state at:(from)) 1)
)

//------------------------------------------------------------------------------
// Move spots

// Human

(define "ForbiddenSpotsHuman" (sites "DeepWater"))

(define "RestrictedSpotsHuman" (sites "Mountain"))

(define "HumanMoveSpots"
    (difference (union (sites Empty) (sites Occupied by:Friend container:"Board")) (union ("ForbiddenSpotsHuman") ("RestrictedSpotsHuman")))
)

(define "RestrictedHumanMoveSpots"
    (intersection (sites Empty) ("RestrictedSpotsHuman"))
)

// Vehicle

(define "ForbiddenSpotsVehicle" (union (sites "Mountain") (sites "DeepWater")))

(define "RestrictedSpotsVehicle" (union (sites "Forest") (sites "ShallowWater")))

(define "VehicleMoveSpots"
    (difference (union (sites Empty) (sites Occupied by:Friend container:"Board")) (union ("ForbiddenSpotsVehicle") ("RestrictedSpotsVehicle")))
)

(define "RestrictedVehicleMoveSpots"
    (intersection (sites Empty) ("RestrictedSpotsVehicle"))
)

// Aircraft

(define "AircraftMoveSpots"
    (union (sites Empty) (sites Occupied by:Friend container:"Board"))
)

// Boat

(define "ForbiddenSpotsBoat" 
    (union 
        (sites "Mountain") 
        (difference (sites Board) (union (sites "ShallowWater") (sites "DeepWater"))) 
    )
)

(define "BoatMoveSpots"
    (difference 
        (union (sites Empty) (sites Occupied by:Friend container:"Board")) 
        ("ForbiddenSpotsBoat")
    )
)

//------------------------------------------------------------------------------
// Attacks

(define "GroundAttackFrom"
    (is In (from) (sites Occupied by:Mover container:"Board" components:{"Bomber" "Battleship" "Artillery" "Launcher"}))
)

(define "AircraftAttackFrom"
    (is In (from) (sites Occupied by:Mover container:"Board" components:{"Antiair" "Fighter"}))
)

(define "BoatAttackFrom"
    (is In (from) (sites Occupied by:Mover container:"Board" components:{"Submarine"}))
)

(define "GroundAttackCheck"
    (if ("GroundAttackFrom")
        (is In (to) (union (sites Occupied by:Enemy container:"Board" components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board")))
        (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board"))) 
    )
)

(define "BoatAttackCheck"
    (if ("BoatAttackFrom")
        (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Submarine" "Battleship" "Cruiser"}))
        (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board"))) 
    )
)

(define "AircraftAttackCheck"
    (if ("AircraftAttackFrom")
        (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Fighter" "Helicopter" "Bomber"}))
        (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board"))) 
    )
)

//------------------------------------------------------------------------------
// Counter attacks

(define "CounterAttackCheckFrom"
    (is In (#1) (sites Occupied #2 components:#3))
)

(define "GroundCounterAttackCheck"
    (if ("CounterAttackCheckFrom" #1 #2 #5)
        (is In (#3) (union (sites Occupied #4 components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board")))
        (is In (#3) (union (sites Occupied #4) (sites Occupied by:Neutral container:"Board"))) 
    )
)

(define "BoatCounterAttackCheck"
    (if ("CounterAttackCheckFrom" #1 #2 #5)
        (is In (#3) (sites Occupied #4 components:{"Submarine" "Battleship" "Cruiser"}))
        (is In (#3) (union (sites Occupied #4) (sites Occupied by:Neutral container:"Board"))) 
    )
)

(define "AircraftCounterAttackCheck"
    (if ("CounterAttackCheckFrom" #1 #2 #5)
        (is In (#3) (sites Occupied #4 components:{"Fighter" "Helicopter" "Bomber"}))
        (is In (#3) (union (sites Occupied #4) (sites Occupied by:Neutral container:"Board"))) 
    )
)

//------------------------------------------------------------------------------
// Attack Moves

(define "AttackMove"
    (move Select
        (from
            (from)
            if:(> (state at:(from)) 0)
        )
        (to
            (sites Distance Orthogonal from:(from) (range #1 #2))
            if:(and {
                ("GroundAttackCheck")
                ("AircraftAttackCheck")
                ("BoatAttackCheck")
                <FogOfWar:AttackCheck>
            })
        )
        (then 
            (do
                (and 
                    (set Value at:(last To) (max 0 (- (value Piece at:(last To)) ("AttackerDamage" (last From) (last To) False))))
                    (set State at:(last From) 0)
                )
                next:(if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) 	// state = 8, means it's a building
                    // Attacking a building
                    "AttackBuilding"
                    
                    // Attacking a unit
                    (if (= (value Piece at:(last To)) 0)
                        (remove (last To))
                        // counter-attack
                        (if (and {
                                (= 0 (count Sites in:(intersection (sites {(last To) (last From)}) (sites Occupied by:All components:{"Launcher" "Artillery" "Battleship" "Antiair"}))))
                                ("GroundCounterAttackCheck" (last To) by:Enemy (last From) by:Mover {"Bomber" "Battleship" "Artillery" "Launcher"})
                                ("AircraftCounterAttackCheck" (last To) by:Enemy (last From) by:Mover {"Antiair" "Fighter"})
                                ("BoatCounterAttackCheck" (last To) by:Enemy (last From) by:Mover {"Submarine"})
                            })
                            (if (<= (- (value Piece at:(last From)) ("AttackerDamage" (last To) (last From) True)) 0)							
                                (remove (last From))
                                (set Value at:(last From) (- (value Piece at:(last From)) ("AttackerDamage" (last To) (last From) True)))			
                            ) 
                            (set Value at:(last From) (value Piece at:(last From)))
                        )
                    ) 
                )
            )
        )
    )
)

//------------------------------------------------------------------------------
// Attacker Damage

// #1 location of the attacking piece
// #2 site that is being attacked (terrain purposes)
// #3 location of the piece being attacked
// #4 If this is a counter Attack (boolean)
(define "AttackerDamage"
    (/
        (*
            (if (is In (#2) "AircraftSites")
                ("DamageMultiply" (* (value Piece at:(#1)) 4) #1)									// Planes are never affected by terrain									
                (if (and
                        (is In (#2) "HumanSites")
                        (is In (#1) (sites Occupied by:All component:"Shooter"))					// Shooter does double damage against humans
                    )
                    (if (is In (#2) (sites "Forest"))
                        ("DamageMultiply" (* (value Piece at:(#1)) 6) #1)							// (Shooter does 150% damage against humans in forests)
                        (if (is In (#2) (union (sites "ShallowWater") (sites "DeepWater")))
                            ("DamageMultiply" (* (value Piece at:(#1)) 10) #1)						// (Shooter does 250% damage against humans in water)
                            ("DamageMultiply" (* (value Piece at:(#1)) 8) #1)						// (Shooter does 200% damage against humans on land)
                        )
                    )
                    (if (is In (#2) (sites "Forest"))
                        ("DamageMultiply" (* (value Piece at:(#1)) 3) #1)							// 75% damage to units in forests
                        (if (is In (#2) (union (sites "ShallowWater") (sites "DeepWater")))
                            ("DamageMultiply" (* (value Piece at:(#1)) 5) #1)						// 125% damage to units in water
                            ("DamageMultiply" (* (value Piece at:(#1)) 4) #1)						// 100% damage to units on land
                        )
                    )
                )
            )
            ("DoctrineMultiply" #1 #2 #3) 
        ) 
        128000				// (4x4x4x5x100x4)
    )
)

(define "DamageMultiply"
    (max (/ (* #1 (mapEntry "DamageMultiplier" (what at:(#2)))) 100) 1)
)

//------------------------------------------------------------------------------
// Specific attacks

(define "AttackBuilding"
    (if (= (value Piece at:(last To)) 0)
        (and {
            (take Control of:All by:Mover at:(last To))
            (set Value at:(last To) 50)
        })
        (set Value at:(last To) (value Piece at:(last To)))
    ) 
)

(define "CloseCombatAttack"
    ("AttackMove" 1 1)
)

(define "RangedAttack"
    ("AttackMove" #1 #2)
)

//------------------------------------------------------------------------------
// Doctrine damage

// #1 location of the attacking piece
// #2 location of the piece being attacked
// #3 If this is a counter Attack (boolean)
(define "DoctrineMultiply"
    (* {
        (if (is In (#1) "HumanSites") 
            ("GetDoctrineValue" (who at:(#1)) 1) 
            (if (is In (#1) "DirectVehicleSites") 
                ("GetDoctrineValue" (who at:(#1)) 2) 
                (if (is In (#1) "RangedVehicleSites") 
                    ("GetDoctrineValue" (who at:(#1)) 3) 
                    (if (is In (#1) "AircraftSites") 
                        ("GetDoctrineValue" (who at:(#1)) 4) 
                        (if (is In (#1) "BoatSites") 
                            ("GetDoctrineValue" (who at:(#1)) 5) 
                            4
                        )
                    )
                )
            )
        )
        (if (and (= 8 (state at:(#2))) (!= (mover) (who at:(#2)))) 			// state = 8, means it's a building
            ("GetDoctrineValue" (who at:(#1)) 6) 5 
        )
        (if (> (who at:(#2)) 0) ("GetDoctrineValue" (who at:(#2)) 8) 4)
        (if #3 ("GetDoctrineValue" (who at:(#1)) 10) ("GetDoctrineValue" (who at:(#1)) 9))
        (value Random (range ("GetDoctrineValue" (who at:(#1)) 11) ("GetDoctrineValue" (who at:(#1)) 12)))
    })
)

//------------------------------------------------------------------------------
// Healing

(define "HealMoveBuilding"
    (move Select
        (from
            (from)
            if:(and
                (> (state at:(from)) 0)
                (< (value Piece at:(from)) (mapEntry "MaxHealth" (what at:(from))))
            )
        )
        (to 
            (sites Around (from) Orthogonal
                if:(is In (to) "MoverBuildingSites") 		
            )
        )
        (then 
            (and {
                (set Value at:(last From) 
                    (min 
                        (mapEntry "MaxHealth" (what at:(last From))) 
                        (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1)
                    )
                )
                (set Value at:(last To) 
                    (max 
                        (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From))))
                        1
                    )
                )
                (set State at:(last From) 0)
            })
        )
    )
)

(define "HealMoveUnit"
    (move Select
        (from
            (from)
            if:(> (state at:(from)) 0)
        )
        (to 
            (sites Around (from) Orthogonal
                if:(and
                    (= (what at:(from)) (what at:(to)))
                    (< (value Piece at:(to)) (mapEntry "MaxHealth" (what at:(to))))
                )		
            )
        )
        (then 
            (and {
                (if (<= (+ (value Piece at:(last To)) (value Piece at:(last From))) (mapEntry "MaxHealth" (what at:(last From))))
                    (and
                        (set Value at:(last To) 
                            (min 
                                (mapEntry "MaxHealth" (what at:(last From))) 
                                (+ (value Piece at:(last From)) (value Piece at:(last To)))
                            )
                        )
                        (remove (last From))
                    )
                    (and
                        (set Value at:(last To) 
                            (min 
                                (mapEntry "MaxHealth" (what at:(last From))) 
                                (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1)
                            )
                        )
                        (set Value at:(last From) 
                            (max 
                                (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From))))
                                1
                            )
                        )
                    )
                )
                (set State at:(last From) 0)
                (set State at:(last To) 0)
            })
        )
    )
)

//------------------------------------------------------------------------------
// Buying units

(define "BuyMove"
    (forEach Site (sites Occupied by:Neutral container:1 #1)
        (move 
            (from (site)) 
            (to 
                #2
                if:(and 
                    (is Empty (to))
                    (<= (/ (* (count at:(site)) ("GetDoctrineValue" (mover) 7)) 4) (score Mover))
                )
            )
            copy:True
            (then 
                (and {
                    (addScore 
                        Mover 
                        (- (/ (* (count at:(last From)) ("GetDoctrineValue" (mover) 7)) 4))
                    )	
                    (take Control of:All by:Mover at:(last To))
                    (set State at:(last To) 0)
                })
            )
        )
    )
)

(define "BuyHumanMove" 
    ("BuyMove" components:{"Soldier" "Motorbike"} 
        (difference 
            (sites Around (sites Occupied by:Mover component:"Town") Orthogonal)
            "ForbiddenSpotsHuman"
        )
    )
)

(define "BuyVehicleMove" 
    ("BuyMove" components:{"Speeder" "Shooter" "Tank" "Antiair" "Launcher" "Artillery"} 
        (difference 
            (sites Around (sites Occupied by:Mover component:"Factory") Orthogonal)
            "ForbiddenSpotsVehicle"
        )
    )
)

(define "BuyAircraftMove" 
    ("BuyMove" components:{"Helicopter" "Fighter" "Bomber"} 
        (sites Around (sites Occupied by:Mover component:"Airport") Orthogonal)
    )
)

(define "BuyBoatMove" 
    ("BuyMove" components:{"Cruiser" "Submarine" "Battleship"} 
        (difference 
            (sites Around (sites Occupied by:Mover component:"Dock") Orthogonal)
            "ForbiddenSpotsBoat"
        )
    )
)

//------------------------------------------------------------------------------
// Sites

(define "MoverBuildingSites"
    (sites Occupied by:Mover container:"Board" components:{"Town" "Dock" "Base" "Factory" "Airport"})
)

(define "EnemyBuildingSites"
    (union (sites Occupied by:Enemy container:"Board" components:{"Town" "Dock" "Base" "Factory" "Airport"}) (sites Occupied by:Neutral container:"Board" components:{"Town" "Dock" "Base" "Factory" "Airport"}))
)

(define "AircraftSites"
    (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})
)

(define "RangedUnitSites"
    (sites Occupied by:All container:"Board" components:{"Launcher" "Artillery" "Battleship" "Antiair"})
)

(define "HumanSites"
    (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})
)

(define "BoatSites"
    (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})
)

(define "DirectVehicleSites"
    (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})
)

(define "RangedVehicleSites"
    (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})
)

//------------------------------------------------------------------------------\
// Player removal

(define "RemovePiecesIfPlayerHasLost" 
    (if 
        (and {
            (is Active #1) 
            (> (count Active) 2)
            ("IsOffBoard" (where "Base" #1))
        }) 
        (forEach Site (sites Occupied by:#1)
            (if (is In (site) (sites Occupied by:#1 components:{"Town" "Base" "Factory" "Dock" "Airport"}))
                (take Control of:All by:Neutral at:(site))
                (remove (site))
            )
        )
    )
)

//------------------------------------------------------------------------------
// Player doctrines

// 1 = Human Damage
// 2 = Direct Vehicle Damage
// 3 = Indirect Vehicle Damage
// 4 = Aircraft Damage
// 5 = Boat Damage
// 6 = Building Damage (against)
// 7 = Cost Multiplier
// 8 = Damage Taken Multiplier
// 9 = First Attack Multiplier
// 10 = Counter Attack Multiplier
// 11 = Random Damage Minimum
// 12 = Random Damage Maximum

(define "GetDoctrineValue"
    (if (= #1 1)
        (mapEntry <Doctrine1:doctrine> #2)
        (if (= #1 2)
            (mapEntry <Doctrine2:doctrine> #2)
            (if (= #1 3)
                (mapEntry <Doctrine3:doctrine> #2)
                (if (= #1 4)
                    (mapEntry <Doctrine4:doctrine> #2)
                    0
                )
            )
        )
    )
)

//------------------------------------------------------------------------------
// Player maps

(define "TwoPlayerMaps"
    // state (movement)
    (map "Movement" { 
        (pair 1 8) (pair 2 8) (pair 3 8) (pair 4 8) (pair 5 8) (pair 6 8) (pair 7 8) (pair 8 8) (pair 9 8) (pair 10 8) 
        (pair 11 4) (pair 12 4) (pair 13 6) (pair 14 6) 
        (pair 15 7) (pair 16 7) (pair 17 5) (pair 18 5) (pair 19 5) (pair 20 5)
        (pair 21 5) (pair 22 5) (pair 23 4) (pair 24 4) (pair 25 4) (pair 26 4)
        (pair 27 5) (pair 28 5) (pair 29 7) (pair 30 7) (pair 31 6) (pair 32 6)
        (pair 33 6) (pair 34 6) (pair 35 6) (pair 36 6) (pair 37 5) (pair 38 5)
        (pair 39 8) (pair 40 8) (pair 41 8) (pair 42 8) (pair 43 8) 
    })
    
    // value (health)
    (map "MaxHealth" { 
        (pair 1 100) (pair 2 100) (pair 3 100) (pair 4 100) (pair 5 100) (pair 6 100) (pair 7 100) (pair 8 100) (pair 9 100) (pair 10 100) 
        (pair 11 30) (pair 12 30) (pair 13 40) (pair 14 40) 
        (pair 15 60) (pair 16 60) (pair 17 60) (pair 18 60) (pair 19 80) (pair 20 80)
        (pair 21 50) (pair 22 50) (pair 23 50) (pair 24 50) (pair 25 40) (pair 26 40)
        (pair 27 40) (pair 28 40) (pair 29 100) (pair 30 100) (pair 31 100) (pair 32 100)
        (pair 33 70) (pair 34 70) (pair 35 100) (pair 36 100) (pair 37 120) (pair 38 120)
        (pair 39 100) (pair 40 100) (pair 41 100) (pair 42 100) (pair 43 100)
    })
    
    (map "DamageMultiplier" { 
        (pair 1 0) (pair 2 0) (pair 3 0) (pair 4 0) (pair 5 0) (pair 6 0) (pair 7 0) (pair 8 0) (pair 9 0) (pair 10 0) 
        (pair 11 50) (pair 12 50) (pair 13 50) (pair 14 50) 
        (pair 15 40) (pair 16 40) (pair 17 40) (pair 18 40) (pair 19 50) (pair 20 50)
        (pair 21 100) (pair 22 100) (pair 23 50) (pair 24 50) (pair 25 100) (pair 26 100)
        (pair 27 70) (pair 28 70) (pair 29 100) (pair 30 100) (pair 31 80) (pair 32 80)
        (pair 33 50) (pair 34 50) (pair 35 80) (pair 36 80) (pair 37 50) (pair 38 50)
        (pair 39 0) (pair 40 0) (pair 41 0) (pair 42 0) (pair 43 0) 
    })
)

(define "FourPlayerMaps"
    // state (movement)
    (map "Movement" { 
        (pair 1 8) (pair 2 8) (pair 3 8) (pair 4 8) (pair 5 8) (pair 6 8) (pair 7 8) (pair 8 8) (pair 9 8) (pair 10 8) 
        (pair 11 8) (pair 12 8) (pair 13 8) (pair 14 8) (pair 15 8) (pair 16 8) (pair 17 8) (pair 18 8) (pair 19 8) (pair 20 8) 
        (pair 21 4) (pair 22 4) (pair 23 4) (pair 24 4) 
        (pair 25 6) (pair 26 6) (pair 27 6) (pair 28 6) 
        (pair 29 7) (pair 30 7) (pair 31 7) (pair 32 7) (pair 33 5) (pair 34 5) (pair 35 5) (pair 36 5)
        (pair 37 5) (pair 38 5) (pair 39 5) (pair 40 5)
        (pair 41 5) (pair 42 5) (pair 43 5) (pair 44 5) (pair 45 4) (pair 46 4)
        (pair 47 4) (pair 48 4) (pair 49 4) (pair 50 4) (pair 51 4) (pair 52 4)
        (pair 53 5) (pair 54 5) (pair 55 5) (pair 56 5) (pair 57 7) (pair 58 7)
        (pair 59 7) (pair 60 7) (pair 61 6) (pair 62 6) (pair 63 6) (pair 64 6)
        (pair 65 6) (pair 66 6) (pair 67 6) (pair 68 6) (pair 69 6) (pair 70 6)
        (pair 71 6) (pair 72 6) (pair 73 5) (pair 74 5) (pair 75 5) (pair 76 5)
        (pair 77 8) (pair 78 8) (pair 79 8) (pair 80 8) (pair 81 8)
    })
    
    // value (health)
    (map "MaxHealth" { 
        (pair 1 100) (pair 2 100) (pair 3 100) (pair 4 100) (pair 5 100) (pair 6 100) (pair 7 100) (pair 8 100) (pair 9 100) (pair 10 100)
        (pair 11 100) (pair 12 100) (pair 13 100) (pair 14 100) (pair 15 100) (pair 16 100) (pair 17 100) (pair 18 100) (pair 19 100) (pair 20 100)
        (pair 21 30) (pair 22 30) (pair 23 30) (pair 24 30)
        (pair 25 40) (pair 26 40) (pair 27 40) (pair 28 40)
        (pair 29 60) (pair 30 60) (pair 31 60) (pair 32 60) (pair 33 60) (pair 34 60) (pair 35 60) (pair 36 60)
        (pair 37 80) (pair 38 80) (pair 39 80) (pair 40 80)
        (pair 41 50) (pair 42 50) (pair 43 50) (pair 44 50) (pair 45 50) (pair 46 50)
        (pair 47 50) (pair 48 50) (pair 49 40) (pair 50 40) (pair 51 40) (pair 52 40)
        (pair 53 40) (pair 54 40) (pair 55 40) (pair 56 40) (pair 57 100) (pair 58 100)
        (pair 59 100) (pair 60 100) (pair 61 100) (pair 62 100) (pair 63 100) (pair 64 100)
        (pair 65 70) (pair 66 70) (pair 67 70) (pair 68 70) (pair 69 100) (pair 70 100)
        (pair 71 100) (pair 72 100) (pair 73 120) (pair 74 120) (pair 75 120) (pair 76 120)
        (pair 77 100) (pair 78 100) (pair 79 100) (pair 80 100) (pair 81 100)
    })
    
    (map "DamageMultiplier" { 
        (pair 1 0) (pair 2 0) (pair 3 0) (pair 4 0) (pair 5 0) (pair 6 0) (pair 7 0) (pair 8 0) (pair 9 0) (pair 10 0)
        (pair 11 0) (pair 12 0) (pair 13 0) (pair 14 0) (pair 15 0) (pair 16 0) (pair 17 0) (pair 18 0) (pair 19 0) (pair 20 0)
        (pair 21 50) (pair 22 50) (pair 23 50) (pair 24 50)
        (pair 25 50) (pair 26 50) (pair 27 50) (pair 28 50)
        (pair 29 40) (pair 30 40) (pair 31 40) (pair 32 40) (pair 33 40) (pair 34 40) (pair 35 40) (pair 36 40)
        (pair 37 50) (pair 38 50) (pair 39 50) (pair 40 50)
        (pair 41 100) (pair 42 100) (pair 43 100) (pair 44 100) (pair 45 50) (pair 46 50)
        (pair 47 50) (pair 48 50) (pair 49 100) (pair 50 100) (pair 51 100) (pair 52 100)
        (pair 53 70) (pair 54 70) (pair 55 70) (pair 56 70) (pair 57 100) (pair 58 100)
        (pair 59 100) (pair 60 100) (pair 61 80) (pair 62 80) (pair 63 80) (pair 64 80)
        (pair 65 50) (pair 66 50) (pair 67 50) (pair 68 50) (pair 69 80) (pair 70 80)
        (pair 71 80) (pair 72 80) (pair 73 50) (pair 74 50) (pair 75 50) (pair 76 50)
        (pair 77 0) (pair 78 0) (pair 79 0) (pair 80 0) (pair 81 0)
    })
)

//------------------------------------------------------------------------------
// Doctrines

(define "DoctrineSetup"
    (map "NoDoctrine" { 
        (pair 1 4) (pair 2 4) (pair 3 4) (pair 4 4) (pair 5 4) (pair 6 5) 
        (pair 7 4) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)
    })
    
    (map "SpecialForces" { 
        (pair 1 6) (pair 2 3) (pair 3 3) (pair 4 3) (pair 5 3) (pair 6 5) 
        (pair 7 4) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)
    })
    
    (map "BruteStrength" { 
        (pair 1 3) (pair 2 6) (pair 3 3) (pair 4 3) (pair 5 3) (pair 6 5) 
        (pair 7 4) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)
    })
    
    (map "Sharpshooter" { 
        (pair 1 3) (pair 2 3) (pair 3 6) (pair 4 3) (pair 5 3) (pair 6 5) 
        (pair 7 4) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)
    })
    
    (map "AcePilot" { 
        (pair 1 3) (pair 2 3) (pair 3 3) (pair 4 6) (pair 5 3) (pair 6 5) 
        (pair 7 4) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)
    })
    
    (map "SeaDog" { 
        (pair 1 3) (pair 2 3) (pair 3 3) (pair 4 3) (pair 5 6) (pair 6 5) 
        (pair 7 4) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)
    })
    
    (map "GuerrillaWarfare" { 
        (pair 1 3) (pair 2 3) (pair 3 3) (pair 4 3) (pair 5 3) (pair 6 10) 
        (pair 7 4) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)
    })
    
    (map "ForeignInvader" { 
        (pair 1 5) (pair 2 5) (pair 3 5) (pair 4 5) (pair 5 5) (pair 6 2) 
        (pair 7 4) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)
    })
    
    (map "Conscription" { 
        (pair 1 2) (pair 2 2) (pair 3 2) (pair 4 2) (pair 5 2) (pair 6 5) 
        (pair 7 2) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)
    })
    
    (map "EliteTraining" { 
        (pair 1 6) (pair 2 6) (pair 3 6) (pair 4 6) (pair 5 6) (pair 6 5) 
        (pair 7 6) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)
    })
    
    (map "GlassCannon" { 
        (pair 1 6) (pair 2 6) (pair 3 6) (pair 4 6) (pair 5 6) (pair 6 5) 
        (pair 7 4) (pair 8 6) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)
    })
    
    (map "HardenedResolve" { 
        (pair 1 2) (pair 2 2) (pair 3 2) (pair 4 2) (pair 5 2) (pair 6 5) 
        (pair 7 4) (pair 8 2) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)
    })
    
    (map "PreemptiveStrike" { 
        (pair 1 4) (pair 2 4) (pair 3 4) (pair 4 4) (pair 5 4) (pair 6 5) 
        (pair 7 4) (pair 8 4) (pair 9 6) (pair 10 0) (pair 11 100) (pair 12 100)
    })
    
    (map "Retaliation" { 
        (pair 1 4) (pair 2 4) (pair 3 4) (pair 4 4) (pair 5 4) (pair 6 5) 
        (pair 7 4) (pair 8 4) (pair 9 2) (pair 10 8) (pair 11 100) (pair 12 100)
    })
    
    (map "LadyLuck" { 
        (pair 1 4) (pair 2 4) (pair 3 4) (pair 4 4) (pair 5 4) (pair 6 5) 
        (pair 7 4) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 50) (pair 12 150)
    })
    
)

//------------------------------------------------------------------------------
// Fog Of War

(define "ClearSites"
    (difference (sites Board) "HiddenSites")
)

(define "HiddenSites"
    (union {(sites "Forest") (sites "Mountain")})
)

(define "VisibilityRangeSites"
    (union {
        (intersection (expand (forEach (players Friend of:(player)) (sites Occupied by:Player container:"Board")) steps:2) "ClearSites")
        (intersection (expand (forEach (players Friend of:(player)) (sites Occupied by:Player container:"Board")) steps:1) "HiddenSites")
        (intersection (expand (intersection (forEach (players Friend of:(player)) (sites Occupied by:Player container:"Board" components:{"Soldier" "Motorbike"})) (sites "Mountain")) steps:3) "ClearSites")
        (intersection (expand (forEach (players Friend of:(player)) (sites Occupied by:Player container:"Board" components:{"Bomber" "Fighter" "Helicopter"})) steps:3) "ClearSites")
        (intersection (expand (intersection (forEach (players Friend of:(player)) (sites Occupied by:Player container:"Board" components:{"Submarine" "Battleship" "Cruiser"})) (sites "Mountain")) steps:3) (union {(sites "DeepWater") (sites "ShallowWater")}))
    })
)

(define "HideSites"
    (forEach Site (intersection (difference (sites Board) ("VisibilityRangeSites")) (difference (sites Board) (sites Hidden What to:#1)))
        (set Hidden {What State Value} at:(site) True to:#1)
    )
)

(define "ShowSites"
    (forEach Site (intersection ("VisibilityRangeSites") (sites Hidden What to:#1))
        (set Hidden {What State Value} at:(site) False to:#1)
    )
)

(define "FogOfWarEachMove"
    (forEach Team (forEach (team) ("HideSites" Player)))
    (forEach Team (forEach (team) ("ShowSites" Player)))
)

(define "FogOfWarAttackCheck"
    (not (is In (to) (sites Hidden What to:Mover)))
)

(define "FogOfWarMetadata"
    (region Colour (intersection (sites Board) (sites Hidden What to:Mover)) (colour 104 120 96))
    (region Colour (intersection (sites "Forest") (sites Hidden What to:Mover)) (colour 0 50 0))
    (region Colour (intersection (sites "ShallowWater") (sites Hidden What to:Mover)) (colour 87 108 115))
    (region Colour (intersection (sites "DeepWater") (sites Hidden What to:Mover)) (colour 14 49 108))
    (region Colour (intersection (sites "Mountain") (sites Hidden What to:Mover)) (colour 97 77 59))
    (region Colour (intersection (sites Occupied by:All container:"Board" components:{"Town" "Dock" "Base" "Factory" "Airport"}) (sites Hidden What to:Mover)) (colour 75 75 75))
)

//------------------------------------------------------------------------------

(game "Mini Wars" 
    (players <Scenario:numPlayers>) 
    (equipment { 
        (board <Scenario:boardShape>)
        
        <Scenario:boardRegins>
        
        (hand Shared size:14)
        
        (piece "Base" Each)
        (piece "Factory" Each)
        (piece "Town" Each)
        (piece "Airport" Each)
        (piece "Dock" Each)
        
        (piece "Soldier" Each (or {"HumanMove" "CloseCombatAttack" "HealMoveBuilding" "HealMoveUnit"}))
        (piece "Motorbike" Each (or {"HumanMove" "CloseCombatAttack" "HealMoveBuilding" "HealMoveUnit"}))
        
        (piece "Speeder" Each (or {("VehicleMove" 1) "CloseCombatAttack" "HealMoveBuilding" "HealMoveUnit"}))
        (piece "Shooter" Each (or {("VehicleMove" 1) "CloseCombatAttack" "HealMoveBuilding" "HealMoveUnit"}))
        (piece "Tank" Each (or {("VehicleMove" 1) "CloseCombatAttack" "HealMoveBuilding" "HealMoveUnit"}))
        
        (piece "Antiair" Each (or {("VehicleMove" 1) ("RangedAttack" 1 2) "HealMoveBuilding" "HealMoveUnit"}))
        (piece "Launcher" Each (or {("VehicleMove" 1) ("RangedAttack" 2 3) "HealMoveBuilding" "HealMoveUnit"}))
        (piece "Artillery" Each (or {("VehicleMove" 0) ("RangedAttack" 3 5) "HealMoveBuilding" "HealMoveUnit"}))
        
        (piece "Helicopter" Each (or {"AircraftMove" "CloseCombatAttack" "HealMoveBuilding" "HealMoveUnit"}))
        (piece "Fighter" Each (or {"AircraftMove" "CloseCombatAttack" "HealMoveBuilding" "HealMoveUnit"}))
        (piece "Bomber" Each (or {"AircraftMove" "CloseCombatAttack" "HealMoveBuilding" "HealMoveUnit"}))
        
        (piece "Cruiser" Each (or {"BoatMove" "CloseCombatAttack" "HealMoveBuilding" "HealMoveUnit"}))
        (piece "Submarine" Each (or {"BoatMove" "CloseCombatAttack" "HealMoveBuilding" "HealMoveUnit"}))
        (piece "Battleship" Each (or {"BoatMove" ("RangedAttack" 2 4) "HealMoveBuilding" "HealMoveUnit"}))
        
        (piece "Base" Neutral) 
        (piece "Factory" Neutral)
        (piece "Town" Neutral)
        (piece "Airport" Neutral)
        (piece "Dock" Neutral)
        
        (piece "Soldier" Neutral)
        (piece "Motorbike" Neutral)
        
        (piece "Speeder" Neutral)
        (piece "Shooter" Neutral)
        (piece "Tank" Neutral)
        
        (piece "Antiair" Neutral)
        (piece "Launcher" Neutral)
        (piece "Artillery" Neutral)
        
        (piece "Helicopter" Neutral)
        (piece "Fighter" Neutral)
        (piece "Bomber" Neutral)
        
        (piece "Cruiser" Neutral)
        (piece "Submarine" Neutral)
        (piece "Battleship" Neutral)
        
        <Scenario:playerMaps>
        
        "DoctrineSetup"
    }) 
    (rules 
        (meta (passEnd NoEnd))
        (start {  
            <Scenario:buildingSetup>
            <Scenario:pieceSetup>
            <Scenario:teams>
            (set Score Each <Scenario:startingMoney>)
            
            (place "Soldier0" (handSite Shared 0) count:30 state:1 value:30)
            (place "Motorbike0" (handSite Shared 1) count:50 state:1 value:40)
            
            (place "Speeder0" (handSite Shared 2) count:60 state:1 value:60)
            (place "Shooter0" (handSite Shared 3) count:80 state:1 value:60)
            (place "Tank0" (handSite Shared 4) count:100 state:1 value:80)
            
            (place "Antiair0" (handSite Shared 5) count:80 state:1 value:50)
            (place "Launcher0" (handSite Shared 6) count:80 state:1 value:50)
            (place "Artillery0" (handSite Shared 7) count:100 state:1 value:40)
            
            (place "Helicopter0" (handSite Shared 8) count:60 state:1 value:40)
            (place "Fighter0" (handSite Shared 9) count:100 state:1 value:100)
            (place "Bomber0" (handSite Shared 10) count:120 state:1 value:100)
            
            (place "Cruiser0" (handSite Shared 11) count:60 state:1 value:70)
            (place "Submarine0" (handSite Shared 12) count:100 state:1 value:100) 
            (place "Battleship0" (handSite Shared 13) count:120 state:1 value:120) 
            
            <FogOfWar:EachMove>
        })
        
        (play 
            (or 
                (or { 
                    (forEach Piece)
                    ("BuyHumanMove")
                    ("BuyBoatMove") 
                    ("BuyAircraftMove") 
                    ("BuyVehicleMove") 
                    }
                    (then 
                        (and {
                            (forEach Player
                                ("RemovePiecesIfPlayerHasLost" Player)
                            )
                            (moveAgain)
                            (and {<FogOfWar:EachMove>})
                        })
                    )
                )
                (move Pass
                    (then
                        (and {
                            (forEach Site (sites Occupied by:Mover container:"Board")
                                (set State at:(site) (mapEntry "Movement" (what at:(site))))
                            )
                            (set Score 
                                Mover
                                (+ {
                                    (* (count Sites in:(sites Occupied by:Mover component:"Base")) 20) 
                                    (* (count Sites in:(sites Occupied by:Mover component:"Town")) 10) 
                                    (score Mover) 
                                })
                            )
                            (forEach Site (sites Occupied by:Mover components:{"Town" "Base" "Factory" "Dock" "Airport"})
                                (set Value at:(site) (min (mapEntry "MaxHealth" (what at:(site))) (+ (value Piece at:(site)) 10)))
                            )
                            (and {<FogOfWar:EachMove>})
                        })
                    )
                )
            )
        )
        
        (end 
            (forEach NonMover 
                if:("IsOffBoard" (where "Base" Player)) (result Player Loss)
            )
        )
    )
)

//------------------------------------------------------------------------------

(option "Scenario" <Scenario> args:{<playerMaps> <numPlayers> <boardShape> <boardRegins> <buildingSetup> <pieceSetup> <startingMoney> <teams> <pieceFlip> <terrainScale>}
    {
    
    (item "First Encounter (2-player, hexagon)"
        <
        "TwoPlayerMaps"
        >
        <
        2
        >
        <
        (hex 5)
        >
        <
        (regions "ShallowWater" (sites {"A3" "B3" "C3" "C1"})) 
        (regions "DeepWater" (sites {"A1" "A2" "B2" "B1"})) 
        (regions "Forest" (sites {"I9" "H9" "G9" "A4" "A5" "D1" "E1" "E7" "D2" "E2"})) 
        (regions "Mountain" (sites {"I8" "H7" "G7" "F6"})) 
        > 
        <
        (place "Base1" (sites {"C7"}) state:8 value:100) 
        (place "Base2" (sites {"G3"}) state:8 value:100)
        (place "Airport0" (sites {"H8"}) state:8 value:100)
        (place "Dock0" (sites {"C2"}) state:8 value:100)
        (place "Town2" (sites {"I5" "I6"}) state:8 value:100)
        (place "Town1" (sites {"E9" "F9"}) state:8 value:100)
        (place "Factory0" (sites {"C5" "F4"}) state:8 value:100)
        >  
        <
        
        >  
        <
        100
        >     
        <
        (set Team 1 {P1})
        (set Team 2 {P2})
        >  
        
        <
        (piece ExtendName P2 "Flip")
        >
        <
        (show Symbol "forest" (sites "Forest") scale:0.8)
        (show Symbol "waves" (sites "ShallowWater") scale:0.9)
        (show Symbol "waves" (sites "DeepWater") scale:0.9)
        (show Symbol "mountain" (sites "Mountain") scale:0.9)
        >
        "Scenario - First Encounter"
    )**
    
    (item "Battle Royale (4-player, 4-teams, hexagon)"
        <
        "FourPlayerMaps"
        >
        <
        4
        >
        <
        (hex 8)
        >
        <
        (regions "ShallowWater" (sites {"G6" "G5" "G4" "F3" "E2" "E1" "D2" "C2" "B1"})) 
        (regions "DeepWater" (sites {"I10" "H10" "I11" "H11" "I12" "J12" "K13" "J13" "K14" "J14"})) 
        (regions "Forest" (sites {"A8" "B9" "C9" "B8" "A7" "D8" "D9" "C8" "B7" "C7" "G9" "F8" "F7" "H6" "I7" "I6" "J7" "K8" "L8" "M9" "A1" "B2" "A2" "A3" "O15" "N14" "O14" "N15" "C1" "D1" "F1" "G1" "H1" "D7" "F9"})) 
        (regions "Mountain" (sites {"H8" "G7" "G8" "H9" "I9" "I8" "H7" "L15" "K15" "J15" "O10" "O9" "N8" "O8" "N7" "M6" "L5" "N9" "J9" "J8" "I15"})) 
        > 
        <
        (place "Base1" (sites {"C5"}) state:8 value:100) 
        (place "Base2" (sites {"M11"}) state:8 value:100)
        (place "Base3" (sites {"J5"}) state:8 value:100) 
        (place "Base4" (sites {"G12"}) state:8 value:100)
        (place "Airport0" (sites {"F4" "K11"}) state:8 value:100)
        (place "Dock0" (sites {"F2" "I13"}) state:8 value:100)
        (place "Town1" (sites {"A5" "A4" "A6"}) state:8 value:100)
        (place "Town2" (sites {"O12" "O13" "O11"}) state:8 value:100)
        (place "Town3" (sites {"J3" "K4" "I2"}) state:8 value:100)
        (place "Town4" (sites {"G14" "F13" "H15"}) state:8 value:100)
        (place "Town0" (sites {"F6" "G10" "K9" "M7" "D4" "C10" "M15" "K7"}) state:8 value:100)
        (place "Factory0" (sites {"B3" "E11" "M13" "H3"}) state:8 value:100)
        >  
        <
        
        >  
        <
        100
        >     
        <
        (set Team 1 {P1})
        (set Team 2 {P2})
        (set Team 3 {P3})
        (set Team 4 {P4})
        >  
        
        <
        (piece ExtendName P2 "Flip")
        (piece ExtendName P3 "Flip")
        >
        <
        (show Symbol "forest" (sites "Forest") scale:0.8)
        (show Symbol "waves" (sites "ShallowWater") scale:0.9)
        (show Symbol "waves" (sites "DeepWater") scale:0.9)
        (show Symbol "mountain" (sites "Mountain") scale:0.9)
        >
        "Scenario - Battle Royale"
    )
    
    (item "Open Plains (2-player, hexagon)"
        <
        "TwoPlayerMaps"
        >
        <
        2
        >
        <
        (hex 7)
        >
        <
        (regions "ShallowWater" (sites {"B1" "C2" "D3" "E4" "F4" "F3" "F2" "F1"})) 
        (regions "DeepWater" (sites {"D1" "C1" "E1" "E2" "D2" "E3"})) 
        (regions "Forest" (sites {"H13" "H12" "H11" "H10" "I10" "J11" "K12" "L13"})) 
        (regions "Mountain" (sites {"I11" "I12" "J12" "J13" "I13" "K13"})) 
        > 
        <
        (place "Town1" (sites {"A2" "F12"}) state:8 value:100) 
        (place "Town2" (sites {"M12" "H2"}) state:8 value:100)
        (place "Town0" (sites {"E5" "G5" "G9" "I9" "D7" "J7"}) state:8 value:100)
        (place "Factory1" (sites {"A4" "D10"}) state:8 value:100) 
        (place "Factory2" (sites {"J4" "M10"}) state:8 value:100)
        (place "Airport0" (sites {"K11" "G11"}) state:8 value:100)
        (place "Dock0" (sites {"C3" "G3"}) state:8 value:100) 
        (place "Base1" (sites {"A7"}) state:8 value:100) 
        (place "Base2" (sites {"M7"}) state:8 value:100)
        >  
        <
        
        >  
        <
        100
        >     
        <
        (set Team 1 {P1})
        (set Team 2 {P2})
        >
        <
        (piece ExtendName P2 "Flip")
        >
        <
        (show Symbol "forest" (sites "Forest") scale:0.8)
        (show Symbol "waves" (sites "ShallowWater") scale:0.9)
        (show Symbol "waves" (sites "DeepWater") scale:0.9)
        (show Symbol "mountain" (sites "Mountain") scale:0.9)
        >
        "Scenario - Open Plains"
    )
    
    (item "Close Quarters (2-player, hexagon)"
        <
        "TwoPlayerMaps"
        >
        <
        2
        >
        <
        (remove
            (hex Rectangle 5 9)
            cells:{0 8 34 42}
        )
        >
        <
        (regions "ShallowWater" (sites {})) 
        (regions "DeepWater" (sites {})) 
        (regions "Forest" (sites {})) 
        (regions "Mountain" (sites {})) 
        > 
        <
        (place "Town1" (sites {"E5" "A1" "C5" "C1"}) state:8 value:100) 
        (place "Town2" (sites {"G1" "G5" "I5" "E1"}) state:8 value:100)
        (place "Factory0" (sites {"E3"}) state:8 value:100) 
        (place "Factory1" (sites {"C3"}) state:8 value:100) 
        (place "Factory2" (sites {"G3"}) state:8 value:100)
        (place "Base1" (sites {"A3"}) state:8 value:100) 
        (place "Base2" (sites {"I3"}) state:8 value:100)
        >  
        <
        
        >  
        <
        100
        >     
        <
        (set Team 1 {P1})
        (set Team 2 {P2})
        >
        <
        (piece ExtendName P2 "Flip")
        >
        <
        (show Symbol "forest" (sites "Forest") scale:0.8)
        (show Symbol "waves" (sites "ShallowWater") scale:0.9)
        (show Symbol "waves" (sites "DeepWater") scale:0.9)
        (show Symbol "mountain" (sites "Mountain") scale:0.9)
        >
        "Scenario - Close Quarters"
    )
    
    (item "Diamond City (2-player, hexagon)"
        <
        "TwoPlayerMaps"
        >
        <
        2
        >
        <
        (hex Diamond 8)
        >
        <
        (regions "DeepWater" (sites {"A5" "B5" "B4" "A4" "B3" "A3" "B2" "A1" "B1" "A2"})) 
        (regions "Forest" (sites {"H8" "G8" "G7" "H7" "H6" "G6" "H5" "G5" "H4" "G4"})) 
        (regions "Mountain" (sites {"A8" "A7" "B8" "H1" "G1" "H2"})) 
        (regions "ShallowWater" (sites {})) 
        > 
        <
        (place "Town1" (sites {"C5" "F6"}) state:8 value:100) 
        (place "Town2" (sites {"C3" "F4"}) state:8 value:100)
        (place "Town0" (sites {"C4" "F5"}) state:8 value:100)
        (place "Factory1" (sites {"D7"}) state:8 value:100) 
        (place "Factory2" (sites {"E2"}) state:8 value:100)
        (place "Airport0" (sites {"F8"}) state:8 value:100)
        (place "Dock0" (sites {"C1"}) state:8 value:100) 
        (place "Base1" (sites {"C8"}) state:8 value:100) 
        (place "Base2" (sites {"F1"}) state:8 value:100)
        >  
        <
        
        >  
        <
        100
        >     
        <
        (set Team 1 {P1})
        (set Team 2 {P2})
        > 
        <
        (piece ExtendName P2 "Flip")
        >
        <
        (show Symbol "forest" (sites "Forest") scale:0.8)
        (show Symbol "waves" (sites "ShallowWater") scale:0.9)
        (show Symbol "waves" (sites "DeepWater") scale:0.9)
        (show Symbol "mountain" (sites "Mountain") scale:0.9)
        >
        "Scenario - Diamond City"
    )
    
    (item "River Crossing (2-player, hexagon)"
        <
        "TwoPlayerMaps"
        >
        <
        2
        >
        <
        (remove
            (hex Rectangle 9 15)
            cells:{0 1 15 29 116 117 102 87 130 129 115 101 43 28 13 14}
        )
        >
        <
        (regions "ShallowWater" (sites {"H5" "H4" "I4" "I5" "G5" "H6" "G6" "I6" "G4" })) 
        (regions "DeepWater" (sites {"L5" "D5" "E5" "F5" "J5" "K5" "K4" "L6" "E6" "D4" "E4" "F4" "J4" "K6" "J6" "F6"})) 
        (regions "Forest" (sites {"K7" "L7" "L8" "M8" "M9" "N9" "D3" "C2" "B1" "E3" "D2" "C1"})) 
        (regions "Mountain" (sites {"E9" "F9" "G9" "H9" "H1" "I1" "J1" "K1"})) 
        > 
        <
        (place "Town1" (sites {"A3" "A4" "A5" "B6" "C7" "C4" "D6"}) state:8 value:100) 
        (place "Town2" (sites {"O5" "O6" "O7" "N4" "M3" "M6" "L4"}) state:8 value:100)
        (place "Factory1" (sites {"K9"}) state:8 value:100) 
        (place "Factory2" (sites {"E1"}) state:8 value:100)
        (place "Dock1" (sites {"C5"}) state:8 value:100) 
        (place "Dock2" (sites {"M5"}) state:8 value:100)
        (place "Base1" (sites {"B2" "E8"}) state:8 value:100) 
        (place "Base2" (sites {"K2" "N8"}) state:8 value:100)
        (place "Airport0" (sites {"I9" "G1"}) state:8 value:100)
        >  
        <
        
        >  
        <
        100
        >     
        <
        (set Team 1 {P1})
        (set Team 2 {P2})
        > 
        <
        (piece ExtendName P2 "Flip")
        >
        <
        (show Symbol "forest" (sites "Forest") scale:0.8)
        (show Symbol "waves" (sites "ShallowWater") scale:0.9)
        (show Symbol "waves" (sites "DeepWater") scale:0.9)
        (show Symbol "mountain" (sites "Mountain") scale:0.9)
        >
        "Scenario - River Crossing"
    )
    
    (item "Fortress Siege (4-player, 2-teams, hexagon)"
        <
        "FourPlayerMaps"
        >
        <
        4
        >
        <
        (hex 10)
        >
        <
        (regions "ShallowWater" (sites {"M19" "M18" "M17" "M16" "M15" "M14" "M13"
        "D1" "E2" "F3" "G4" "H5" "I6" "J7"})) 
        (regions "DeepWater" (sites {"B1" "C2" "D3" "E4" "F5" "G6" "H7"
                "C1" "D2" "E3" "F4" "G5" "H6" "I7"
                "K19" "K18" "K17" "K16" "K15" "K14" "K13"
        "L19" "L18" "L17" "L16" "L15" "L14" "L13"})) 
        (regions "Forest" (sites {"H8" "I8" "J8" "K8" "J12" "K12" "L12" "M12" "C9" "D10" "D11"
        "C6" "B5" "G14" "G15" "B9" "C10" "C11"})) 
        (regions "Mountain" (sites {"A1" "B2" "C3" "D4" "E5" "F6" "G7" 
                "J19" "J18" "J17" "J16" "J15" "J14" "J13"
                "D7" "E8" "F9" "G10" "G11" "G12" "G13"
        "D13" "D12" "A7" "B8"}))
        > 
        <
        (place "Base1" (sites {"A10"}) state:8 value:100) 
        (place "Base2" (sites {"S15"}) state:8 value:100)
        (place "Base3" (sites {"S10"}) state:8 value:100) 
        (place "Base4" (sites {"N5"}) state:8 value:100)
        (place "Airport0" (sites {"S19" "J1"}) state:8 value:100)
        (place "Dock0" (sites {"G3" "N17"}) state:8 value:100)
        (place "Town1" (sites {"C12" "A8" "A5" "A4" "A3" "A2" "F15" "G16" "H17" "I18"}) state:8 value:100)
        (place "Town2" (sites {"Q15" "R17" "Q13"}) state:8 value:100)
        (place "Town3" (sites {"Q10" "R12" "P8"}) state:8 value:100)
        (place "Town4" (sites {"L5" "N7" "K3"}) state:8 value:100)
        (place "Factory1" (sites {"E14" "A6"}) state:8 value:100)
        (place "Town0" (sites {"J4" "P16" "M8" "O12" "N10" "I2" "G1" "Q18" "P19"}) state:8 value:100)
        (place "Factory0" (sites {"O9" "P11" "O14" "K6"}) state:8 value:100)
        >  
        <
        (place "Artillery1" (sites {"F10" "D8" "F12"}) state:3 value:40)
        (place "Antiair1" (sites {"F11" "E9"}) state:4 value:50)
        (place "Launcher1" (sites {"I13" "I15" "F7" "D5"}) state:3 value:50)
        (place "Tank1" (sites {"C4" "I16" "E6" "I14"}) state:4 value:80)
        >  
        <
        200
        >     
        <
        (set Team 1 {P1})
        (set Team 2 {P2 P3 P4})
        >
        <
        (piece ExtendName P2 "Flip")
        (piece ExtendName P3 "Flip")
        (piece ExtendName P4 "Flip")
        >
        <
        (show Symbol "forest" (sites "Forest") scale:0.8)
        (show Symbol "waves" (sites "ShallowWater") scale:0.9)
        (show Symbol "waves" (sites "DeepWater") scale:0.9)
        (show Symbol "mountain" (sites "Mountain") scale:0.9)
        >
        "Scenario - Fortress Siege"
    )
    
    (item "Canyon Pass (2-player, square)"
        <
        "TwoPlayerMaps"
        >
        <
        2
        >
        <
        (rectangle 8 14)
        >
        <
        (regions "Forest" (sites {"B3" "D1" "E1" "J1" "K1" "M3" "E8" "F8" "G8" "H8" "I8" "J8"})) 
        (regions "Mountain" (sites {"D3" "D4" "D5" "D6" "D7" "D8" "F1" "G1" "G2" "G3" "G4" "G5" "I1" "H1" "H2" "H3" "H4" "H5" "K3" "K4" "K5" "K6" "K7" "K8"})) 
        (regions "ShallowWater" (sites {})) 
        (regions "DeepWater" (sites {})) 
        > 
        <
        (place "Town1" (sites {"A1" "B1" "A7" "B7" "F2" "F4"}) state:8 value:100) 
        (place "Town2" (sites {"I2" "I4" "M1" "N1" "M7" "N7"}) state:8 value:100)
        (place "Town0" (sites {"E7" "F7" "G7" "H7" "I7" "J7"}) state:8 value:100)
        (place "Factory1" (sites {"A3" "C5" "A6"}) state:8 value:100) 
        (place "Factory2" (sites {"N3" "N6" "L5"}) state:8 value:100)
        (place "Base1" (sites {"A4"}) state:8 value:100) 
        (place "Base2" (sites {"N4"}) state:8 value:100)
        >  
        <
        
        >  
        <
        100
        >  
        <
        (set Team 1 {P1})
        (set Team 2 {P2})
        >  
        <
        (piece ExtendName P2 "Flip")
        >
        <
        (show Symbol "forest" (sites "Forest"))
        (show Symbol "waves" (sites "ShallowWater"))
        (show Symbol "waves" (sites "DeepWater"))
        (show Symbol "mountain" (sites "Mountain"))
        >   
        "Scenario - Canyon Pass"
    )
    
    (item "Gridlock (2-player, square)"
        <
        "TwoPlayerMaps"
        >
        <
        2
        >
        <
        (rectangle 9 14)
        >
        <
        (regions "ShallowWater" (sites {})) 
        (regions "DeepWater" (sites {})) 
        (regions "Forest" (sites {})) 
        (regions "Mountain" (sites {})) 
        > 
        <
        (place "Factory1" (sites {"B7" "C8"}) state:8 value:100) 
        (place "Factory2" (sites {"L2" "M3"}) state:8 value:100)
        (place "Factory0" (sites {"B2" "M8"}) state:8 value:100)
        (place "Town0" (sites {"B4" "B6" "C2" "C4" "C6" "D2" "D4" "D6" "D8" "E2" "E4" "E6" "E8" "J2" "J4" "J6" "J8" "K2" "K4" "K6" "K8"
        "L4" "L6" "L8" "M4" "M6" "G2" "G4" "G6" "G8" "H2" "H4" "H6" "H8" "F2" "F4" "F6" "F8" "I2" "I4" "I6" "I8"}) state:8 value:100) 
        (place "Base1" (sites {"B8"}) state:8 value:100) 
        (place "Base2" (sites {"M2"}) state:8 value:100)
        >  
        <
        
        >  
        <
        100
        >   
        <
        (set Team 1 {P1})
        (set Team 2 {P2})
        >  
        <
        (piece ExtendName P2 "Flip")
        >
        <
        (show Symbol "forest" (sites "Forest"))
        (show Symbol "waves" (sites "ShallowWater"))
        (show Symbol "waves" (sites "DeepWater"))
        (show Symbol "mountain" (sites "Mountain"))
        >   
        "Scenario - Gridlock"
    )
    
    (item "Tiny Island (2-player, square)"
        <
        "TwoPlayerMaps"
        >
        <
        2
        >
        <
        (rectangle 8 13)
        >
        <
        (regions "ShallowWater" (sites {"C7" "D7" "E7" "F7" "G7" "H7" "I7" "J7" "K7" 
                "C2" "D2" "E2" "F2" "G2" "H2" "I2" "J2" "K2"
                "B2" "B3" "B4" "B5" "B6" "B7" 
                "L2" "L3" "L4" "L5" "L6" "L7" 
        })) 
        
        (regions "DeepWater" (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7" "A8" "B8" "L8"
                "M1" "M2" "M3" "M4" "M5" "M6" "M7" "M8" "B1" "L1" 
                "C8" "D8" "E8" "F8" "G8" "H8" "I8" "J8" "K8"
                "C1" "D1" "E1" "F1" "G1" "H1" "I1" "J1" "K1" 
        })) 
        (regions "Forest" (sites {})) 
        (regions "Mountain" (sites {})) 
        > 
        <
        (place "Town0" (sites {"E5" "E4" "G5" "G4" "I5" "I4" "F5" "F4" "H5" "H4"}) state:8 value:100) 
        (place "Town1" (sites {"C4"}) state:8 value:100) 
        (place "Town2" (sites {"K5"}) state:8 value:100) 
        (place "Base1" (sites {"C5"}) state:8 value:100) 
        (place "Base2" (sites {"K4"}) state:8 value:100)
        (place "Dock1" (sites {"C3" "C6"}) state:8 value:100) 
        (place "Dock2" (sites {"K3" "K6"}) state:8 value:100)
        >  
        <
        
        >  
        <
        100
        >   
        <
        (set Team 1 {P1})
        (set Team 2 {P2})
        > 
        <
        (piece ExtendName P2 "Flip")
        >
        <
        (show Symbol "forest" (sites "Forest"))
        (show Symbol "waves" (sites "ShallowWater"))
        (show Symbol "waves" (sites "DeepWater"))
        (show Symbol "mountain" (sites "Mountain"))
        >   
        "Scenario - Tiny Island"
    )
    
    (item "Aerial Assault (2-player, square)"
        <
        "TwoPlayerMaps"
        >
        <
        2
        >
        <
        (rectangle 8 13)
        >
        <										 
        (regions "DeepWater" (sites {"G1" "G2" "G3" "G4" "G5" "G6" "G7" "G8"})) 
        (regions "ShallowWater" (sites {})) 
        (regions "Forest" (sites {})) 
        (regions "Mountain" (sites {})) 
        > 
        <
        (place "Town1" (sites {"A2" "A7" "C1" "C8"}) state:8 value:100) 
        (place "Town2" (sites {"M2" "M7" "K1" "K8"}) state:8 value:100) 
        (place "Town0" (sites {"I2" "I4" "I5" "I7" "E2" "E4" "E5" "E7"}) state:8 value:100) 
        (place "Base1" (sites {"A5"}) state:8 value:100) 
        (place "Base2" (sites {"M4"}) state:8 value:100)
        (place "Airport1" (sites {"C3" "C6"}) state:8 value:100) 
        (place "Airport2" (sites {"K3" "K6"}) state:8 value:100)
        >  
        <
        
        >  
        <
        100
        >  
        <
        (set Team 1 {P1})
        (set Team 2 {P2})
        > 
        <
        (piece ExtendName P2 "Flip")
        >
        <
        (show Symbol "forest" (sites "Forest"))
        (show Symbol "waves" (sites "ShallowWater"))
        (show Symbol "waves" (sites "DeepWater"))
        (show Symbol "mountain" (sites "Mountain"))
        >    
        "Scenario - Aerial Assault"
    )
    
    (item "Sudden Death (4-player, 4-teams, square)"
        <
        "FourPlayerMaps"
        >
        <
        4
        >
        <
        (square 11)
        >
        <
        (regions "Forest" (sites {"D7" "E8" "G8" "H7" "H5" "E11" "G11" "E1" "G1"
        "G4" "E4" "D5" "A7" "A5" "K5" "K7"})) 
        (regions "Mountain" (sites {"B6" "B5" "B7" "C3" "C9" "I9" "I3" "E10" "F10" "G10" "J7"
        "J6" "J5" "G2" "F2" "E2" "F6"})) 
        (regions "ShallowWater" (sites {})) 
        (regions "DeepWater" (sites {})) 
        > 
        <
        (place "Town1" (sites {"A1" "A2" "B1"}) state:8 value:100) 
        (place "Town2" (sites {"K11" "J11" "K10"}) state:8 value:100)
        (place "Town3" (sites {"A11" "A10" "B11"}) state:8 value:100)
        (place "Town4" (sites {"K1" "K2" "J1"}) state:8 value:100) 
        (place "Town0" (sites {"F3" "D4" "C6" "D8" "F9" "H8" "I6" "H4"}) state:8 value:100) 
        (place "Factory1" (sites {"A3" "C1"}) state:8 value:100) 
        (place "Factory2" (sites {"K9" "I11"}) state:8 value:100)
        (place "Factory3" (sites {"A9" "C11"}) state:8 value:100) 
        (place "Factory4" (sites {"K3" "I1"}) state:8 value:100)
        (place "Base1" (sites {"E6"}) state:8 value:100) 
        (place "Base2" (sites {"G6"}) state:8 value:100)
        (place "Base3" (sites {"F7"}) state:8 value:100) 
        (place "Base4" (sites {"F5"}) state:8 value:100)
        >  
        <
        
        >  
        <
        100
        >     
        <
        (set Team 1 {P1})
        (set Team 2 {P2})
        (set Team 3 {P3})
        (set Team 4 {P4})
        >  
        <
        (piece ExtendName P2 "Flip")
        (piece ExtendName P4 "Flip")
        >
        <
        (show Symbol "forest" (sites "Forest"))
        (show Symbol "waves" (sites "ShallowWater"))
        (show Symbol "waves" (sites "DeepWater"))
        (show Symbol "mountain" (sites "Mountain"))
        >
        "Scenario - Sudden Death"
    )
    
    (item "Random Small Map (2-player, hexagon)"
        <
        "TwoPlayerMaps"
        >
        <
        2
        >
        <
        (hex 5)
        >
        <
        (regions "BuildingsP1Area" (expand (union (sites Side NW) (sites Side SW)) steps:1))
        (regions "BuildingsP2Area" (expand (union (sites Side SE) (sites Side NE)) steps:1))
        (regions "BaseP1" (sites Random (union (sites Side NW) (sites Side SW)) num:1))
        (regions "BaseP2" (sites Random (union (sites Side SE) (sites Side NE)) num:1))
        (regions "TownP1" (sites Random (difference (sites "BuildingsP1Area") (sites "BaseP1")) num:2))
        (regions "TownP2" (sites Random (difference (sites "BuildingsP2Area") (sites "BaseP2")) num:2))
        
        (regions "TownP01" (sites Random (difference (sites "BuildingsP1Area") (union (sites "BaseP1") (sites "TownP1"))) num:1))
        (regions "TownP02" (sites Random (difference (sites "BuildingsP2Area") (union (sites "BaseP2") (sites "TownP2"))) num:1))
        (regions "TownP00" (sites Random (difference (sites Empty) (union {(sites "BuildingsP1Area") (sites "BuildingsP2Area")})) num:3))
        
        (regions "BuildingsTowns" (union {(sites "BaseP1") (sites "BaseP2") (sites "TownP1") (sites "TownP2") (sites "TownP01") (sites "TownP02") (sites "TownP00")}))
        
        (regions "Factory1" (sites Random (difference (sites "BuildingsP1Area") (sites "BuildingsTowns")) num:1))
        (regions "Factory2" (sites Random (difference (sites "BuildingsP2Area") (sites "BuildingsTowns")) num:1))
        
        (regions "Airport" (sites Random (difference (sites Empty) (union {(sites "Factory1") (sites "Factory2") (sites "BuildingsTowns") (sites "BuildingsP1Area") (sites "BuildingsP2Area")})) num:1))
        
        (regions "Buildings" (union {(sites "BuildingsTowns") (sites "Factory1") (sites "Factory2") (sites "Airport") }))
        (regions "SitesAroundBuildings" (expand (sites "Buildings")))
        
        (regions "River1" (sites Random (difference (union (sites Top) (sites Bottom)) (sites "SitesAroundBuildings")) num:1))
        (regions "River2" (sites Random (intersection (expand (sites "River1") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1")}))) num:1))
        (regions "River3" (sites Random (intersection (expand (sites "River2") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2")}))) num:1))
        (regions "River4" (sites Random (intersection (expand (sites "River3") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3")}))) num:1))
        (regions "River5" (sites Random (intersection (expand (sites "River4") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3") (sites "River4")}))) num:1))
        (regions "River6" (sites Random (intersection (expand (sites "River5") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3") (sites "River4") (sites "River5")}))) num:1))
        
        (regions "FirstRiver" (union {(sites "River1") (sites "River2") (sites "River3") (sites "River4") (sites "River5") (sites "River6") }))		
        
        (regions "DeepWater" (union {(sites "FirstRiver")}))
        
        (regions "Docks1" (sites Random (difference (expand (sites "FirstRiver")) (union (sites "Buildings") (sites "DeepWater"))) num:1))
        (regions "Docks" (union {(sites "Docks1") }))
        
        (regions "ShallowWater" (difference (expand (sites "DeepWater")) (union {(sites "Buildings") (sites "DeepWater") (sites "Docks")})))
        
        (regions "MountainArea" (difference (expand (union {(sites Top) (sites Bottom) (sites Side NW) (sites Side NE) (sites Side SW) (sites Side SE)})) (union {(sites "Buildings") (sites "DeepWater") (sites "Docks") (sites "ShallowWater")})))
        (regions "Mountain" (sites Random (sites "MountainArea") num:5))
        
        (regions "Forest" (sites Random (difference (sites Board) (union {(sites "ShallowWater") (sites "DeepWater") (sites "Mountain") (sites "Docks") (sites "Buildings")})) num:8))  
        > 
        <
        (place "Base1" (sites "BaseP1") state:8 value:100) 
        (place "Base2" (sites "BaseP2") state:8 value:100) 
        (place "Town1" (sites "TownP1") state:8 value:100) 
        (place "Town2" (sites "TownP2") state:8 value:100) 
        (place "Town0" (sites "TownP01") state:8 value:100)
        (place "Town0" (sites "TownP02") state:8 value:100) 
        (place "Town0" (sites "TownP00") state:8 value:100) 
        (place "Factory0" (sites "Factory1") state:8 value:100) 
        (place "Factory0" (sites "Factory2") state:8 value:100) 
        (place "Dock0" (sites "Docks") state:8 value:100) 
        (place "Airport0" (sites "Airport") state:8 value:100) 
        >  
        <
        
        >  
        <
        150
        >     
        <
        (set Team 1 {P1})
        (set Team 2 {P2})
        >
        <
        (piece ExtendName P2 "Flip")
        >
        <
        (show Symbol "forest" (sites "Forest") scale:0.8)
        (show Symbol "waves" (sites "ShallowWater") scale:0.9)
        (show Symbol "waves" (sites "DeepWater") scale:0.9)
        (show Symbol "mountain" (sites "Mountain") scale:0.9)
        >
        "Scenario - Random Small Map (Hexagon)"
    )
    
    (item "Random Small Map (2-player, square)"
        <
        "TwoPlayerMaps"
        >
        <
        2
        >
        <
        (rectangle 7 9)
        >
        <
        (regions "BuildingsP1Area" (expand (sites Left) steps:1))
        (regions "BuildingsP2Area" (expand (sites Right) steps:1))
        (regions "BaseP1" (sites Random (sites Left) num:1))
        (regions "BaseP2" (sites Random (sites Right) num:1))
        (regions "TownP1" (sites Random (difference (sites "BuildingsP1Area") (sites "BaseP1")) num:2))
        (regions "TownP2" (sites Random (difference (sites "BuildingsP2Area") (sites "BaseP2")) num:2))
        
        (regions "TownP01" (sites Random (difference (sites "BuildingsP1Area") (union (sites "BaseP1") (sites "TownP1"))) num:1))
        (regions "TownP02" (sites Random (difference (sites "BuildingsP2Area") (union (sites "BaseP2") (sites "TownP2"))) num:1))
        (regions "TownP00" (sites Random (difference (sites Empty) (union {(sites "BuildingsP1Area") (sites "BuildingsP2Area")})) num:3))
        
        (regions "BuildingsTowns" (union {(sites "BaseP1") (sites "BaseP2") (sites "TownP1") (sites "TownP2") (sites "TownP01") (sites "TownP02") (sites "TownP00")}))
        
        (regions "Factory1" (sites Random (difference (sites "BuildingsP1Area") (sites "BuildingsTowns")) num:1))
        (regions "Factory2" (sites Random (difference (sites "BuildingsP2Area") (sites "BuildingsTowns")) num:1))
        
        (regions "Airport" (sites Random (difference (sites Empty) (union {(sites "Factory1") (sites "Factory2") (sites "BuildingsTowns") (sites "BuildingsP1Area") (sites "BuildingsP2Area")})) num:1))
        
        (regions "Buildings" (union {(sites "BuildingsTowns") (sites "Factory1") (sites "Factory2") (sites "Airport") }))
        (regions "SitesAroundBuildings" (expand (sites "Buildings")))
        
        (regions "River1" (sites Random (difference (union (sites Top) (sites Bottom)) (sites "SitesAroundBuildings")) num:1))
        (regions "River2" (sites Random (intersection (expand (sites "River1") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1")}))) num:1))
        (regions "River3" (sites Random (intersection (expand (sites "River2") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2")}))) num:1))
        (regions "River4" (sites Random (intersection (expand (sites "River3") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3")}))) num:1))
        (regions "River5" (sites Random (intersection (expand (sites "River4") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3") (sites "River4")}))) num:1))
        (regions "River6" (sites Random (intersection (expand (sites "River5") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3") (sites "River4") (sites "River5")}))) num:1))
        
        (regions "FirstRiver" (union {(sites "River1") (sites "River2") (sites "River3") (sites "River4") (sites "River5") (sites "River6") }))		
        
        (regions "DeepWater" (union {(sites "FirstRiver")}))
        
        (regions "Docks1" (sites Random (difference (expand (sites "FirstRiver")) (union (sites "Buildings") (sites "DeepWater"))) num:1))
        (regions "Docks" (union {(sites "Docks1") }))
        
        (regions "ShallowWater" (difference (expand (sites "DeepWater")) (union {(sites "Buildings") (sites "DeepWater") (sites "Docks")})))
        
        (regions "MountainArea" (difference (expand (union {(sites Top) (sites Bottom) (sites Left) (sites Right)})) (union {(sites "Buildings") (sites "DeepWater") (sites "Docks") (sites "ShallowWater")})))
        (regions "Mountain" (sites Random (sites "MountainArea") num:5))
        
        (regions "Forest" (sites Random (difference (sites Board) (union {(sites "ShallowWater") (sites "DeepWater") (sites "Mountain") (sites "Docks") (sites "Buildings")})) num:8))  
        > 
        <
        (place "Base1" (sites "BaseP1") state:8 value:100) 
        (place "Base2" (sites "BaseP2") state:8 value:100) 
        (place "Town1" (sites "TownP1") state:8 value:100) 
        (place "Town2" (sites "TownP2") state:8 value:100) 
        (place "Town0" (sites "TownP01") state:8 value:100)
        (place "Town0" (sites "TownP02") state:8 value:100) 
        (place "Town0" (sites "TownP00") state:8 value:100) 
        (place "Factory0" (sites "Factory1") state:8 value:100) 
        (place "Factory0" (sites "Factory2") state:8 value:100) 
        (place "Dock0" (sites "Docks") state:8 value:100) 
        (place "Airport0" (sites "Airport") state:8 value:100) 
        >  
        <
        
        >  
        <
        150
        >     
        <
        (set Team 1 {P1})
        (set Team 2 {P2})
        >
        <
        (piece ExtendName P2 "Flip")
        >
        <
        (show Symbol "forest" (sites "Forest"))
        (show Symbol "waves" (sites "ShallowWater"))
        (show Symbol "waves" (sites "DeepWater"))
        (show Symbol "mountain" (sites "Mountain"))
        >
        "Scenario - Random Small Map (Square)"
    )
    
    (item "Random Large Map (2-player, hexagon)"
        <
        "TwoPlayerMaps"
        >
        <
        2
        >
        <
        (hex 7)
        >
        <
        (regions "BuildingsP1Area" (expand (union (sites Side NW) (sites Side SW)) steps:3))
        (regions "BuildingsP2Area" (expand (union (sites Side SE) (sites Side NE)) steps:3))
        (regions "BaseP1" (sites Random (union (sites Side NW) (sites Side SW)) num:1))
        (regions "BaseP2" (sites Random (union (sites Side SE) (sites Side NE)) num:1))
        (regions "TownP1" (sites Random (difference (sites "BuildingsP1Area") (sites "BaseP1")) num:4))
        (regions "TownP2" (sites Random (difference (sites "BuildingsP2Area") (sites "BaseP2")) num:4))
        
        (regions "TownP01" (sites Random (difference (sites "BuildingsP1Area") (union (sites "BaseP1") (sites "TownP1"))) num:2))
        (regions "TownP02" (sites Random (difference (sites "BuildingsP2Area") (union (sites "BaseP2") (sites "TownP2"))) num:2))
        (regions "TownP00" (sites Random (difference (sites Empty) (union {(sites "BuildingsP1Area") (sites "BuildingsP2Area")})) num:5))
        
        (regions "BuildingsTowns" (union {(sites "BaseP1") (sites "BaseP2") (sites "TownP1") (sites "TownP2") (sites "TownP01") (sites "TownP02") (sites "TownP00")}))
        
        (regions "Factory1" (sites Random (difference (sites "BuildingsP1Area") (sites "BuildingsTowns")) num:1))
        (regions "Factory2" (sites Random (difference (sites "BuildingsP2Area") (sites "BuildingsTowns")) num:1))
        
        (regions "Airport" (sites Random (difference (sites Empty) (union {(sites "Factory1") (sites "Factory2") (sites "BuildingsTowns") (sites "BuildingsP1Area") (sites "BuildingsP2Area")})) num:1))
        
        (regions "Buildings" (union {(sites "BuildingsTowns") (sites "Factory1") (sites "Factory2") (sites "Airport") }))
        (regions "SitesAroundBuildings" (expand (sites "Buildings")))
        
        (regions "River1" (sites Random (difference (union (sites Top) (sites Bottom)) (sites "SitesAroundBuildings")) num:1))
        (regions "River2" (sites Random (intersection (expand (sites "River1") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1")}))) num:1))
        (regions "River3" (sites Random (intersection (expand (sites "River2") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2")}))) num:1))
        (regions "River4" (sites Random (intersection (expand (sites "River3") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3")}))) num:1))
        (regions "River5" (sites Random (intersection (expand (sites "River4") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3") (sites "River4")}))) num:1))
        (regions "River6" (sites Random (intersection (expand (sites "River5") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3") (sites "River4") (sites "River5")}))) num:1))
        (regions "River7" (sites Random (intersection (expand (sites "River6") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3") (sites "River4") (sites "River5") (sites "River6")}))) num:1))
        (regions "River8" (sites Random (intersection (expand (sites "River7") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3") (sites "River4") (sites "River5") (sites "River6") (sites "River7")}))) num:1))
        (regions "River9" (sites Random (intersection (expand (sites "River8") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3") (sites "River4") (sites "River5") (sites "River6") (sites "River7") (sites "River8")}))) num:1))
        (regions "River10" (sites Random (intersection (expand (sites "River9") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3") (sites "River4") (sites "River5") (sites "River6") (sites "River7") (sites "River8") (sites "River9")}))) num:1))
        (regions "River11" (sites Random (intersection (expand (sites "River10") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3") (sites "River4") (sites "River5") (sites "River6") (sites "River7") (sites "River8") (sites "River9") (sites "River10")}))) num:1))
        
        (regions "FirstRiver" (union {(sites "River1") (sites "River2") (sites "River3") (sites "River4") (sites "River5") (sites "River6") (sites "River7")
        (sites "River8") (sites "River9") (sites "River10") (sites "River11") }))		
        (regions "FirstRiverArea" (expand (sites "FirstRiver") steps:3))
        
        (regions "Riverx1" (sites Random (difference (sites Board) (union (sites "SitesAroundBuildings") (sites "FirstRiverArea"))) num:1))
        (regions "Riverx2" (sites Random (intersection (expand (sites "Riverx1") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") (sites "FirstRiverArea")
        (sites "Riverx1")}))) num:1))
        (regions "Riverx3" (sites Random (intersection (expand (sites "Riverx2") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") (sites "FirstRiverArea")
        (sites "Riverx1") (sites "Riverx2")}))) num:1))
        (regions "Riverx4" (sites Random (intersection (expand (sites "Riverx3") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") (sites "FirstRiverArea")
        (sites "Riverx1") (sites "Riverx2") (sites "Riverx3")}))) num:1))
        (regions "Riverx5" (sites Random (intersection (expand (sites "Riverx4") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") (sites "FirstRiverArea")
        (sites "Riverx1") (sites "Riverx2") (sites "Riverx3") (sites "Riverx4")}))) num:1))
        (regions "Riverx6" (sites Random (intersection (expand (sites "Riverx5") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") (sites "FirstRiverArea")
        (sites "Riverx1") (sites "Riverx2") (sites "Riverx3") (sites "Riverx4") (sites "Riverx5")}))) num:1))
        
        (regions "SecondRiver" (union {(sites "Riverx1") (sites "Riverx2") (sites "Riverx3") (sites "Riverx4") (sites "Riverx5") (sites "Riverx6")}))
        
        (regions "DeepWater" (union {(sites "FirstRiver") (sites "SecondRiver")}))
        
        (regions "Docks1" (sites Random (difference (expand (sites "FirstRiver")) (union (sites "Buildings") (sites "DeepWater"))) num:1))
        (regions "Docks2" (sites Random (difference (expand (sites "SecondRiver")) (union (sites "Buildings") (sites "DeepWater"))) num:1))
        (regions "Docks" (union {(sites "Docks1") (sites "Docks2")}))
        
        (regions "ShallowWater" (difference (expand (sites "DeepWater")) (union {(sites "Buildings") (sites "DeepWater") (sites "Docks")})))
        
        (regions "MountainArea" (difference (expand (union {(sites Top) (sites Bottom) (sites Side NW) (sites Side NE) (sites Side SW) (sites Side SE)})) (union {(sites "Buildings") (sites "DeepWater") (sites "Docks") (sites "ShallowWater")})))
        (regions "Mountain" (sites Random (sites "MountainArea") num:14))
        
        (regions "Forest" (sites Random (difference (sites Board) (union {(sites "ShallowWater") (sites "DeepWater") (sites "Mountain") (sites "Docks") (sites "Buildings")})) num:20))  
        > 
        <
        (place "Base1" (sites "BaseP1") state:8 value:100) 
        (place "Base2" (sites "BaseP2") state:8 value:100) 
        (place "Town1" (sites "TownP1") state:8 value:100) 
        (place "Town2" (sites "TownP2") state:8 value:100) 
        (place "Town0" (sites "TownP01") state:8 value:100)
        (place "Town0" (sites "TownP02") state:8 value:100) 
        (place "Town0" (sites "TownP00") state:8 value:100) 
        (place "Factory0" (sites "Factory1") state:8 value:100) 
        (place "Factory0" (sites "Factory2") state:8 value:100) 
        (place "Dock0" (sites "Docks") state:8 value:100) 
        (place "Airport0" (sites "Airport") state:8 value:100) 
        >  
        <
        
        >  
        <
        200
        >      
        <
        (set Team 1 {P1})
        (set Team 2 {P2})
        >
        <
        (piece ExtendName P2 "Flip")
        >
        <
        (show Symbol "forest" (sites "Forest") scale:0.8)
        (show Symbol "waves" (sites "ShallowWater") scale:0.9)
        (show Symbol "waves" (sites "DeepWater") scale:0.9)
        (show Symbol "mountain" (sites "Mountain") scale:0.9)
        >
        "Scenario - Random Large Map (Hexagon)"
    )
    
    (item "Random Large Map (2-player, square)"
        <
        "TwoPlayerMaps"
        >
        <
        2
        >
        <
        (rectangle 10 14)
        >
        <
        (regions "BuildingsP1Area" (expand (sites Left) steps:3))
        (regions "BuildingsP2Area" (expand (sites Right) steps:3))
        (regions "BaseP1" (sites Random (sites Left) num:1))
        (regions "BaseP2" (sites Random (sites Right) num:1))
        (regions "TownP1" (sites Random (difference (sites "BuildingsP1Area") (sites "BaseP1")) num:4))
        (regions "TownP2" (sites Random (difference (sites "BuildingsP2Area") (sites "BaseP2")) num:4))
        
        (regions "TownP01" (sites Random (difference (sites "BuildingsP1Area") (union (sites "BaseP1") (sites "TownP1"))) num:2))
        (regions "TownP02" (sites Random (difference (sites "BuildingsP2Area") (union (sites "BaseP2") (sites "TownP2"))) num:2))
        (regions "TownP00" (sites Random (difference (sites Empty) (union {(sites "BuildingsP1Area") (sites "BuildingsP2Area")})) num:5))
        
        (regions "BuildingsTowns" (union {(sites "BaseP1") (sites "BaseP2") (sites "TownP1") (sites "TownP2") (sites "TownP01") (sites "TownP02") (sites "TownP00")}))
        
        (regions "Factory1" (sites Random (difference (sites "BuildingsP1Area") (sites "BuildingsTowns")) num:1))
        (regions "Factory2" (sites Random (difference (sites "BuildingsP2Area") (sites "BuildingsTowns")) num:1))
        
        (regions "Airport" (sites Random (difference (sites Empty) (union {(sites "Factory1") (sites "Factory2") (sites "BuildingsTowns") (sites "BuildingsP1Area") (sites "BuildingsP2Area")})) num:1))
        
        (regions "Buildings" (union {(sites "BuildingsTowns") (sites "Factory1") (sites "Factory2") (sites "Airport") }))
        (regions "SitesAroundBuildings" (expand (sites "Buildings")))
        
        (regions "River1" (sites Random (difference (union (sites Top) (sites Bottom)) (sites "SitesAroundBuildings")) num:1))
        (regions "River2" (sites Random (intersection (expand (sites "River1") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1")}))) num:1))
        (regions "River3" (sites Random (intersection (expand (sites "River2") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2")}))) num:1))
        (regions "River4" (sites Random (intersection (expand (sites "River3") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3")}))) num:1))
        (regions "River5" (sites Random (intersection (expand (sites "River4") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3") (sites "River4")}))) num:1))
        (regions "River6" (sites Random (intersection (expand (sites "River5") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3") (sites "River4") (sites "River5")}))) num:1))
        (regions "River7" (sites Random (intersection (expand (sites "River6") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3") (sites "River4") (sites "River5") (sites "River6")}))) num:1))
        (regions "River8" (sites Random (intersection (expand (sites "River7") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3") (sites "River4") (sites "River5") (sites "River6") (sites "River7")}))) num:1))
        (regions "River9" (sites Random (intersection (expand (sites "River8") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3") (sites "River4") (sites "River5") (sites "River6") (sites "River7") (sites "River8")}))) num:1))
        (regions "River10" (sites Random (intersection (expand (sites "River9") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3") (sites "River4") (sites "River5") (sites "River6") (sites "River7") (sites "River8") (sites "River9")}))) num:1))
        (regions "River11" (sites Random (intersection (expand (sites "River10") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") 
        (sites "River1") (sites "River2") (sites "River3") (sites "River4") (sites "River5") (sites "River6") (sites "River7") (sites "River8") (sites "River9") (sites "River10")}))) num:1))
        
        (regions "FirstRiver" (union {(sites "River1") (sites "River2") (sites "River3") (sites "River4") (sites "River5") (sites "River6") (sites "River7")
        (sites "River8") (sites "River9") (sites "River10") (sites "River11") }))		
        (regions "FirstRiverArea" (expand (sites "FirstRiver") steps:3))
        
        (regions "Riverx1" (sites Random (difference (sites Board) (union (sites "SitesAroundBuildings") (sites "FirstRiverArea"))) num:1))
        (regions "Riverx2" (sites Random (intersection (expand (sites "Riverx1") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") (sites "FirstRiverArea")
        (sites "Riverx1")}))) num:1))
        (regions "Riverx3" (sites Random (intersection (expand (sites "Riverx2") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") (sites "FirstRiverArea")
        (sites "Riverx1") (sites "Riverx2")}))) num:1))
        (regions "Riverx4" (sites Random (intersection (expand (sites "Riverx3") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") (sites "FirstRiverArea")
        (sites "Riverx1") (sites "Riverx2") (sites "Riverx3")}))) num:1))
        (regions "Riverx5" (sites Random (intersection (expand (sites "Riverx4") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") (sites "FirstRiverArea")
        (sites "Riverx1") (sites "Riverx2") (sites "Riverx3") (sites "Riverx4")}))) num:1))
        (regions "Riverx6" (sites Random (intersection (expand (sites "Riverx5") Orthogonal) (difference (sites Board) (union {(sites "SitesAroundBuildings") (sites "FirstRiverArea")
        (sites "Riverx1") (sites "Riverx2") (sites "Riverx3") (sites "Riverx4") (sites "Riverx5")}))) num:1))
        
        (regions "SecondRiver" (union {(sites "Riverx1") (sites "Riverx2") (sites "Riverx3") (sites "Riverx4") (sites "Riverx5") (sites "Riverx6")}))
        
        (regions "DeepWater" (union {(sites "FirstRiver") (sites "SecondRiver")}))
        
        (regions "Docks1" (sites Random (difference (expand (sites "FirstRiver")) (union (sites "Buildings") (sites "DeepWater"))) num:1))
        (regions "Docks2" (sites Random (difference (expand (sites "SecondRiver")) (union (sites "Buildings") (sites "DeepWater"))) num:1))
        (regions "Docks" (union {(sites "Docks1") (sites "Docks2")}))
        
        (regions "ShallowWater" (difference (expand (sites "DeepWater")) (union {(sites "Buildings") (sites "DeepWater") (sites "Docks")})))
        
        (regions "MountainArea" (difference (expand (union {(sites Top) (sites Bottom) (sites Left) (sites Right)})) (union {(sites "Buildings") (sites "DeepWater") (sites "Docks") (sites "ShallowWater")})))
        (regions "Mountain" (sites Random (sites "MountainArea") num:14))
        
        (regions "Forest" (sites Random (difference (sites Board) (union {(sites "ShallowWater") (sites "DeepWater") (sites "Mountain") (sites "Docks") (sites "Buildings")})) num:20))  
        > 
        <
        (place "Base1" (sites "BaseP1") state:8 value:100) 
        (place "Base2" (sites "BaseP2") state:8 value:100) 
        (place "Town1" (sites "TownP1") state:8 value:100) 
        (place "Town2" (sites "TownP2") state:8 value:100) 
        (place "Town0" (sites "TownP01") state:8 value:100)
        (place "Town0" (sites "TownP02") state:8 value:100) 
        (place "Town0" (sites "TownP00") state:8 value:100) 
        (place "Factory0" (sites "Factory1") state:8 value:100) 
        (place "Factory0" (sites "Factory2") state:8 value:100) 
        (place "Dock0" (sites "Docks") state:8 value:100) 
        (place "Airport0" (sites "Airport") state:8 value:100) 
        >  
        <
        
        >  
        <
        200
        >     
        <
        (set Team 1 {P1})
        (set Team 2 {P2})
        >
        <
        (piece ExtendName P2 "Flip")
        >
        <
        (show Symbol "forest" (sites "Forest"))
        (show Symbol "waves" (sites "ShallowWater"))
        (show Symbol "waves" (sites "DeepWater"))
        (show Symbol "mountain" (sites "Mountain"))
        >
        "Scenario - Random Large Map (Square)"
    )
    
    }
)

//------------------------------------------------------------------------------

(option "Fog of War" <FogOfWar> args:{ <AttackCheck> <EachMove> <Metadata> }
    {
    (item "Off" 	<> <> <> 															"No Fog of War.")**
    (item "On" 	<"FogOfWarAttackCheck"> <"FogOfWarEachMove"> <"FogOfWarMetadata">	"Fog of War.")
})

//------------------------------------------------------------------------------

(option "Player 1 Doctrine" <Doctrine1> args:{ <doctrine> }
    {
    (item "None" 			<"NoDoctrine"> 		"Player 1 - No Doctrine.")**
    (item "Special Forces" 	<"SpecialForces"> 	"Player 1 - Special Forces.")
    (item "Brute Strength"		<"BruteStrength"> 	"Player 1 - Brute Strength.")
    (item "Sharpshooter" 	<"Sharpshooter"> 	"Player 1 - Sharpshooter.")
    (item "Ace Pilot" 		<"AcePilot"> 			"Player 1 - Ace Pilot.")
    (item "Sea Dog" 			<"SeaDog"> 			"Player 1 - Sea Dog.")
    (item "Guerrilla Warfare" 	<"GuerrillaWarfare"> 	"Player 1 - Guerrilla Warfare.")
    (item "Foreign Invader" 	<"ForeignInvader"> 	"Player 1 - Foreign Invader.")
    (item "Conscription" 	<"Conscription"> 	"Player 1 - Conscription.")
    (item "Elite Training" 	<"EliteTraining"> 	"Player 1 - Elite Training.")
    (item "Glass Cannon" 	<"GlassCannon"> 		"Player 1 - Glass Cannon.")
    (item "Hardened Resolve" <"HardenedResolve"> 	"Player 1 - Hardened Resolve.")
    (item "Preemptive Strike" 	<"PreemptiveStrike"> 	"Player 1 - Preemptive Strike.")
    (item "Retaliation" 		<"Retaliation"> 		"Player 1 - Retaliation.")
    (item "Lady Luck" 		<"LadyLuck"> 		"Player 1 - Lady Luck.")
})

(option "Player 2 Doctrine" <Doctrine2> args:{ <doctrine> }
    {
    (item "None" 			<"NoDoctrine"> 		"Player 2 - No Doctrine.")**
    (item "Special Forces" 	<"SpecialForces"> 	"Player 2 - Special Forces.")
    (item "Brute Strength"		<"BruteStrength"> 	"Player 2 - Brute Strength.")
    (item "Sharpshooter" 	<"Sharpshooter"> 	"Player 2 - Sharpshooter.")
    (item "Ace Pilot" 		<"AcePilot"> 			"Player 2 - Ace Pilot.")
    (item "Sea Dog" 			<"SeaDog"> 			"Player 2 - Sea Dog.")
    (item "Guerrilla Warfare" 	<"GuerrillaWarfare"> 	"Player 2 - Guerrilla Warfare.")
    (item "Foreign Invader" 	<"ForeignInvader"> 	"Player 2 - Foreign Invader.")
    (item "Conscription" 	<"Conscription"> 	"Player 2 - Conscription.")
    (item "Elite Training" 	<"EliteTraining"> 	"Player 2 - Elite Training.")
    (item "Glass Cannon" 	<"GlassCannon"> 		"Player 2 - Glass Cannon.")
    (item "Hardened Resolve" <"HardenedResolve"> 	"Player 2 - Hardened Resolve.")
    (item "Preemptive Strike" 	<"PreemptiveStrike"> 	"Player 2 - Preemptive Strike.")
    (item "Retaliation" 		<"Retaliation"> 		"Player 2 - Retaliation.")
    (item "Lady Luck" 		<"LadyLuck"> 		"Player 2 - Lady Luck.")
})

(option "Player 3 Doctrine" <Doctrine3> args:{ <doctrine> }
    {
    (item "None" 			<"NoDoctrine"> 		"Player 3 - No Doctrine.")**
    (item "Special Forces" 	<"SpecialForces"> 	"Player 3 - Special Forces.")
    (item "Brute Strength"		<"BruteStrength"> 	"Player 3 - Brute Strength.")
    (item "Sharpshooter" 	<"Sharpshooter"> 	"Player 3 - Sharpshooter.")
    (item "Ace Pilot" 		<"AcePilot"> 			"Player 3 - Ace Pilot.")
    (item "Sea Dog" 			<"SeaDog"> 			"Player 3 - Sea Dog.")
    (item "Guerrilla Warfare" 	<"GuerrillaWarfare"> 	"Player 3 - Guerrilla Warfare.")
    (item "Foreign Invader" 	<"ForeignInvader"> 	"Player 3 - Foreign Invader.")
    (item "Conscription" 	<"Conscription"> 	"Player 3 - Conscription.")
    (item "Elite Training" 	<"EliteTraining"> 	"Player 3 - Elite Training.")
    (item "Glass Cannon" 	<"GlassCannon"> 		"Player 3 - Glass Cannon.")
    (item "Hardened Resolve" <"HardenedResolve"> 	"Player 3 - Hardened Resolve.")
    (item "Preemptive Strike" 	<"PreemptiveStrike"> 	"Player 3 - Preemptive Strike.")
    (item "Retaliation" 		<"Retaliation"> 		"Player 3 - Retaliation.")
    (item "Lady Luck" 		<"LadyLuck"> 		"Player 3 - Lady Luck.")
})

(option "Player 4 Doctrine" <Doctrine4> args:{ <doctrine> }
    {
    (item "None" 			<"NoDoctrine"> 		"Player 4 - No Doctrine.")**
    (item "Special Forces" 	<"SpecialForces"> 	"Player 4 - Special Forces.")
    (item "Brute Strength"		<"BruteStrength"> 	"Player 4 - Brute Strength.")
    (item "Sharpshooter" 	<"Sharpshooter"> 	"Player 4 - Sharpshooter.")
    (item "Ace Pilot" 		<"AcePilot"> 			"Player 4 - Ace Pilot.")
    (item "Sea Dog" 			<"SeaDog"> 			"Player 4 - Sea Dog.")
    (item "Guerrilla Warfare" 	<"GuerrillaWarfare"> 	"Player 4 - Guerrilla Warfare.")
    (item "Foreign Invader" 	<"ForeignInvader"> 	"Player 4 - Foreign Invader.")
    (item "Conscription" 	<"Conscription"> 	"Player 4 - Conscription.")
    (item "Elite Training" 	<"EliteTraining"> 	"Player 4 - Elite Training.")
    (item "Glass Cannon" 	<"GlassCannon"> 		"Player 4 - Glass Cannon.")
    (item "Hardened Resolve" <"HardenedResolve"> 	"Player 4 - Hardened Resolve.")
    (item "Preemptive Strike" 	<"PreemptiveStrike"> 	"Player 4 - Preemptive Strike.")
    (item "Retaliation" 		<"Retaliation"> 		"Player 4 - Retaliation.")
    (item "Lady Luck" 		<"LadyLuck"> 		"Player 4 - Lady Luck.")
})

//------------------------------------------------------------------------------

(metadata
    
    (info
        {
        (description "Mini Wars is a simplified tabletop war game.")
        (rules "//------------------------------------------------------------------------------
            <b>General Rules:</b>
            
            <u>The following rules apply to all units, unless stated otherwise in their description:</u>
            
            - All units move and measure distance orthogonally.
            - Units may move up to their maximum movement limit and can then attack an adjacent site.
            
            - Attacking a unit will deal damage to it (see damage calculation section).
            - If an attacked unit's health reaches zero, it will be removed from the battlefield.
            - Defending units that survive an attack, will then deal counter damage to their attacker.
            
            - Units can reinforce an adjacent unit of the same type, instead of attacking.
            - Both units must be owned by the same player.
            - Reinforcing will convert health from one unit to the other, transferring as much health as possible.
            - Any units that are left with zero health after reinforcing are removed.
            - A unit which has been reinforced cannot perform any further actions this turn.
            
            <u>The following rules apply to all buildings:</u>
            
            - There are five types of building: Town, Factory, Airport, Dock and Base.
            
            - Attacking a building will deal damage to it (see damage calculation section).
            - If an attacked building's health reaches zero, it will gain 50 health and change ownership to the player who attacked it. 
            - Buildings that are attacked, will not deal counter damage.
            
            - Units can heal at an adjacent building that you own, instead of attacking.
            - Healing at a building, will convert health from the building to the unit, transferring as much health as possible.
            
            - Additional units can be purchased using gold at their corresponding production building.
            - To purchase a unit, drag it from your hand to an available site next to a production building that you own.
            - The cost of purchasing a unit is represented by its count.
            - Purchased units cannot move, attack or heal, on the same turn they are purchased.
            
            - Each player receives 10 gold for every Town they own and 20 gold for every Base they own, at the start of their turn.
            - Buildings gain 10 health at the end of the owning player's turn, up to a maximum of 100.
            - Grey buildings are neutral, and are not owned by any player.
            
            - If a player loses ownership of all their Bases, they lose the game.
            
            //------------------------------------------------------------------------------
            <b>Units:</b>
            
            <u>Human</u> (Purchased from Towns)
            
            Soldier
            Move: 3
            Health: 30
            Cost: 30
            Damage Factor: 50%
            
            Motorbike
            Move: 5
            Health: 40
            Cost: 50
            Damage Factor: 50%
            
            <u>Vehicle</u> (Purchased from Factories)
            
            Speeder
            Move: 6
            Health: 60
            Cost: 60
            Damage Factor: 40%
            
            Shooter
            Move: 4
            Health: 60
            Cost: 80
            Damage Factor: 40%
            - Deals double damage against Humans.
            
            Tank
            Move: 4
            Health: 80
            Cost: 100
            Damage Factor: 50%
            
            Anti-Aircraft
            Move: 4
            Health: 50
            Cost: 80
            Damage Factor: 100%
            - Can only attack Aircraft.
            - Can attack units 1-2 spaces away.
            - Does not deal or receive counter damage during an attack.
            
            Missile Launcher
            Move: 3
            Health: 50
            Cost: 80
            Damage Factor: 50%
            - Cannot attack Aircraft.
            - Can only attack units 2-3 spaces away.
            - Does not deal or receive counter damage during an attack.
            
            Artillery
            Move: 3
            Health: 40
            Cost: 100
            Damage Factor: 100%
            - Cannot attack Aircraft.
            - Can only attack units 3-5 spaces away.
            - Does not deal or receive counter damage during an attack.
            - Cannot attack or heal in the same turn that it moved.
            
            <u>Aircraft</u> (Purchased from Airports)
            
            Helicopter
            Move: 4
            Health: 40
            Cost: 60
            Damage Factor: 70%
            
            Fighter Jet
            Move: 6
            Health: 100
            Cost: 100
            Damage Factor: 100%
            - Can only attack Aircraft.
            
            Bomber
            Move: 5
            Health: 100
            Cost: 120
            Damage Factor: 80%
            - Cannot attack Aircraft.
            
            <u>Boat</u> (Purchased from Docks)
            
            Cruiser
            Move: 5
            Health: 70
            Cost: 60
            Damage Factor: 50%
            
            Submarine
            Move: 5
            Health: 100
            Cost: 100
            Damage Factor: 80%
            - Can only attack Boats.
            
            Battleship
            Move: 4
            Health: 120
            Cost: 120
            Damage Factor: 50%
            - Cannot attack Aircraft.
            - Can only attack units 2-4 spaces away.
            - Does not deal or receive counter damage during an attack.
            
            //------------------------------------------------------------------------------
            <b>Movement Restrictions:</b>
            
            Humans may travel across plains, forests, and shallow water. They may also move 1 space into mountains instead of their regular movement.
            Vehicles may travel across plains. They may also move 1 space into forests or shallow water instead of their regular movement.
            Aircraft may travel across all spaces.
            Boats may travel across shallow and deep water.
            Buildings cannot move (obviously).
            Units cannot move over enemy or neutral occupied spaces.
            
            //------------------------------------------------------------------------------
            <b>Damage Calculation:</b>
            
            An attacking unit deals damage equal to its health, multiplied by its damage factor. 
            For example, A submarine has a damage factor of 80%, so a submarine with 20 health will deal 16 damage when it attacks (20 x 0.8).
            If the defending unit is in shallow or deep water, it takes 25% more damage.
            If the defending unit is in a forest, it takes 25% less damage.
            Aircraft are unaffected by terrain when calculating damage against them.
            All damage values are rounded down to the nearest whole number.
            
            //------------------------------------------------------------------------------
            <b>Fog of War:</b> (Optional)
            
            All friendly units and buildings can see tiles up to 2 spaces away.
            Aircraft can see tiles up to 3 spaces away.
            Boats can see shallow and deep water tiles up to 3 spaces away.
            Humans on a mountain can see tiles up to 3 spaces away.
            Forest and mountain tiles can only be seen if adjacent to them.
            Enemy units and buildings that are not visible cannot be attacked, and have their type and health hidden.
            
            //------------------------------------------------------------------------------
            <b>Army Doctrine:</b>
            
            At the start of the game (selected via the game options) you may pick a doctrine for your army.
            
            None - No effect.
            Special Forces - Human units do 50% more damage, all other units do 25% less damage.
            Brute Strength - Direct Vehicle units (no range on their attack distance) do 50% more damage, all other units do 25% less damage.
            Sharpshooter - Indirect Vehicle units (range on their attack distance) do 50% more damage, all other units do 25% less damage.
            Ace Pilot - Aircraft units do 50% more damage, all other units do 25% less damage.
            Sea Dog - Boat units do 50% more damage, all other units do 25% less damage.
            Guerrilla Warfare - Attacks against buildings deal 50% more damage, but attacks against units deal 25% less damage.
            Foreign Invader - Attacks against buildings deal 50% less damage, but attacks against units deal 25% more damage.
            Conscription - Units cost 50% less gold, but do 50% less damage.
            Elite Training - Units cost 50% more gold, but do 50% more damage.
            Glass Cannon - Units do 50% more damage, but take 50% more damage.
            Hardened Resolve - Units do 50% less damage, but take 50% less damage.
            Preemptive Strike - Units do 50% more damage when attacking, but never deal counter damage.
            Retaliation - Units do 50% less damage when attacking, but deal 100% more counter damage.
            Lady Luck - All attack damage is randomly selected between 50% and 150% of the normal amount.
            
        //------------------------------------------------------------------------------")
        (id "1421")
        (version "1.3.11")
        (classification "board/war/replacement/eliminate/target")
        (author "Matthew Stephenson")
        (credit "Matthew Stephenson and Eric Piette")
        }
    )
    
    (graphics {
        (player Colour P1 (colour Red))
        (player Colour P2 (colour Yellow))
        (player Colour P3 (colour Blue))
        (player Colour P4 (colour Green))
        
        (piece Colour P1 state:0 fillColour:(colour 139 0 0))
        (piece Colour P2 state:0 fillColour:(colour 155 135 12))
        (piece Colour P3 state:0 fillColour:(colour 0 77 156))
        (piece Colour P4 state:0 fillColour:(colour 0 150 0))
        
        (board Colour Phase0 (colour 208 240 192))
        (board Colour InnerEdges (colour Black))
        (board Colour OuterEdges (colour Black))
        (board Colour Symbols (colour Black))
        
        (piece Background image:"square" fillColour:(colour 255 255 255 1) edgeColour:(colour 255 255 255 1))
        (show Piece Value Top offsetImage:true valueOutline:true)
        
        <Scenario:pieceFlip>
        
        (piece Scale "Factory" 0.55)
        (piece Scale "Base" 0.55)
        (piece Scale "Town" 0.55)
        (piece Scale "Dock" 0.55)
        (piece Scale "Airport" 0.55)
        
        (piece Scale "Antiair" 0.7)
        (piece Scale "Cruiser" 0.7)
        (piece Scale "Motorbike" 0.7)
        (piece Scale "Soldier" 0.6)
        (piece Scale 0.8)
        
        <Scenario:terrainScale>
        
        (region Colour (sites Occupied by:All container:"Board" components:{"Town" "Dock" "Base" "Factory" "Airport"}) (colour 150 150 150))
        (region Colour "Forest" (colour 0 100 0))
        (region Colour "ShallowWater" (colour 174 216 230))
        (region Colour "DeepWater" (colour 28 98 216))
        (region Colour "Mountain" (colour 194 154 118))
        
        <FogOfWar:Metadata>
        
        (show Score " Gold")
        
        (piece Families {"Defined" "Fantasy"})
    })
    
    (ai
        "Mini Wars_ai"
    )
)











(define "Move"
    ("StepToEmpty" ~ (then "PostActionUpdate"))
)

(define "Shoot"
    (move Select
        (from)
        (to
            (intersection 
                (sites Occupied by:Enemy container:"Board")
                (sites Distance from:(from) (range 1 (state at:(from))))
            )
        )
        (then 
            (and
                (if	(= (value Piece at:(last To)) 1)
                    (remove (last To))
                    (set Value at:(last To) (- (value Piece at:(last To)) 1))
                )
                "PostActionUpdate"
            )
        )
    )
)

(define "Trade"
    (move Select
        (from)
        (to
            (intersection 
                (sites Occupied by:Enemy container:"Board")
                (sites Distance from:(from) (range 1 (state at:(from))))
            )
        )
        (then 
            (and
                (addScore (player (who at:(last To))) 1)
                "PostActionUpdate"
            )
        )
    )
)

(define "Upgrade"
    (move Select
        (from)
        (to)
        (then 
            (and
                (if (< (state at:(last To)) 100)
                    (set State at:(last To) (+ 1 (state at:(last To))))
                )
                "PostActionUpdate"
            )
        )
    )
)

(define "Pass"
    (move Pass
        (then
            (addScore
                Mover
                1
            )
        )
    )
)

(define "PostActionUpdate"
    (if (> (score Mover) 1)
        (and 
            (addScore
                Mover
                -1
            )
            (moveAgain)
        )
    )
)

//------------------------------------------------------------------------------

(game "Tank Tactics" 
    (players <Players:numPlayers>) 
    (equipment { 
        (board (rectangle <Board:size>)) 
        (hand Each)
        (piece "Tank" Each (or {"Move" "Shoot" "Trade" "Upgrade"}) maxState:100)
    }) 
    (rules 
        (meta (passEnd NoEnd))
        (start { 
            (set Score Each 1)
            <Players:setupRules>
        })
        phases:{
        (phase "Placement"
            (play
                (move 
                    (from (handSite Mover)) 
                    (to (sites Empty)) 
                ) 
            ) 
            (nextPhase Mover ("HandEmpty" Mover) "Movement")
        )
        (phase "Movement" 
            (play 
                (or 
                    (forEach Piece)
                    "Pass"
                )
            )
        )}
        (end 
            (forEach NonMover 
                if:(no Pieces Player) (result Player Loss)
            )
        )
    )
)

//------------------------------------------------------------------------------

(option "Number of Players" <Players> args:{<numPlayers> <setupRules>}
    {
    (item "2 Players" 
        <2> 
        <
        (place "Tank1" (handSite P1) state:2 value:3) 
        (place "Tank2" (handSite P2) state:2 value:3)
        > 
        "2 players."
    )**
    (item "3 Players" 
        <3> 
        <
        (place "Tank1" (handSite P1) state:2 value:3) 
        (place "Tank2" (handSite P2) state:2 value:3)
        (place "Tank3" (handSite P3) state:2 value:3)
        > 
        "3 players."
    )
    (item "12 Players" 
        <12> 
        <
        (place "Tank1" (handSite P1) state:2 value:3) 
        (place "Tank2" (handSite P2) state:2 value:3)
        (place "Tank3" (handSite P3) state:2 value:3)
        (place "Tank4" (handSite P4) state:2 value:3) 
        (place "Tank5" (handSite P5) state:2 value:3)
        (place "Tank6" (handSite P6) state:2 value:3)
        (place "Tank7" (handSite P7) state:2 value:3) 
        (place "Tank8" (handSite P8) state:2 value:3)
        (place "Tank9" (handSite P9) state:2 value:3)
        (place "Tank10" (handSite P10) state:2 value:3) 
        (place "Tank11" (handSite P11) state:2 value:3)
        (place "Tank12" (handSite P12) state:2 value:3)
        > 
        "12 players."
    )
    }
)

(option "Board Size" <Board> args:{ <size> }
    {
    (item "5x10" <5 10> "The game is played on a 5x10 board.")**
    (item "10x20" <10 20> "The game is played on a 10x20 board.")
})

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Inspired by a prototype game idea presented at GDC13.")
        (rules "Each player controls a tank with three health and an initial shooting range of two spaces. 
            Each player gains one action point at the start of their turn. 
            Players may use an action point during their turn to perform one of four actions:
            - Move their tank to an adjacent space.
            - Shoot at another tank within shooting range, deducting one point of health.
            - Trade with another tank within shooting range, increasing the owning players action points by one.
            - Increase the shooting range of their tank by one space.
            Players can pass to conserve action points between turns.
        A player loses if their tank reaches zero health.")
        (id "1625")
        (source "<a href=\"https://www.youtube.com/watch?v=t9WMNuyjm4w\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Youtube</a>")
        (version "1.3.11")
        (classification "board/war/replacement/eliminate/all")
        (author "Luke Muscat and Joe Gatling")
        (credit "Matthew Stephenson")
        }
    )
    
    (graphics {
        (show Piece Value CornerLeft offsetImage:true valueOutline:true)
        (show Piece State CornerRight offsetImage:true valueOutline:true)
    })
    
    (ai
        "Tank Tactics_ai"
    )
)












(define "EmptyorNext"
    (or (is Empty (to)) (= ("RightPlayer") (who at:(to)))) 
)

(define "NextCanNotMove"
    (not (can Move (do (forEach Piece Next) ifAfterwards:(not ("IsInCheck" "King" Next)))))
)

(define "CapturePiece" 
    (apply 
        (if (= ("RightPlayer") (who at:(to))) 
            (and
                (remove (to))
                (and 
                    (note player:Next "Pays into the pot" to:Next) 
                    (set Pot (+ (pot) (amount Next)))
                )
            )
        )
    )
)

(define "CaptureForwardDiagonal"
    (move Step 
        (directions {FR FL}) 
        (to 
            if:(= ("RightPlayer") (who at:(to))) 
            ("CapturePiece")
        )
    )
)

(define "PawnMove" 
    (or {
        "StepForwardToEmpty" 
        "CaptureForwardDiagonal"
        }
        (then ("PromoteIfReach" (sites #1) "Queen"))
    )
)

(define "RightPlayer" 
    (if (is Mover P1)
        (if (is Active P2)
            2
            (if (is Active P3)
                3
                4
            )
        )
        (if (is Mover P2)
            (if (is Active P3)
                3
                (if (is Active P4)
                    4
                    1
                )
            )
            (if (is Mover P3)
                (if (is Active P4)
                    4
                    (if (is Active P1)
                        1
                        2
                    )
                )
                (if (is Active P1)
                    1
                    (if (is Active P2)
                        2
                        3
                    )
                )
            )
        )
    )
)

//----------------------------------------------------------------

(game "Acedrex de los Cuatros Tiempos" 
    (players 4) 
    (equipment { 
        (board (square 8))
        (piece "King" Each
            (move
                Step 
                (to 
                    if:("EmptyorNext") 
                    ("CapturePiece")
                ) 
            )
        )
        (piece "Pawn" P1 W ("PawnMove" Left))
        (piece "Pawn3d" P1 N ("PawnMove" Top))
        
        (piece "Pawn" P2 W ("PawnMove" Left))
        (piece "Pawn3d" P2 S ("PawnMove" Bottom))
        
        (piece "Pawn" P3 E ("PawnMove" Right))
        (piece "Pawn3d" P3 S ("PawnMove" Bottom))
        
        (piece "Pawn" P4 E ("PawnMove" Right))
        (piece "Pawn3d" P4 N ("PawnMove" Top))
        
        (piece "Knight" Each
            (move Leap 
                "KnightWalk" 
                (to 
                    if:("EmptyorNext") 
                    ("CapturePiece")
                ) 
            )
        )
        (piece "Rook" Each
            (move Slide 
                Orthogonal 
                (to 
                    if:(= ("RightPlayer") (who at:(to))) 
                    ("CapturePiece")
                ) 
            )
        )
        (piece "Bishop" Each
            (move Hop 
                Diagonal 
                (between if:True) 
                (to 
                    if:("EmptyorNext") 
                    ("CapturePiece")
                ) 
            )		
        )
        (piece "Queen" Each
            (move Step 
                Diagonal
                (to 
                    if:("EmptyorNext") 
                    ("CapturePiece")
                ) 
            )	
        )
        }
    )
    (rules
        (start {
            (place "King1" coord:"H1") (place "Knight1" coord:"G1") (place "Rook1" coord:"H2") 
            (place "Bishop1" coord:"G2") (place "Pawn1" {"F1" "F2"}) (place "Pawn3d1" {"G3" "H3"})
            
            (place "King2" coord:"H8") (place "Knight2" coord:"G8") (place "Rook2" coord:"H7") 
            (place "Bishop2" coord:"G7") (place "Pawn2" {"F8" "F7"}) (place "Pawn3d2" {"H6" "G6"})
            
            (place "King3" coord:"A8") (place "Knight3" coord:"B8") (place "Rook3" coord:"A7") 
            (place "Bishop3" coord:"B7") (place "Pawn3" {"C7" "C8"}) (place "Pawn3d3" {"A6" "B6"})
            
            (place "King4" coord:"A1") (place "Knight4" coord:"B1") (place "Rook4" coord:"A2") 
            (place "Bishop4" coord:"B2") (place "Pawn4" {"C1" "C2"}) (place "Pawn3d4" {"A3" "B3"})
        })
        phases:{
        (phase "Betting" 
            (play (move Bet Mover (range 0 100)))
            (nextPhase Mover)
        )
        (phase "Playing" 
            (play
                (do
                    (forEach Piece)
                    ifAfterwards:(not ("IsInCheck" "King" Mover))
                    (then 
                        (if ("IsInCheck" "King" Next)
                            (if 
                                ("NextCanNotMove")
                                (forEach Site (sites Occupied by:Next)
                                    (and
                                        (remove (to))
                                        (and 
                                            (note player:Next "Pays into the pot" to:Next) 
                                            (set Pot (+ (pot) (amount Next)))
                                        )
                                    )
                                )
                                (and 
                                    (note player:Next "Pays into the pot" to:Next) 
                                    (set Pot (+ (pot) (amount Next)))
                                )
                            )
                        )
                    )
                )
            )
        )
        }
        (end
            (if (no Pieces Next)
                (result Next Loss)
            ) 
        )
    )
)

//----------------------------------------------------------------

(metadata
    (info
        {
        (description "Acedrex de los Cuatros Tiempos is a four-player game derived from Chess. It was described in Alofonso X of Castile's Libro de los Juegos. The four players are conceptualized as playing the four seasons, eating away at the other seasons.")
        (rules "Played on an 8x8 checkered board, with large diagonals drawn on the inner square 4x4 spaces. Four players, seated, from top left, anti-clockwise: red, black, white, green. Each player has four pawns, a knight, a fil, a rook, and a king. The kings begin in the corner space, with the knight to the adjacent square in the row with the king, the rook in the square in the column adjacent to the king, and the fil in the remaining 2x2 square in the corner. The pawns are placed on the orthogonally adjacent squares to this formation. Pieces move as follows: King: One square in any direction. Knight: As a knight in Chess. Rook: Orthogonally any number of spaces. Fil: moves diagonally two spaces, jumping over any piece in the intervening square. Pawns: move forward along the direction of their nearest edge, but capture diagonally forward. Upon reaching the opposite edge of the board, pawns are immediately promoted to \"Fers,\" which moves diagonally one space in any direction. Pieces are taken by moving onto a space occupied by an enemy piece. Kings cannot be in check at the end of their turn, if this is not possible the king is checkmated and that player loses. Each player makes an opening bet. Any time a player loses a piece or their king is placed in check, they must pay into the pot. When a player's king is checkmated, they must pay into the pot for their remaining pieces, and all their pieces are removed from the board. Each player may capture only the pieces of the player to their right. As players are eliminated, the targeted player is changed accordingly.")
        (source "Libro de los Juegos 87-89.")
        (id "313")
        (version "1.3.11")
        (classification "board/war/replacement/checkmate/chess")
        (credit "Eric Piette")
        }
    )
    
    (graphics {
        (board Style Chess)
        (player Colour P1 (colour Green))
        (player Colour P2 (colour Red))
        (player Colour P3 (colour VeryDarkGrey))
        (player Colour P4 (colour White))
        (show Line { {20 60}} (colour 250 221 144) scale:4.0)
        (show Line { {56 24}} (colour 200 150 75) scale:4.0)
    })
    
    (ai
        "Acedrex de los Cuatros Tiempos_ai"
    )
)













(define "InitHand" 
    (place #1 (handSite #2) state:0) 
    (place #1 (handSite #2 1) state:1) 
    (place #1 (handSite #2 2) state:2) 
    (place #1 (handSite #2 3) state:3) 
    (place #1 (handSite #2 4) state:4) 
    (place #1 (handSite #2 5) state:5) 	
)
(define "SumFingers" <Players:sumFingers>)
(define "MaxFingers" (* 5 (count Players)))
(define "ShowHand" 
    (move 
        (from (sites Occupied by:#1)) 
        (to (- (id #1) 1)) 
        copy:True
        #1
        (then 
            (if (= "SumFingers" (amount #1))
                (addScore #1 1)
            )
            applyAfterAllMoves:True
        )
    )
)

//-------------------------------------------------------------------------

(game "Morra" 
    (players <Players:num>) 
    
    (mode Simultaneous) 
    
    (equipment { 
        <Players:board>
        (hand Each size:6) 
        (hand Shared)
        (piece "Hand0" Each)
    }) 
    
    (rules 
        (start { 
            ("InitHand" "Hand01" P1)
            ("InitHand" "Hand02" P2)
            <Players:initP3>
        })
        
        phases:{
        (phase "Bet" 
            (play 
                (or {
                    (move Bet P1 (range 0 ("MaxFingers")) (then (set Pot (+ (pot) (amount P1)))))
                    (move Bet P2 (range 0 ("MaxFingers")) (then (set Pot (+ (pot) (amount P2)))))
                    <Players:betP3>
                })
            )
            (nextPhase "Hand")
        )
        
        (phase "Hand" 
            (play 
                (or {
                    ("ShowHand" P1)
                    ("ShowHand" P2)
                    <Players:showHandP3>
                })
            )
            (nextPhase "Observe")
        )
        
        (phase "Observe" 
            (play 
                (move 
                    Pass 
                    (then 
                        (and {
                            (remove 0) 
                            (remove 1)
                            <Players:removeP3>
                        })
                    )
                )
            )
            (nextPhase "Bet")
        )
        }
        
        (end 
            (if 
                (or {
                    (= (score P1) 3) 
                    (= (score P2) 3)
                    <Players:endP3>
                }) 
                (byScore)
            )
        ) 
    )
)

//-------------------------------------------------------------------------

(option "Players" <Players> args:{ <num> <board> <sumFingers> <initP3> <betP3> <showHandP3> <removeP3> <endP3>}
    {
    (item "2" 
        <2>
        <(board 
            (union 
                (square 1) 
                (shift 0 2 (square 1))
            )
        )>
        <(+ (state at:0) (state at:1))>
        <>
        <>
        <>
        <>
        <>
    "The game is played with 2 players.")* 
    
    (item "3" 
        <3> 
        <(board 
            (union 
                {
                (square 1) 
                (shift -1 2 (square 1)) 
                (shift 1 2 (square 1))
                }
            )
        )>
        <(+ {(state at:0) (state at:1) (state at:2)})>
        <("InitHand" "Hand03" P3)>
        <(move Bet P3 (range 0 ("MaxFingers")) (then (set Pot (+ (pot) (amount P3)))))>
        <("ShowHand" P3)>
        <(remove 2)>
        <(= (score P3) 3)>
    "The game is played with 3 players.") 
})

//-------------------------------------------------------------------------

(metadata
    
    (info
        {
        (description "Morra is a hand game of uncertain history from the Mediterranean region.")
        (rules "Each player simultaneously bets on what the sum of all fingers shown will be. Each bet is added to a common pot. Then each player simultaneously reveals their hand, extending any number of fingers. Any player who successfully guesses the total number of fingers revealed by all players combined scores a point.
        The game is over when a player reaches a score of 3. The winning players share the pot.")
        (source "https://en.wikipedia.org/wiki/Morra_(game)")
        (id "600")
        (version "1.3.11")
        (classification "math/hand")
        (credit "Eric Piette")
        }
    )
    
    (graphics {
        (player Colour P1 (colour HumanLight))
        (player Colour P2 (colour HumanDark))
        (piece Rotate P2 degrees:180)
        (piece AddStateToName)
        (no Board)
    })
    
)

(game "Tower of Hanoi" 
    (players 1) 
    (equipment { 
        (board (rectangle 1 3)) 
        <Version:pieces>
    }) 
    (rules
        (start {
            <Version:start>
        }) 
        (play ("MoveToEmptyOrOccupiedByLargerPiece" (sites Occupied by:Mover)))
        
        (end {
            (if 
                (is Target {<Version:order>} 2) 
                (result P1 Win) 
            )
            (if 
                (= (count Moves) <Version:limit>) 
                (result P1 Loss) 
            )
        })
    )
)

//------------------------------------------------------------------------------

(option "Stack Size" <Version> args:{ <pieces> <start> <order> <limit>}
    {
    (item "2x2 (3 moves)" 
        <
        (piece "Counter4" P1)
        (piece "Counter9" P1)
        >
        <
        (place Stack items:{"Counter9" "Counter4"} 0)
        >
        <2 1>
        <3>
        ""
    )
    
    (item "3x3 (7 moves)" 
        <
        (piece "Counter3" P1)
        (piece "Counter6" P1)
        (piece "Counter9" P1)
        >
        <
        (place Stack items:{"Counter9" "Counter6" "Counter3"} 0)
        >
        <3 2 1>
        <7>
        ""
    )**
    
    (item "4x4 (15 moves)" 
        <
        (piece "Counter3" P1)
        (piece "Counter5" P1)
        (piece "Counter7" P1)
        (piece "Counter9" P1)
        >
        <
        (place Stack items:{"Counter9" "Counter7" "Counter5" "Counter3"} 0)
        >
        <4 3 2 1>
        <15>
        ""
    )
    
    (item "5x5 (31 moves)" 
        <
        (piece "Counter1" P1)
        (piece "Counter3" P1)
        (piece "Counter5" P1)
        (piece "Counter7" P1)
        (piece "Counter9" P1)
        >
        <
        (place Stack items:{"Counter9" "Counter7" "Counter5" "Counter3" "Counter1"} 0)
        >
        <5 4 3 2 1>
        <31>
        ""
    )
    
    (item "6x6 (63 moves)" 
        <
        (piece "Counter1" P1)
        (piece "Counter2" P1)
        (piece "Counter3" P1)
        (piece "Counter5" P1)
        (piece "Counter7" P1)
        (piece "Counter9" P1)
        >
        <
        (place Stack items:{"Counter9" "Counter7" "Counter5" "Counter3" "Counter2" "Counter1"} 0)
        >
        <6 5 4 3 2 1>
        <63>
        ""
    )
    
    (item "7x7 (127 moves)" 
        <
        (piece "Counter1" P1)
        (piece "Counter2" P1)
        (piece "Counter3" P1)
        (piece "Counter5" P1)
        (piece "Counter7" P1)
        (piece "Counter8" P1)
        (piece "Counter9" P1)
        >
        <
        (place Stack items:{"Counter9" "Counter8" "Counter7" "Counter5" "Counter3" "Counter2" "Counter1"} 0)
        >
        <7 6 5 4 3 2 1>
        <127>
        ""
    )
    
    (item "8x8 (255 moves)" 
        <
        (piece "Counter1" P1)
        (piece "Counter2" P1)
        (piece "Counter3" P1)
        (piece "Counter4" P1)
        (piece "Counter6" P1)
        (piece "Counter7" P1)
        (piece "Counter8" P1)
        (piece "Counter9" P1)
        >
        <
        (place Stack items:{"Counter9" "Counter8" "Counter7" "Counter6" "Counter4" "Counter3" "Counter2" "Counter1"} 0)
        >
        <8 7 6 5 4 3 2 1>
        <255>
        ""
    )
    
    (item "9x9 (511 moves)" 
        <
        (piece "Counter1" P1)
        (piece "Counter2" P1)
        (piece "Counter3" P1)
        (piece "Counter4" P1)
        (piece "Counter5" P1)
        (piece "Counter6" P1)
        (piece "Counter7" P1)
        (piece "Counter8" P1)
        (piece "Counter9" P1)
        >
        <
        (place Stack items:{"Counter9" "Counter8" "Counter7" "Counter6" "Counter5" "Counter4" "Counter3" "Counter2" "Counter1"} 0)
        >
        <9 8 7 6 5 4 3 2 1>
        <511>
        ""
    )
    }
)

(metadata
    
    (info
        {
        (description "Tower of Hanoi was invented by Ã‰douard Lucas in 1883. The game equipment consists of three rods in a row and a series of disks of different sizes which fit on the rods.")
        (aliases {"Tower of Brahma" "Lucas' Tower" "Towers of Hanoi"})
        (rules "A player moves one disk at a time to an empty rod or on a rod where it rests on a larker disk. The goal is to place all of the disks on one rod in decreasing size with the largest on the bottom and the smallest on top.")
        (source "<a href=\"https://en.wikipedia.org/wiki/Tower_of_Hanoi\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (id "125")
        (version "1.3.11")
        (classification "puzzle/planning")
        (credit "Eric Piette")
        (date "1883")
        }
    )
    
    (graphics {
        (player Colour P1 (colour HumanLight))
        (player Colour P2 (colour Brown))
        (piece Scale "Counter1" 0.2)
        (piece Scale "Counter2" 0.3)
        (piece Scale "Counter3" 0.4)
        (piece Scale "Counter4" 0.5)
        (piece Scale "Counter5" 0.6)
        (piece Scale "Counter6" 0.7)
        (piece Scale "Counter7" 0.8)
        (piece Scale "Counter8" 0.9)
        (piece Scale "Counter9" 1.0)
        (stackType None)
        (piece Families {"Defined" "Isometric"})
    })
    
)










(game "Quarto"
    (players 2)
    (equipment {
        (board (square 4) use:Vertex)
        (piece "Disc" Each)
        (piece "Square" Each)
        (hand Shared size:16)
    })
    (rules 
        (start {
            (place "Disc1" (handSite Shared 0))
            (place "Disc1" (handSite Shared 1) value:1)
            (place "Disc1" (handSite Shared 2) state:1)
            (place "Disc1" (handSite Shared 3) state:1 value:1)
            (place "Disc2" (handSite Shared 4))
            (place "Disc2" (handSite Shared 5) value:1)
            (place "Disc2" (handSite Shared 6) state:1)
            (place "Disc2" (handSite Shared 7) state:1 value:1)
            (place "Square1" (handSite Shared 8))
            (place "Square1" (handSite Shared 9) value:1)
            (place "Square1" (handSite Shared 10) state:1)
            (place "Square1" (handSite Shared 11) state:1 value:1)
            (place "Square2" (handSite Shared 12))
            (place "Square2" (handSite Shared 13) value:1)
            (place "Square2" (handSite Shared 14) state:1)
            (place "Square2" (handSite Shared 15) state:1 value:1)
        })
        phases:{
        (phase "Select" 
            (play 
                (move Select 
                    (from 
                        Cell
                        (difference 
                            (sites Hand Shared) 
                            (sites Empty 1)
                        )
                    )
                )
            )
            (nextPhase "Place")
        )
        (phase "Place" 
            (play
                (move 
                    (from Cell (last From))
                    (to (sites Empty))
                    (then (moveAgain))
                )
            )
            (end { 
                // Shape line (what)
                (if (is Line 4 All whats:{(id "Disc" P1) (id "Disc" P2)}) (result Mover Win))
                (if (is Line 4 All whats:{(id "Square" P1) (id "Square" P2)}) (result Mover Win))
                
                // Colour line (who)
                (if (is Line 4 All P1) (result Mover Win))
                (if (is Line 4 All P2) (result Mover Win))
                
                // State line (state)
                (if (is Line 4 All whats:{(id "Disc" P1) (id "Disc" P2) (id "Square" P1) (id "Square" P2)} if:(= 0 (state at:(to)))) (result Mover Win))
                (if (is Line 4 All whats:{(id "Disc" P1) (id "Disc" P2) (id "Square" P1) (id "Square" P2)} if:(= 1 (state at:(to)))) (result Mover Win))
                
                // Value line (value)
                (if (is Line 4 All whats:{(id "Disc" P1) (id "Disc" P2) (id "Square" P1) (id "Square" P2)} if:(= 0 (value Piece at:(to)))) (result Mover Win))
                (if (is Line 4 All whats:{(id "Disc" P1) (id "Disc" P2) (id "Square" P1) (id "Square" P2)} if:(= 1 (value Piece at:(to)))) (result Mover Win))
            })
            (nextPhase "Select")
        )
        }
    )
)

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Quarto has a 4Ã—4 board and 16 pieces. Each piece has four dichotomous attributes â€“ color, height, shape, and consistency â€“ so each piece is either black or white, tall or short, square or round, and hollow or solid.")
        (rules "Each piece has four dichotomous attributes â€“ color, height, shape, and consistency â€“ so each piece is either black or white, tall or short, square or round, and hollow or solid. The object is to place the fourth piece in a row in which all four pieces have at least one attribute in common. The twist is that your opponent gets to choose the piece you place on the board each turn.")
        (id "1536")
        (source "<a href=\"https://boardgamegeek.com/boardgame/681/quarto\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />BGG</a>")
        (version "1.3.11")
        (classification "board/space/line")
        (author "Blaise Muller")
        (publisher "<a href=\"https://www.gigamic.com/\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Gigamic</a> (used with permission)")
        (credit "Eric Piette")
        (date "1991")
        }
    )
    
    (graphics {
        (piece Scale "Disc" 0.7)
        (piece Scale "Square" 0.7)
        (piece Foreground state:1 image:"Disc" fillColour:(colour Hidden) edgeColour:(colour Orange) scale:0.5)
        (piece Foreground value:1 image:"Square" fillColour:(colour Hidden) edgeColour:(colour Orange) scale:0.3)
        
        (show Edges Hidden)
        (show Symbol "Disc" (sites Board) fillColour:(colour 185 130 85) edgeColour:(colour 225 182 130)) 
        (board Placement scale:0.8)
        (board Background image:"square.svg" fillColour:(colour 185 130 85) edgeColour:(colour 185 130 85) scale:1.45)
    })
    
    (ai
        "Quarto_ai"
    )
)











(game "Atoll"
    (players 2)
    (equipment {
        (board 
            (remove
                (rotate 90 (hex Rectangle 13 12))
                cells:{138 139 148 149 0 1 10 11 69 80}
            )
        )
        (piece "Marker" Each)
    })
    (rules
        (start {
            (place "Marker1" (sites {132 133 134 135 131 120 108 97 85 7 6 5 4 8 19 31 42 54}))
            (place "Marker2" (sites {136 137 138 139 64 53 41 30 18 3 2 1 0 121 109 98 86 75}))
        })
        (play (move Add (to (sites Empty))))
        (end 
            (if (is Mover P1)
                {
                (if (or 
                        (is Connected {(sites {132..135}) (sites {4..7})}) 
                        (is Connected {(sites {131 120 108 97 85}) (sites {54 42 31 19 8})}) 
                    )
                    (result Mover Win)
                )
                (if (or 
                        (is Connected {(sites {121 109 98 86 75}) (sites {64 53 41 30 18})}) 
                        (is Connected {(sites {136..139}) (sites {0..3})}) 
                    )
                    (result Mover Win)
                )
                }
            )
        )
    )
)

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Atoll is a two player game played on a hexagonal pattern grid. The game starts with eight â€œislandsâ€ of stones surrounding an empty grid. Each player takes possession of an entire set of stones of one color, black or white. Each player owns the islands of his stonesâ€™ color. ")
        (rules "STONE PLACEMENT Players take turns adding their stones to the board, one stone per turn. Black makes the first placement of the game. Each player will always have a placement available on his turn and must
            make one.
            
        OBJECT OF THE GAME To win you must connect two of your islands, which are exactly opposite each other, with a contiguous sequence of your stones. The stones of your islands can be included in the sequence. ")
        (id "1767")
        (source "<a href=\"http://www.marksteeregames.com/Atoll_rules.pdf\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />www.marksteeregames.com</a>")
        (version "1.3.11")
        (classification "board/space/connection")
        (author "Mark Steere")
        (publisher "<a href=\"http://www.marksteeregames.com/Atoll_rules.pdf\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />www.marksteeregames.com</a>")
        (credit "Eric Piette")
        (date "01-2008")
        }
    )
    
    (ai
        "Atoll_ai"
    )
)










(define "CellOfLastEdge" 
    (sites Incident Cell of:Edge at:(last To)) 
)

(define "NoFreeEdge" 
    ("NoSites" 
        (intersection 
            (sites Incident Edge of:Cell at:(site)) 
            (sites Empty Edge) 
        ) 
    ) 
)

(define "CaptureTheCell" 
    (claim
        (to
            Cell 
            (site) 
        )
        (then 
            (and 
                (addScore Mover 1) 
                (moveAgain)
            )
        )
    ) 
)

(define "HalfBoardSize" (/ (count Cells) 2))

//------------------------------------------------------------------------------

(game "Dots and Boxes" 
    (players 2)
    (equipment {(board <Dual:begin> (<Board> <Size>) <Dual:end>) }) 
    
    (rules 
        (play (move Add 
                (to Edge (sites Empty Edge)) 
                (then 
                    (forEach Site
                        "CellOfLastEdge" 
                        (if "NoFreeEdge"
                            "CaptureTheCell"
                        )
                    )
                )
            )
        ) 
        (end (if (> (score Mover) "HalfBoardSize") (result Mover <Result>))) 
    )
)

//------------------------------------------------------------------------------

(option "Board" <Board> args:{<type>}
    {
    (item "Square" <square> "The board uses a square tiling.")**
    (item "Diamond Square" <square Diamond> "The diamond board uses a square tiling.")
    (item "Hexagon" <hex> "The board uses a hexagon tiling.") 
    (item "Square Hexagon" <hex Square> "The square board uses a hexagon tiling.") 
    (item "Diamond Hexagon" <hex Diamond> "The diamond board uses a hexagon tiling.") 
    (item "Triangle Hexagon" <hex Triangle> "The triangle board uses a hexagon tiling.") 
    (item "Star Hexagon" <hex Star> "The star board uses a hexagon tiling.") 
    (item "Limping Hexagon" <hex Limping> "The limping board uses a hexagon tiling.")
    (item "Triangle" <tri> "The board uses a triangle tiling.") 
    (item "Hexagon Triangle" <tri Hexagon> "The hexagonal board uses a triangle tiling.")
    (item "Diamond Triangle" <tri Diamond> "The diamond board uses a triangle tiling.") 
    (item "Square Triangle" <tri Square> "The square board uses a triangle tiling.") 
    (item "Star Triangle" <tri Star> "The star board uses a triangle tiling.") 
    (item "Limping Triangle" <tri Limping> "The limping board uses a triangle tiling.") 
    (item "Celtic" <celtic> "The board uses a celtic tiling.")  
    (item "Brick" <brick> "The board uses a brick tiling.") 
    (item "Diamond Brick" <brick Diamond> "The diamond board uses a brick tiling.") 
    (item "Spiral Brick" <brick Spiral> "The spiral board uses a brick tiling.") 
    (item "Limping Brick" <brick Limping> "The limping board uses a brick tiling.")  
    (item "Quadhex" <quadhex> "The board uses a quadhex tiling.")  
    (item "Tiling 31212" <tiling T31212> "The board uses a tiling 31212.")  
    (item "Tiling 333333_33434" <tiling T333333_33434> "The board uses a tiling 333333_33434.")  
    (item "Tiling 33336" <tiling T33336> "The board uses a tiling 33336.")  
    (item "Tiling 33344" <tiling T33344> "The board uses a tiling 33344.")  
    (item "Tiling 3464" <tiling T3464> "The board uses a tiling 3464.")  
    (item "Tiling 3636" <tiling T3636> "The board uses a tiling 3636.")  
    (item "Tiling 4612" <tiling T4612> "The board uses a tiling 4612.")  
    (item "Tiling 488" <tiling T488> "The board uses a tiling 488.")  
    }
)

(option "Board Size" <Size> args:{ <size> }
    {
    (item "3x3" <3> "The game is played on a 3x3 board.") 
    (item "4x4" <4> "The game is played on a 4x4 board.") 
    (item "5x5" <5> "The game is played on a 5x5 board.") 
    (item "6x6" <6> "The game is played on a 6x6 board.") 
    (item "7x7" <7> "The game is played on a 7x7 board.") 
    (item "8x8" <8> "The game is played on a 8x8 board.")** 
    (item "9x9" <9> "The game is played on a 9x9 board.") 
    (item "10x10" <10> "The game is played on a 10x10 board.") 
    (item "11x11" <11> "The game is played on a 11x11 board.") 
    (item "12x12" <12> "The game is played on a 12x12 board.") 
    (item "13x13" <13> "The game is played on a 13x13 board.") 
    (item "14x14" <14> "The game is played on a 14x14 board.") 
    (item "15x15" <15> "The game is played on a 15x15 board.") 
})

(option "Dual" <Dual> args:{<begin> <end>}
    {
    (item "No" <> <> "")**
    (item "Yes" <(dual > <)> "The dual of the board is applied.")
    }
)

(option "End Rules" <Result> args:{ <type> }
    {
    (item "Standard" <Win>  "The first player capture half the cells wins.")* 
    (item "Misere" <Loss>  "The first player capture half the cells loses.") 
})

//------------------------------------------------------------------------------

(metadata
    
    (info
        {
        (description "Dots and Boxes was invented in the nineteenth century by Ã‰douard Lucas, calling it \"la Pipopipette.\" It is a pen-and-paper game that is sometimes adapted into other forms.")
        (aliases {"La Pipopipette"})
        (rules "It is played on a board that is a grid of dots. 3x3 dots is common. Players alternate turns drawing a line between two of the dots. If a player completes a square, they receive one point and play again. The player with the most points when there are no more moves wins.")
        (source "<a href=\"https://en.wikipedia.org/wiki/Dots_and_Boxes\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (id "103")
        (version "1.3.11")
        (classification "math/graph")
        (author "Ã‰douard Lucas")
        (credit "Eric Piette")
        (date "1889")
        }
    )
    
    (graphics {
        (player Colour P1 (colour Red))
        (player Colour P2 (colour Blue))
        (board Style PenAndPaper replaceComponentsWithFilledCells:True)
    })
    (ai
        "Dots and Boxes_ai"
    )
)







(define "DiagonalNESW"
    (union (sites Direction from:(last To) NE included:True) (sites Direction from:(last To) SW))
)

(define "DiagonalSENW"
    (union (sites Direction from:(last To) SE included:True) (sites Direction from:(last To) NW))
)

//------------------------------------------------------------------------------

(game "Diagonals"
    (players 2)
    (equipment {
        (board (square 8) use:Vertex)
        (piece "Ball" Each)
    })
    (rules
        (play 
            (move Add (to (sites Empty))
                (then
                    (and
                        (if (not (is In (last To) (sites {"A8" "H1"})))
                            (if (all Sites ("DiagonalNESW") if:(is Occupied (site)))
                                (addScore Mover (count Sites in:(forEach ("DiagonalNESW") if:("IsFriendAt" (site)))))
                            )
                        )
                        (if (not (is In (last To) (sites {"A1" "H8"})))
                            (if (all Sites ("DiagonalSENW") if:(is Occupied (site)))
                                (addScore Mover (count Sites in:(forEach ("DiagonalSENW") if:("IsFriendAt" (site)))))
                            )
                        )
                    )
                )
            )
        )
        (end (if (is Full) (byScore))) 
    )
)

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "A scoring game involving diagonals of the board.")
        (rules "TURN - On each turn, each player drops a friendly stone on an empty cell. If a diagonal line is full (i.e., there are no empty cells on that diagonal), the player who dropped the last stone achieves so many points as the number of friendly stones on the finished line.
            
            Two lines can be finished on one turn, the player achieves points for both lines (the dropped stone counts twice, once for each diagonal).
            A diagonal line must have at least 2 stones. So, corner cells do not count as diagonals.
            
        GOAL - When all cells are occupied, wins the player with more points.")
        (id "1803")
        (source "<a href=\"http://www.di.fc.ul.pt/~jpn/gv/diagonals.htm\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />www.di.fc.ul.pt</a>")
        (version "1.3.11")
        (classification "board/race/score")
        (credit "Eric Piette")
        }
    )
    
    (graphics {
        (show Edges Diagonal (colour Hidden))
        (board Background image:"square.svg" fillColour:(colour 223 178 110) edgeColour:(colour 223 178 110) scale:1.25)
        (board Colour OuterEdges (colour Black))
        (board Colour InnerEdges (colour Black))
        (board Colour OuterVertices (colour Hidden))
        (board Colour InnerVertices (colour Hidden))
        (show Symbol "disc" (sites Corners) fillColour:(colour Black) edgeColour:(colour Black) scale:0.3)
    })
    
    (ai
        "Diagonals_ai"
    )
)













(game "Gonnect" 
    (players 2) 
    (equipment { 
        (board <Board> use:Vertex) 
        (piece "Marker" Each)
        (regions P1 {(sites Side N) (sites Side S) })
        (regions P2 {(sites Side W) (sites Side E) })
    })
    
    (rules 
        (meta {
            (swap)
            (no Repeat)
        })
        (play 
            (do
                (move Add
                    (to (sites Empty))
                    (then ("EncloseCapture" Orthogonal))
                )
                ifAfterwards:("HasFreedom" Orthogonal)
            )
        )
        
        (end {
            (if (is Connected Mover) (result Mover Win))
            ("BlockWin")
        }) 
    )
)

//------------------------------------------------------------------------------

(option "Board Size" <Board> args:{ <size> }
    {
    (item "9x9"  <(square 9)>  "The game is played on a 9x9 board") 
    (item "13x13" <(square 13)> "The game is played on a 13x13 board")** 
    (item "15x15" <(square 15)> "The game is played on a 15x15 board") 
    (item "19x19" <(square 19)> "The game is played on a 19x19 board") 
})

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Gonnect was invented by JoÃ£o Pedro Neto in 2000. It is played with a Go board and pieces, with the goal of creating a group that connects two opposite sides of the board.")
        (rules "All the rules of Go apply, except that passing is not allowed. A player loses if he has no legal move. A player wins if they successfully connect two opposite sides of the board.")
        (source "<a href=\"https://en.wikipedia.org/wiki/Gonnect\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (id "467")
        (version "1.3.11")
        (classification "board/space/connection")
        (author "JoÃ£o Pedro Neto")
        (credit "Eric Piette")
        (date "2000")
        }
    )
    
    (graphics {
        (board Style Go)
        (player Colour P1 (colour Black))
        (player Colour P2 (colour White))
    })
    
    (ai 
        "Gonnect_ai"
    )
    
)





(game "Hex" 
    (players 2) 
    (equipment { 
        (board (hex Diamond <Board>)) 
        (piece "Marker" Each)
        (regions P1 {(sites Side NE) (sites Side SW) })
        (regions P2 {(sites Side NW) (sites Side SE) })
    }) 
    (rules 
        <Meta:rule>
        (play (move Add (to (sites Empty))))
        (end (if (is Connected Mover) (result Mover <Result>))) 
    )
)

//------------------------------------------------------------------------------

(option "Board Size" <Board> args:{ <size> } {
    (item "3x3" <3> "The game is played on a 3x3 board.") 
    (item "4x4" <4> "The game is played on a 4x4 board.") 
    (item "5x5" <5> "The game is played on a 5x5 board.") 
    (item "6x6" <6> "The game is played on a 6x6 board.") 
    (item "7x7" <7> "The game is played on a 7x7 board.") 
    (item "8x8" <8> "The game is played on a 8x8 board.") 
    (item "9x9" <9> "The game is played on a 9x9 board.") 
    (item "10x10" <10> "The game is played on a 10x10 board.")* 
    (item "11x11" <11> "The game is played on a 11x11 board.")** 
    (item "12x12" <12> "The game is played on a 12x12 board.") 
    (item "13x13" <13> "The game is played on a 13x13 board.") 
    (item "14x14" <14> "The game is played on a 14x14 board.")* 
    (item "15x15" <15> "The game is played on a 15x15 board.") 
    (item "16x16" <16> "The game is played on a 16x16 board.") 
    (item "17x17" <17> "The game is played on a 17x17 board.")* 
    (item "18x18" <18> "The game is played on a 18x18 board.") 
    (item "19x19" <19> "The game is played on a 19x19 board.") 
})

(option "Swap Rules" <Meta> args:{ <rule>} {
    (item "On" <(meta (swap))> "The game uses the swap rule.")* 
    (item "Off" <> "The game does not use the swap rule.") 
})

(option "End Rules" <Result> args:{ <type>} {
    (item "Standard" <Win> "The first player to connect their two sides wins.")* 
    (item "Misere" <Loss> "The first player to connect their two sides loses.") 
})

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Hex was invented by Piet Hein in 1942 then described again by John Nash in 1944. It is played on a rhombus tiled by hexagons, most commonly 11x11 in size.")
        (rules "Players take turns placing a piece of their colour at an empty cell, and win by connecting their board sides with a chain of their pieces.")
        (source "<a href=\"https://en.wikipedia.org/wiki/Hex_(board_game)\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (id "82")
        (version "1.3.11")
        (classification "board/space/connection")
        (credit "Eric Piette")
        (date "1942")
        }
    )
    
    (graphics {
        (player Colour P1 (colour Red))
        (player Colour P2 (colour Blue))
        (board Colour Phase0 (colour VeryLightGrey))
        (board Style ConnectiveGoal)
    })
    
    (ai 
        "Hex_ai"
    )
    
)


















// Polypods 
//---------------------------------------------
// Utility for determining if a group is alive   
(define "IsAliveAt" // <region>
    (<= 0
        (+
            (results
                from:#1 
                to:(from)
                (if (!= 1 (state at:(to))) 1 (- 1))
            )
        )
    )
)

//----------------------------------  
// Capture Locations and procedure

(define "CaptureSites" 
    // i.e. opponent foot occupied sites that are next to the body sites of the group that includes the last placement
    (intersection
        (sites Around (intersection (sites Group at:(last To)) (sites State 1)))
        (difference (sites Occupied by:Next) (sites State 1))
    )
)

(define "KeySitesOfAffectedGroups"
    (sites
        (results
            from:"CaptureSites"
            to:(min (array (difference (sites Group at:(from)) "CaptureSites")))
            (to)
        )
    )
)

(define "AffectedGroupAt"  // The updated group without captured terminals associated with the key location.
    (difference (sites Group at:#1) (sites (values Remembered "CS")))
)

(define "Check4IllegalCapture"
    (and {
        ("UpdateTerminals" (sites Group at:(var "ConvertedFootSite"))) 
        }
        (then
            (if
                //work around: using  (last To) did not pick up the last consequence, but rather the last move
                (not ("IsAliveAt" (sites Group at:(var "ConvertedFootSite"))))
                (trigger "IllegalCapture" Mover)
            )
        )
    )
)

(define "ClaimCapture" // site
    (if 
        (= 1 (state at:(site)))
        (remove (site))
        (add
            (to (site)
                (apply
                    (and
                        (set Var "ConvertedFootSite" (to))
                        (remove (to))
                    )
                )
            )
            (then ("Check4IllegalCapture"))
        )
    )
)

//-------------------------------

(define "Captures"
    (do
        (forEach Site "CaptureSites"
            (remember Value "CS" (site) unique:True)
            (then
                (forEach Site "KeySitesOfAffectedGroups"
                    (remember Value "KS" (site) unique:True)
                )
            )
        )
        next:(forEach Site (sites (values Remembered "CS")) (remove (site))
            (then
                (forEach Value
                    (values Remembered "KS")  // a key site within the remainder of the group
                    ("UpdateTerminals" ("AffectedGroupAt" (value)))
                )
            )
        )
        (then 
            (and
                (forEach Value (values Remembered "KS")  
                    (if 
                        (not ("IsAliveAt" ("AffectedGroupAt" (value))))
                        (forEach Site
                            ("AffectedGroupAt" (value)) 
                            ("ClaimCapture") 
                        )
                    )
                )
                (forget Value "CS" All
                    (then (forget Value "KS" All))
                )
            )
        )
    )
)

//---------------------------------------------
// Updating Group structures 

(define "SurroundingSitesInGroup"
    (array (intersection #1 (sites Around (site))))
)

(define "UpdateTerminals"
    (if
        (= 6 (count Sites in:(sites Corners)))
        ("UpdateTerminalsHex" #1)
        ("UpdateTerminalsSquareOriented" #1)
))

(define "UpdateTerminalsHex"  // <region> such as (sites) or (sites Group at:(last To))
    (forEach Site #1
        (if
            (or
                (< 2 (size Array ("SurroundingSitesInGroup" #1)))
                (and
                    (= 2 (size Array ("SurroundingSitesInGroup" #1)))
                    (< 1 
                        (count Steps 
                            (min ("SurroundingSitesInGroup" #1))
                            (max ("SurroundingSitesInGroup" #1))
                        )
                    )
                )
            )
            (set State at:(site) 1)
            (set State at:(site) 0)
        )
    )
)

(define "UpdateTerminalsSquareOriented"  // <region> such as (sites) or (sites Group at:(last To))
    (forEach Site #1
        (if
            (< 1 (size Array ("SurroundingSitesInGroup" #1)))
            (set State at:(site) 1)
            (if
                (is Within (what at:(site)) in:(sites Around (site) N))
                (set State at:(site) 2)
                (if
                    (is Within (what at:(site)) in:(sites Around (site) E))
                    (set State at:(site) 3)
                    (if
                        (is Within (what at:(site)) in:(sites Around (site) S))
                        (set State at:(site) 4)
                        (if
                            (is Within (what at:(site)) in:(sites Around (site) W))
                            (set State at:(site) 5)
                            (set State at:(site) 0)
                        )
                    )
                )
            )
        )
    )
)

//--------------------------------
// Placement

(define "ToAllowedSites"
    (to
        (difference
            (sites Empty)
            (sites Around
                (intersection (sites Occupied by:Next) (sites State 1))
            )
        )
        //  level:0
    )
)

//-----------------------------------------------
// Main routine

(game "Polypods"
    (players 2)
    (equipment {
        (board <BoardShape:gridType> use:Vertex)
        (piece "Disc" Each maxState:1 maxValue:4)
    })
    (rules
        (play
            (or
                (move Pass)
                (do
                    (do
                        (move Add "ToAllowedSites" 
                            (then
                                (and
                                    (set Value at:(last To) (layer of:(last To)))
                                    ("UpdateTerminals" (sites Group at:(last To)))
                                )
                            )
                        )
                        ifAfterwards:("IsAliveAt" (sites Group at:(last To)))
                        (then ("Captures"))
                    )
                    ifAfterwards:(not (is Triggered "IllegalCapture" Mover))
                )
                (then 
                    ("Score")
                )
            )
        )
        (end 
            (if
                (all Passed) {
                (if
                    (> (score Mover) (score Next))
                    (result Mover Win)
                )
                (if
                    (and
                        (= (score Mover) (score Next))
                        (>= ("FringeScoreOf" Mover) ("FringeScoreOf" Next))
                    )
                    (result Mover Win)
                )
                (if
                    (and
                        (= (score Mover) (score Next))
                        (= ("FringeScoreOf" Mover) ("FringeScoreOf" Next))
                    )
                    (result Mover Draw)
                )
                }
                (result Next Win)
            )
        )
    )
)

//-----------------------------
//Scoring

(define "Score"
    (and
        ("ScoreCore4" Mover)
        ("ScoreCore4" Next)
))

(define "ScoreFringe4" (set Score #1 ("FringeScoreOf" #1)))

(define "ScoreCore4"
    (set Score #1
        (count Sites 
            in:(intersection
                (sites Occupied by:#1) 
                (sites State 1)
            )
        )
    )
)

(define "FringeScoreOf"
    (count Sites
        in:(difference
            (sites Around (sites Occupied by:#1))
            (sites Around (difference (sites Occupied by:All) (sites Occupied by:#1)) includeSelf:True)
        )
    )
)

//-------------------------------------------------
// Options

(option "Board" <BoardShape> args:{<gridType> <directionsUsed> <graphsOption> } 
    {
    (item "Square 4-7" <(rectangle 4 7)> <Orthogonal> <("Graphics")> "Order 5 Square Grid")*
    (item "Square 5-6" <(rectangle 5 6)> <Orthogonal> <("Graphics")> "Order 5 Square Grid")
    (item "Square 5-7" <(rectangle 5 7)> <Orthogonal> <("Graphics")> "Order 5 Square Grid")
    (item "Square 6" <(square 6)> <Orthogonal> <("Graphics")> "Order 6 Square Grid")
    (item "Square 8**" <(square 8)> <Orthogonal> <("Graphics")> "Order 8 Square Grid")**
    (item "Square 10**" <(square 10)> <Orthogonal> <("Graphics")> "Order 10 Square Grid")*
    (item "Square 12" <(square 12)> <Orthogonal> <("Graphics")> "Order 12 Square Grid")
    (item "Square 14" <(square 14)> <Orthogonal> <("Graphics")> "Order 14 Square Grid")
    (item "Square 16" <(square 16)> <Orthogonal> <("Graphics")> "Order 16 Square Grid")
    (item "Square 18" <(square 18)> <Orthogonal> <("Graphics")> "Order 18 Square Grid")
    (item "Hex 3" <(tri Hexagon 3)> <Orthogonal> <("GraphicsOption" "counter.svg" 0.98  "disc.svg" 0.75)>  "Order 3, Hex Grid")
    (item "Hex 3,4*" <(tri Limping 3)> <Orthogonal> <("GraphicsOption" "counter.svg" 0.98  "disc.svg" 0.75)>  "Order 3-4, Hex Grid")*
    (item "Hex 4" <(tri Hexagon 4)> <Orthogonal> <("GraphicsOption" "counter.svg" 0.98  "disc.svg" 0.75)>  "Order 4, Hex Grid")
    (item "Hex 4,5**" <(tri Limping 4)> <Orthogonal> <("GraphicsOption" "counter.svg" 0.98  "disc.svg" 0.75)> "Order 4-5, Hex Grid")**
    (item "Hex 5" <(tri Hexagon 5)> <Orthogonal> <("GraphicsOption" "counter.svg" 0.98  "disc.svg" 0.75)> "Order 5, Hex Grid")
    (item "Hex 5,6" <(tri Limping 5)> <Orthogonal> <("GraphicsOption" "counter.svg" 0.98  "disc.svg" 0.75)>  "Order 5-6, Hex Grid") 
    //   (item "3D-4" <"ThreeD4Board"> <Orthogonal> <("Graphics3D" "disc.svg" "square.svg")> "3D Grid")
    //   (item "3D" <"ThreeD456Board"> <Orthogonal> <("Graphics3D" "disc.svg" "square.svg")> "3D Grid")
    }
)

(define "ThreeD456Board" (layers 4 (rectangle 5 6)))
// (scale 1.8 1 5 (layers 4 (rectangle 5 6)))
// (skew .7 (scale 1.6 .2 (layers 4 (rectangle 5 6))))
// (layers 4 (skew .7 (scale 1.8 1 (rectangle 5 6))))
//)

(define "ThreeD4Board" (layers 4 (rectangle 4 4)))
// (scale 1.8 1 5 (layers 4 (rectangle 4 4)))

(define "Graphics"  ("GraphicsOption" "counter.svg" 0.98  "disc.svg" 0.75))
//  Other possible styles
// "Stub Feet" // ("GraphicsOption" "square.svg" 0.9 "senetpiece" 0.9)
// "Feet with toes" // ("GraphicsOption" "square.svg" 0.9 "queen_symbola" 0.9)
// "Small feet"// ("GraphicsOption" "counter.svg" 0.98  "disc.svg" 0.75)
// "Dots" // ("GraphicsOption" "square.svg" 0.9  "disc.svg" 0.7)
// "3D" // ("Graphics3D" "disc.svg" "square.svg")

(define "P1Colour" (colour DarkGreen))
(define "P2Colour" (colour White))
// (define "P2Colour" (colour 230 224 200))

(define "GraphicsOption" // Orients symbols used for feet on the square grid - 
    (graphics
        {
        (player Colour P1 (colour DarkGreen))
        (player Colour P2 (colour Cream))
        (board Style Graph)
        (board Background
            fillColour:(colour 150 120 30 90) 
            edgeColour:(colour 150 120 30 90)
        )
        (board StyleThickness InnerEdges .2)
        (board StyleThickness OuterEdges .2)
        (board StyleThickness InnerVertices .5)
        (no Sunken False)
        (show Edges Diagonal Hidden)
        (piece Scale .04) 
        (piece Foreground "Disc1" state:0 image:#3
            fillColour:(colour DarkGreen) scale:#4 
            rotation:0
        )
        (piece Background "Disc1" state:1 image:#1
            fillColour:(colour DarkGreen) scale:#2 
            rotation:90
        )
        (piece Foreground "Disc1" state:2 image:#3
            fillColour:(colour DarkGreen) scale:#4 
            rotation:180
        )
        (piece Foreground "Disc1" state:3 image:#3
            fillColour:(colour DarkGreen) scale:#4 
            rotation:270
        )
        (piece Foreground "Disc1" state:4 image:#3
            fillColour:(colour DarkGreen) scale:#4 
            rotation:0
        )
        (piece Foreground "Disc1" state:5 image:#3
            fillColour:(colour DarkGreen) scale:#4 
            rotation:90
        )
        (piece Foreground "Disc2" state:0 image:#3
            fillColour:"P2Colour" scale:#4 rotation:0
        )
        (piece Background "Disc2" state:1 image:#1
            fillColour:"P2Colour" scale:#2 
            rotation:90
        )
        (piece Foreground "Disc2" state:2 image:#3
            fillColour:"P2Colour" scale:#4 
            rotation:180
        )
        (piece Foreground "Disc2" state:3 image:#3
            fillColour:"P2Colour" scale:#4 
            rotation:270
        )
        (piece Foreground "Disc2" state:4 image:#3
            fillColour:"P2Colour" scale:#4 
            rotation:0
        )
        (piece Foreground "Disc2" state:5 image:#3
            fillColour:"P2Colour" scale:#4 
            rotation:90
        )
        //(show Piece State)
        (show Symbol "X"
            (forEach
                (sites Around (sites Occupied by:All) if:(is Empty (to)))
                if:(and 
                    {
                    (all Passed)
                    (no Pieces P2 in:(sites Around (site)))
                    }
            ))
            edgeColour:"P1Colour"
            scale:.4 
        )
        (show Symbol "X"
            (forEach
                (sites Around (sites Occupied by:All) if:(is Empty (to)))
                if:(and 
                    {
                    (all Passed)
                    (no Pieces P1 in:(sites Around (site)))
                    }
            ))
            edgeColour:"P2Colour"
            scale:.4 
        )
        }
))

(define "Graphics3D" // Future use - Game works, but Ludii Gui doesn't
    (graphics
        {
        (player Colour P1 (colour DarkGreen))
        (player Colour P2 (colour Cream))
        (board Style Graph)
        (board StyleThickness InnerEdges .2)
        (board StyleThickness OuterEdges .2)
        (board StyleThickness InnerVertices .5)
        (show Edges Diagonal Hidden)
        //    (piece Scale .04)  
        //Probably should use partly transparent colors for 3D
        (piece Colour fillColour:(colour 0 0 0 0) strokeColour:(colour 0 0 0 0))
        (piece Foreground "Disc1" state:0 value:0 image:#1 fillColour:(colour DarkGreen) scale:1 rotation:0)
        (piece Foreground "Disc1" state:0 value:1 image:#1 fillColour:(colour DarkGreen) scale:.8 rotation:0)
        (piece Foreground "Disc1" state:0 value:2 image:#1 fillColour:(colour DarkGreen) scale:.6 rotation:0)
        (piece Foreground "Disc1" state:0 value:3 image:#1 fillColour:(colour DarkGreen) scale:.4 rotation:0)
        (piece Foreground "Disc1" state:0 value:4 image:#1 fillColour:(colour DarkGreen) scale:.2 rotation:0)
        (piece Foreground "Disc2" state:0 value:0 image:#1 fillColour:(colour Cream) scale:1 rotation:0)
        (piece Foreground "Disc2" state:0 value:1 image:#1 fillColour:(colour Cream) scale:.8 rotation:0)
        (piece Foreground "Disc2" state:0 value:2 image:#1 fillColour:(colour Cream) scale:.6 rotation:0)
        (piece Foreground "Disc2" state:0 value:3 image:#1 fillColour:(colour Cream) scale:.4 rotation:0)
        (piece Background "Disc2" state:0 value:4 image:#1 fillColour:(colour Cream) scale:.2 rotation:0)
        (piece Background "Disc1" state:1 value:0 image:#2 fillColour:(colour DarkGreen) scale:1 rotation:0)
        (piece Background "Disc1" state:1 value:1 image:#2 fillColour:(colour DarkGreen) scale:.8 rotation:0)
        (piece Background "Disc1" state:1 value:2 image:#2 fillColour:(colour DarkGreen) scale:.6 rotation:0)
        (piece Background "Disc1" state:1 value:3 image:#2 fillColour:(colour DarkGreen) scale:.4 rotation:0)
        (piece Background "Disc1" state:1 value:4 image:#2 fillColour:(colour DarkGreen) scale:.2 rotation:0)
        (piece Background "Disc2" state:1 value:0 image:#2 fillColour:(colour Cream) scale:1 rotation:0)
        (piece Background "Disc2" state:1 value:1 image:#2 fillColour:(colour Cream) scale:.8 rotation:0)
        (piece Background "Disc2" state:1 value:2 image:#2 fillColour:(colour Cream) scale:.6 rotation:0)
        (piece Background "Disc2" state:1 value:3 image:#2 fillColour:(colour Cream) scale:.4 rotation:0)
        (piece Background "Disc2" state:1 value:4 image:#2 fillColour:(colour Cream) scale:.2 rotation:0)
        //    (piece Scale scaleX:1.5 scaleY:.95)
        //    (show Piece Value)
        }
))

//---------------------------------------------

(metadata
    (info
        {
        (description "Polypods was created as an exploration of a new capture concept in which a group lives as long as it has more terminal ends than core pieces. Group capture naturally became determined in two stages: removing terminals, which then in turn cause the group to exceed its core limit.     This works best on the hex grid.     Since terminals are added in play, they can also be removed without destroying the group.    All groups fall in the range of with 0 to 3 free terminals. Additions can either help stabilize the group, or destabilize it.     Efficiency in scoring encourages growing groups to near the critical size. As does attacking another player's terminals, and being attacked.        Critical size groups are most vulnerable to being killed by terminal attacks instead of merely suffering a terminal loss.    This is not difficult to use as a tactic, and if the result were to clear too much of the board the game would be too unstable a cycle. Removing only the core, ensures that the resultant groups will be singletons and pairs which are all legal formations, and keep the board from clearing too much.         However, tit-for-tat captures still can cause major resets. Therefore, the capture rule specifies that the ownership of the terminals of the captured groups also changes to the capturing player.         This final solution allows tactical instability, but strategic stability.        On small boards ties may be more frequent than some players would like. Thus, a tie-breaker based on empty territory control has also been added. This value is intuitive, and not frequently correlated to the core score, so it functions well in this role.        Group count is not used for scoring, because the terminals provide a benefit in allowing for stability and future growth, and thus function best as investments rather than outcomes.")
        (rules "Polypods is a game about groups of connected stones called Polypods.
            
            Understanding the mythical life of a polypod should help you to easily remember the rules.
            
            Polypods are creatures that have poisonous body segments that tie together its numerous feet. To survive, at least half of a polypod must be its feet, and this determines how they may grow and the shapes they may take. 
            
            The feet die and fall off upon contact with the poisonous body segments of other polypods,  however, since the feet themselves are not poisonous, there is no harm in their contact with other polypod's feet. Fortunately a polypod's foot is able to smell the area around it, and thus a polypod avoids extending its feet to touch the bodies of competing polypods.
            
            Hungry polypods do, however, find ways to bring their body against a foot of another polypod, causing that foot (or feet) to self-amputate.     If the attacking polypod is lucky, the loss of a foot will cause its neighbor to die. 
            
            The attacking polypod then ingests the body of its dead neighbor and spawns new polypods in the dead neighbor's feet.
            
            Definitions:
            -- A POLYPOD is a group of interconnected stones. The group includes every stone of the same color that is connected to it.
            (A single stone, or monopod, is also considered as a polypod in these rules.)
            
            Each stone in a polypod has one of two roles: Body or foot.   
            -- FOOT STONES (FEET) are stones that connect to at most two other friendly stones:- and if connected to two stones, those two must already be adjacent to each other. 
            -- BODY STONES are those that serve to link all the polypod feet together. 
            
            As the polypods grow or shrink, the roles of their individual stones change accordingly.
            (In this application the body stones are marked with squares for convenience in reading the board.)
            
            A polypod is ALIVE if it has at least as many feet as body stones.
            
            -- Foot stones in contact with a body stone of the opposite color SELF-AMPUTATE (ie get immediately removed from the board)
            -- when a Polypod DIES, its body stones are removed, and its feet change ownership.
            
            Rules:
            The game uses discs played on the intersections of a triangular grid of the desired size and shape. 
            The board starts empty and Dark starts. Turns Alternate.
            
            The moving player, either passes, or does the following sequence of actions, if possible:
            1. The mover places a piece on an empty space.
            -- The placement must not cause the immediate self-amputation of the placed stone.
            -- It may add to or merge friendy polypods, UNLESS this would cause those polypod(s) to die.
            2. The mover removes all self-amputating feet.
            3. The mover resolves all polypod deaths.
            
            The game ends when the players pass consecutively.
            
            The winner is determined by tallying the value of each player's polypods.
            The value of a polypod is the number of body stones that it contains.
            If tied, score all the empty spaces adjacent to the players' own polypods.
        If this count is also equal, the game is considered a draw.")
        (id "1994")
        (version "1.3.11")
        (classification "experimental")
        (author "Dale W. Walton")
        (credit "Dale W. Walton")
        (date "06-05-2022")
        }
    )
    
    <BoardShape:graphsOption>
    (ai
        "Polypods_ai"
    )
    
)


















(define "Connect"
    (do
        (move Add
            (to 
                (sites Around (sites Occupied by:Mover) Empty)
                (apply
                    (set Var "NumberOfFriendlyGroupsBeforePlacement"
                        (count Groups Orthogonal
                            if:(is Mover (who at:(to)))
                        )
                    )
                )
            )
        )
        ifAfterwards:(<
            (count Groups Orthogonal
                if:(is Mover (who at:(to)))
            )
            (var "NumberOfFriendlyGroupsBeforePlacement")
        )
    )
)

(game "Scaffold"
    (players 2)
    (equipment {
        (board (square <Board:size>) use:Vertex)
        (piece "Marker" Each)
        (regions P1 {(sites Side N) (sites Side S) })
        (regions P2 {(sites Side W) (sites Side E) })
    })
    (rules
        (meta (swap))
        (play
            (if (< 0 (count MovesThisTurn))
                ("Connect")
                (move Add (to (sites Empty)))
                (then
                    (if 
                        (can Move ("Connect"))
                        (moveAgain)
                    )
                )
                
            )
        )
        (end (if (is Connected Orthogonal Mover) (result Mover Win)))
    )
)

//------------------------------------------------------------------------------

(option "Board Size" <Board> args:{ <size> }
    {
    (item "4x4"  <4> "A 4x4 board is currently selected")
    (item "5x5"  <5> "A 5x5 board is currently selected")
    (item "6x6"  <6> "A 6x6 board is currently selected")
    (item "7x7"  <7> "A 7x7 board is currently selected")
    (item "8x8"  <8> "An 8x8 board is currently selected")
    (item "9x9"  <9> "A 9x9 board is currently selected")
    (item "10x10" <10> "A 10x10 board is currently selected")
    (item "11x11" <11> "An 11x11 board is currently selected")
    (item "12x12" <12> "A 12x12 board is currently selected")*
    (item "13x13" <13> "A 13x13 board is currently selected")
    (item "14x14" <14> "A 14x14 board is currently selected")
    (item "15x15" <15> "A 15x15 board is currently selected")
    (item "16x16" <16> "A 16x16 board is currently selected")
    (item "17x17" <17> "A 17x17 board is currently selected")
    (item "18x18" <18> "An 18x18 board is currently selected")
    (item "19x19" <19> "A 19x19 board is currently selected")
    }
)

//------------------------------------------------------------------------------

(metadata
    (info
        {
        (description "Scaffold is a drawless square connection game invented by Andrew Lannan in 2022 with inspiration and input from the designers on Boardgamegeek.com's Abstract Game forum. Luis BolaÃ±os Mures helped clarify the presentation of the rules. It is similar to Bill Taylor's Quadrex, but was discovered independently.")
        (rules "Definitions
            Group: Either a single stone (a group of one) or any number of stones of the same color connected through a continuous series of orthogonal adjacencies.
            
            Rules
            Scaffold is a drawless connection game played on the intersections of a square grid using stones (as in Go). Black is trying to connect N-S edges of the board, White E-W with an orthogonally connected group.
            
            First player places a single black stone on any grid intersection, after which the second player decides which color they will play (pie rule). Players then alternate taking turns.
            
        On your turn, place a stone of your color on an empty point. Then, if possible, place a stone of your color on an empty point that is orthogonally adjacent to two groups of your color, and keep making such placements until no more are possible.")
        (id "1971")
        (source "<a href=\"https://boardgamegeek.com/boardgame/360432/scaffold\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />BGG</a>")
        (version "1.3.11")
        (classification "board/space/connection")
        (author "Andrew Lannan")
        (credit "Michael Amundsen")
        (date "2022")
        }
    )
    
    (graphics {
        (player Colour P1 (colour Black))
        (player Colour P2 (colour White))
        (board Colour InnerEdges (colour 178 151 100))
        (board Colour OuterEdges (colour Black))
        (board Colour Phase0 (colour 250 210 148))
        (board Colour Phase1 (colour 250 210 148))
        (board Style Board)
        (board StyleThickness OuterEdges 3.0)
        (region Colour Edge (union (sites Top Edge) (sites Bottom Edge)) regionSiteType:Edge (colour Black))
        (region Colour Edge (union (sites Left Edge) (sites Right Edge)) regionSiteType:Edge (colour White))
    })
    (ai
        "Scaffold_ai"
    )
)













(define "RemovePiece" <Version:removeRule>)

(define "SlideOrChangeDirection"
    (or
        (move Slide
            #1
            (between #2) 
            (to 
                if:("IsEnemyAt" (to)) 
                (apply "RemovePiece")
            )
        )
        (move Set Rotation) 
    ) 
)

(define "StepOrChangeDirection"
    (or 
        (move Step
            #1 
            (to 
                if:(not ("IsFriendAt" (to))) 
                (apply "RemovePiece")
            )
            #2
        ) 
        (move Set Rotation) 
    ) 
)

(define "CaptureCommandeOf" (trigger "CommanderCaptured" #1))

(define "CommanderOfWasCapture" (is Triggered "CommanderCaptured" #1))

(define "CaptureCommandeOf" (trigger "CommanderCaptured" #1))

(define "CommanderOfWasCapture" (is Triggered "CommanderCaptured" #1))

//------------------------------------------------------------------------------

(game "Ploy" 
    (players <Version:numPlayers>) 
    (equipment { 
        (board (square 9) use:Vertex) 
        <Version:rulesCommander>
        
        (piece "Commander" Each ("StepOrChangeDirection" (directions {FR FL BL BR} of:All)))
        (piece "Shield" Each ("StepOrChangeDirection" (directions Forward of:All) (then (moveAgain))))
        (piece "LanceW" Each ("SlideOrChangeDirection" (directions Forwards of:All) (max 3))) 
        (piece "LanceY" Each ("SlideOrChangeDirection" (directions {FR FL Backward} of:All) (max 3))) 
        (piece "LanceT" Each ("SlideOrChangeDirection" (directions {Forward Rightward Leftward} of:All) (max 3))) 
        (piece "ProbeI" Each ("SlideOrChangeDirection" (directions {Forward Backward} of:All) (max 2)))
        (piece "ProbeMinV" Each ("SlideOrChangeDirection" (directions {Forward FR} of:All) (max 2)))
        (piece "ProbeBigV" Each ("SlideOrChangeDirection" (directions {FR FL} of:All) (max 2)))
    }) 
    (rules 
        (start { 
            <Version:start>
        })
        (play
            (if "SameTurn"
                (or 
                    (move Set Rotation (to (last To))) 
                    (move Pass)
                )
                (forEach Piece <Version:consequence>)
            )
        )
        <Version:endRules>
    )
)

//------------------------------------------------------------------------------

(option "Version" <Version> args:{ <numPlayers> <rulesCommander> <removeRule> <start> <consequence> <endRules>}
    {
    (item "2 Players"
        <2>
        <>
        <(remove (to))>
        <
        (place "Commander1" coord:"E1" rotation:0) (place "Shield1" {"D3" "E3" "F3"} rotation:0) 
        (place "ProbeI1" coord:"E2" rotation:0) (place "ProbeBigV1" {"D2" "F2"} rotation:0) 
        (place "ProbeMinV1" coord:"C2" rotation:0) (place "ProbeMinV1" coord:"G2" rotation:7) (place "LanceW1" {"D1" "F1"} rotation:0) 
        (place "LanceY1" {"C1" "G1"} rotation:0) (place "LanceT1" {"B1" "H1"} rotation:0)
        
        (place "Commander2" coord:"E9" rotation:4) (place "Shield2" {"D7" "E7" "F7"} rotation:4) 
        (place "ProbeI2" coord:"E8" rotation:4) (place "ProbeBigV2" {"D8" "F8"} rotation:4) 
        (place "ProbeMinV2" coord:"C8" rotation:3) (place "ProbeMinV2" coord:"G8" rotation:4) (place "LanceW2" {"D9" "F9"} rotation:4) 
        (place "LanceY2" {"C9" "G9"} rotation:4) (place "LanceT2" {"B9" "H9"} rotation:4)
        >
        <>
        <
        (end 
            (if 
                (or 
                    ("IsOffBoard" (where "Commander" Next)) 
                    (= (count Pieces Next) 1)
                ) 
                (result Mover Win)
            )
        )
        >
        "The two players version of Ploy."
    )** 
    
    (item "4 Players"
        <4>
        <
        >
        <
        (and {
            (if (= (what at:(to)) (id "Commander" P1)) (and ("CaptureCommandeOf" P1) (take Control of:P1 by:Mover))) 
            (if (= (what at:(to)) (id "Commander" P2)) (and ("CaptureCommandeOf" P2) (take Control of:P2 by:Mover))) 
            (if (= (what at:(to)) (id "Commander" P3)) (and ("CaptureCommandeOf" P3) (take Control of:P3 by:Mover))) 
            (if (= (what at:(to)) (id "Commander" P4)) (and ("CaptureCommandeOf" P4) (take Control of:P4 by:Mover))) 
            (remove (to)) 
        })
        >
        <
        (place "Commander1" coord:"A1" rotation:1) (place "Shield1" {"C2" "B3" "C3"} rotation:1) 
        (place "ProbeBigV1" coord:"B2" rotation:1) 
        (place "ProbeMinV1" coord:"A3" rotation:2) (place "ProbeMinV1" coord:"C1" rotation:7) 
        (place "LanceW1" coord:"A2" rotation:1) 
        (place "LanceT1" coord:"B1" rotation:1)
        
        (place "Commander2" coord:"A9" rotation:1) (place "Shield2" {"B7" "C7" "C8"} rotation:3) 
        (place "ProbeBigV2" coord:"B8" rotation:3) 
        (place "ProbeMinV2" coord:"A7" rotation:1) (place "ProbeMinV2" coord:"C9" rotation:5) 
        (place "LanceW2" coord:"B9" rotation:3) 
        (place "LanceT2" coord:"A8" rotation:3)
        
        (place "Commander3" coord:"I9" rotation:1) (place "Shield3" {"G7" "H7" "G8"} rotation:5) 
        (place "ProbeBigV3" coord:"H8" rotation:5) 
        (place "ProbeMinV3" coord:"I7" rotation:6) (place "ProbeMinV3" coord:"G9" rotation:3) 
        (place "LanceW3" coord:"I8" rotation:5) 
        (place "LanceT3" coord:"H9" rotation:5)
        
        (place "Commander4" coord:"I1" rotation:1) (place "Shield4" {"G3" "H3" "G2"} rotation:7) 
        (place "ProbeBigV4" coord:"H2" rotation:7) 
        (place "ProbeMinV4" coord:"I3" rotation:5) (place "ProbeMinV4" coord:"G1" rotation:0) 
        (place "LanceW4" coord:"H1" rotation:7) 
        (place "LanceT4" coord:"I2" rotation:7)
        >
        <
        (then 
            (and {
                (if (= (count Pieces P1) 1) (and ("CaptureCommandeOf" P1) (remove (where "Commander" P1)))) 
                (if (= (count Pieces P2) 1) (and ("CaptureCommandeOf" P2) (remove (where "Commander" P2))))
                (if (= (count Pieces P3) 1) (and ("CaptureCommandeOf" P3) (remove (where "Commander" P3))))
                (if (= (count Pieces P4) 1) (and ("CaptureCommandeOf" P4) (remove (where "Commander" P4))))
            })
        )
        >
        <
        (end {
            (if ("CommanderOfWasCapture" P1) (result P1 Loss))
            (if ("CommanderOfWasCapture" P2) (result P2 Loss))
            (if ("CommanderOfWasCapture" P3) (result P3 Loss))
            (if ("CommanderOfWasCapture" P4) (result P4 Loss))
        })
        >
        "The four players version with no team of Ploy."
    )
    
    (item "4 Players With Team"
        <4>
        <
        >
        <
        (and {
            (if (= (what at:(to)) (id "Commander" P1)) ("CaptureCommandeOf" P1)) 
            (if (= (what at:(to)) (id "Commander" P2)) ("CaptureCommandeOf" P2))
            (if (= (what at:(to)) (id "Commander" P3)) ("CaptureCommandeOf" P3)) 
            (if (= (what at:(to)) (id "Commander" P4)) ("CaptureCommandeOf" P4)) 
            (remove (to)) 
        })
        >
        <
        (set Team 1 {P1 P3})
        (set Team 2 {P2 P4})
        (place "Commander1" coord:"C9" rotation:0) (place "Shield1" {"B7" "C7" "D7"} rotation:4) 
        (place "ProbeBigV1" coord:"C8" rotation:4) 
        (place "ProbeMinV1" coord:"B8" rotation:3) (place "ProbeMinV1" coord:"D8" rotation:4) 
        (place "LanceW1" coord:"D9" rotation:4) 
        (place "LanceT1" coord:"B9" rotation:4)
        
        (place "Commander2" coord:"C1" rotation:0) (place "Shield2" {"B3" "C3" "D3"} rotation:0) 
        (place "ProbeBigV2" coord:"C2" rotation:0) 
        (place "ProbeMinV2" coord:"B2" rotation:0) (place "ProbeMinV2" coord:"D2" rotation:7) 
        (place "LanceW2" coord:"D1" rotation:0) 
        (place "LanceT2" coord:"B1" rotation:0)
        
        (place "Commander3" coord:"G9" rotation:0) (place "Shield3" {"F7" "G7" "H7"} rotation:4) 
        (place "ProbeBigV3" coord:"G8" rotation:4) 
        (place "ProbeMinV3" coord:"F8" rotation:3) (place "ProbeMinV3" coord:"H8" rotation:4) 
        (place "LanceW3" coord:"F9" rotation:4) 
        (place "LanceT3" coord:"H9" rotation:4)
        
        (place "Commander4" coord:"G1" rotation:0) (place "Shield4" {"F3" "G3" "H3"} rotation:0) 
        (place "ProbeBigV4" coord:"G2" rotation:0) 
        (place "ProbeMinV4" coord:"F2" rotation:0) (place "ProbeMinV4" coord:"H2" rotation:7) 
        (place "LanceW4" coord:"F1" rotation:0) 
        (place "LanceT4" coord:"H1" rotation:0)
        >
        <
        (then (and {
                (if (= (count Pieces P1) 1) ("CaptureCommandeOf" P1)) 
                (if (= (count Pieces P2) 1) ("CaptureCommandeOf" P2))
                (if (= (count Pieces P3) 1) ("CaptureCommandeOf" P3))
                (if (= (count Pieces P4) 1) ("CaptureCommandeOf" P4))
        }))
        >
        <
        (end 
            {
            (if (and ("CommanderOfWasCapture" P2) ("CommanderOfWasCapture" P4)) (result Team1 Win))
            (if (and ("CommanderOfWasCapture" P1) ("CommanderOfWasCapture" P3)) (result Team2 Win))
            }
        )
        >
        "The four players version with no team of Ploy."
    )
})

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Ploy was invented by Frank Thibault in 1970. It can be played by two or four players and the goal is to capture the opponent's Commander.")
        (rules "The goal is to capture the enemy Commander, or reduce the opponent army to a single Commander. Each piece has an indicator which determines at which directions the piece can move. This can be altered by rotating the piece 45 degrees= to the left or right. Rotating the piece costs a move. Each player has 3 Shields, 5 Probes, 6 Lances, and one Commander. The Shield moves one step and has only one movement freedom at any time. The Probe slides two steps and has two freedoms. The Lance slides three steps and has three freedoms. The Commander has four, but can only move one step. A player must either make a direction move or a motion move. The three Shields are the only pieces that can perform a direction move immediately after a motion move. Capture occurs by displacement.")
        (source "<a href=\"http://mlwi.magix.net/bg/ploy.htm\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />mlwi.magix.net</a>")
        (id "408")
        (version "1.3.11")
        (classification "board/war/replacement/eliminate/target")
        (author "Frank Thibault")
        (publisher "3M, Dujardin, Grow Jogos e Brinquedos, Schmid")
        (credit "Eric Piette")
        (date "1970")
        }
    )
    
    (graphics {
        (player Colour P1 (colour Green))
        (player Colour P2 (colour Red))
        (player Colour P3 (colour Yellow))
        (player Colour P4 (colour Blue))
        (show Edges Outer Hidden)
        (show Edges Diagonal Thin (colour 102 0 153))
        (show Edges Inner Thin (colour 102 0 153))
        (board Background image:"Square.svg" fillColour:(colour 153 0 204) edgeColour:(colour 153 0 204) scale:1.3)
        (show Symbol "Disc" (sites Board) fillColour:(colour 102 0 153) edgeColour:(colour 102 0 153) scale:0.5)
    })
    
    (ai 
        "Ploy_ai"
    )
    
)





(define "SumPips" (count Pips))

(define "SiteToMoveOnTrack" ("NextSiteOnTrack" #2 #1))

(define "NumDiceAtOne" 
    (+ {
        (if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0)
        (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0)
        (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0)
        (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)
    })
)

(define "CaptureEnemyPiece" 
    (apply 
        if:("IsEnemyAt" (to)) 
        (remove (to))
    ) 
)

//------------------------------------------------------------------------------

(game "Chong (Sakhalin)"
    (players 2)
    (equipment {
        (board 
            (rectangle 3 <Board:size>)
            {
            (track "Track1" "0,E,N1,W,N1,E" P1 directed:True)
            (track "Track2" <Board:track2> P2 directed:True)
            }
        )
        (dice d:6 num:4)
        (piece "Marker" Each
            (move
                (from)
                (to ("SiteToMoveOnTrack" from:(from) (pips))
                    if:(or {
                        (is Empty (to))
                        (and 
                            ("IsEnemyAt" (to))
                            (if (not ("IsPieceAt" "King" Next (to)))
                                True
                                (= 1 (abs (- (to) (from))))
                            )
                        )
                    })
                    ("CaptureEnemyPiece")
                )
            )
        )
        (piece "King" Each
            (if (= 1 (pips))
                (if (<= 2 (count Pieces Mover))
                    (if (and (!= 1 (value Player Mover)) (= 1 (count Pieces Mover)))
                        (move (from (from)) (to (from)) (then (set Value Mover 1)))
                        (move
                            (from)
                            (to ("SiteToMoveOnTrack" from:(from) (pips))
                                if:(or {
                                    (is Empty (to))
                                    (and 
                                        ("IsEnemyAt" (to))
                                        (if (not ("IsPieceAt" "King" Next (to)))
                                            True
                                            (= 1 (abs (- (to) (from))))
                                        )
                                    )
                                })
                                ("CaptureEnemyPiece")
                            )
                        )
                    )
                    (firstMoveOnTrack "Track" Mover
                        (if (and (> (site) (from)) (is Mover (who at:(site))))
                            (move Swap Pieces (from) (site))
                        )
                    )
                )
            )
        )
    })
    (rules 
        (start { 
            (place "Marker1" (sites Bottom))
            (place "King1" 23)
            (place "Marker2" (sites Top))
            (place "King2" 12)
        })
        phases:{
        (phase "Opening"
            (play 
                ("RollMove"
                    (if (!= 0 ("NumDiceAtOne"))
                        (if (is Mover P1)
                            (if (is Mover (who at:(- (where "King" Mover) (+ (- (count Sites in:(sites Bottom)) 1) ("NumDiceAtOne")))))
                                (move Swap Pieces (where "King" Mover) (- (where "King" Mover) (+ (- (count Sites in:(sites Bottom)) 1) ("NumDiceAtOne"))))
                            )
                            (if (is Mover (who at:(+ (where "King" Mover) (+ (- (count Sites in:(sites Bottom)) 1) ("NumDiceAtOne")))))
                                (move Swap Pieces (where "King" Mover) (+ (where "King" Mover) (+ (- (count Sites in:(sites Bottom)) 1) ("NumDiceAtOne"))))
                            )
                            (then
                                (fromTo
                                    (from (last From))
                                    (to ("SiteToMoveOnTrack" from:(last From) (- ("SumPips") ("NumDiceAtOne")))
                                        ("CaptureEnemyPiece")
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase Mover (not (was Pass)) "Playing")
        )
        (phase "Playing"
            (play
                ("RollEachNewTurnMove"
                    (forEach Die
                        if:("DieNotUsed")
                        (forEach Piece)
                        (then ("ReplayNotAllDiceUsed"))
                    )
                )
            )
        )
        }
        
        (end {
            (if (= (who at:0) P2) (result P2 Win))
            (if (= (who at:(- (count Sites in:(sites Board)) 1)) P1) (result P1 Win))
        })
    )
)

//------------------------------------------------------------------------------

(option "Board Size" <Board> args:{ <size> <track2>} {
    (item "3x12" <12> <"35,W,S1,E,S1,W"> "The game is played on a 3x12 board.") 
    (item "3x13" <13> <"38,W,S1,E,S1,W"> "The game is played on a 3x13 board.") 
    (item "3x14" <14> <"41,W,S1,E,S1,W"> "The game is played on a 3x14 board.") 
    (item "3x15" <15> <"44,W,S1,E,S1,W"> "The game is played on a 3x15 board.") 
    (item "3x16" <16> <"47,W,S1,E,S1,W"> "The game is played on a 3x16 board.") 
    (item "3x17" <17> <"50,W,S1,E,S1,W"> "The game is played on a 3x17 board.") 
    (item "3x18" <18> <"53,W,S1,E,S1,W"> "The game is played on a 3x18 board.") 
    (item "3x19" <19> <"56,W,S1,E,S1,W"> "The game is played on a 3x19 board.") 
    (item "3x20" <20> <"59,W,S1,E,S1,W"> "The game is played on a 3x20 board.") 
    (item "3x21" <21> <"62,W,S1,E,S1,W"> "The game is played on a 3x21 board.") 
    (item "3x22" <22> <"65,W,S1,E,S1,W"> "The game is played on a 3x22 board.") 
    (item "3x23" <23> <"68,W,S1,E,S1,W"> "The game is played on a 3x23 board.") 
    (item "3x24" <24> <"71,W,S1,E,S1,W"> "The game is played on a 3x24 board.") 
    (item "3x25" <25> <"74,W,S1,E,S1,W"> "The game is played on a 3x25 board.") 
    (item "3x26" <26> <"77,W,S1,E,S1,W"> "The game is played on a 3x26 board.") 
    (item "3x27" <27> <"80,W,S1,E,S1,W"> "The game is played on a 3x27 board.") 
    (item "3x28" <28> <"83,W,S1,E,S1,W"> "The game is played on a 3x28 board.") 
})

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Chong is a game played by the Nivkh people in Northern Asia. This version was played in the late nineteenth and early twentieth century on Sakhalin Island.")
        (rules "3x12-28 board. Players begin with soldiers, equal in number to the number of spaces in one row for each player, which begin in the spaces in the row closes to the player. Each player has one king piece, which begins in the rightmost space in the central row with respect to the player. Four six-sided dice with values from 1-6. A throw of 1 is called Chong. Pieces move in a boustrophedon path along the board, from left to right in their home row, right to left in the center row, and then left to right in their opponent's row. 
            
            A player must first throw a Chong to play. On this turn, when a player throws one Chong, the King exchanges places with the soldier behind it. If more than one Chong is thrown, the King exchanges places with the soldier that many spaces behind it. Any remaining values in the throw are moved by the soldier which took the king's space. Once this move has taken place, pieces move according to the throws of the dice, which can be subdivided between the pieces as the player sees fit. The King only moves with a Chong, and it exchanges the place of a piece that number of occupied squares away, i.e., only spaces occupied by the player's pieces are counted when moving the King. When the player has only one soldier and the King, the King may move normally (like a soldier does), but on throws of Chong. When only the King is left, the first Chong in a throw is ignored and only the second, third, or fourth Chongs are moved.  
            
            When a player's piece lands on a space occupied by an opponent's piece, the opponent's piece is captured. An opponent's King cannot be taken by a soldier until it has first moved backwards, and then it can only be taken by a Chong.
            
            The game continues after the players' Kings have been taken.
            
        When a player reaches the end of the opponent's home line, the player wins.")
        (source "Sternberg 1933: 340-342.")
        (id "1972")
        (version "1.3.11")
        (classification "board/race/reach")
        (credit "Eric Piette")
        (origin "This game was played in North Asia, from around 1890 to 1933.")
        }
    )
    
    (graphics {
        (board Colour Phase0 (colour 223 178 110))
        (board Colour InnerEdges (colour Black))
        (board Colour OuterEdges (colour Black))
    })
    
    (ai
        "Chong (Sakhalin)_ai"
    )
)

















// Wellisch Chess
// Copyright 2020, Jay M. Coskey, except functions drawn from Chess.lud, as noted

//----------------------------------------
// General functions
//----------------------------------------

// Usage: ("Directions" <p1_dirs> <p2_dirs> <p3_dirs>)
(define "Directions"
    ("P123" (directions #1) (directions #2) (directions #3))
)

// Usage: ("IsToA" <piece_type>)
(define "IsToA"
    (or {
        ("IsPieceAt" #1 P1 (to))
        ("IsPieceAt" #1 P2 (to))
        ("IsPieceAt" #1 P3 (to))
    })
)

(define "IsToEmpty"
    (is In (to) (sites Empty))
)

(define "IsToEmptyOrEnemy"
    (or "IsToEmpty"
        ("IsEnemyAt" (to))
    )
)

// Source: Chess.lud - NextCanNotMove
(define "NextCannotMove"
    (not (can Move (do
                (forEach Piece (next))
                ifAfterwards:(not ("IsInCheck" "King" Next))
            )
        )
    )
)

// Usage: ("P123" <p1_arg> <p2_arg> <p3_arg>)
(define "P123"
    (if (is Mover P1) #1
        (if (is Mover P2) #2 #3)
    )
)

//----------------------------------------
// Hand functions
// "Grab" = Move a piece from board to Hand
//----------------------------------------

// Usage: ("GrabToPiece <then>)
(define "GrabToPiece"
    (if ("IsToA" "Pawn")
        (remove (to))   // Remove Pawn
        (if ("IsToA" "King")
            (and
                (trigger "CapturedEnemyKing" Mover) // Record winner
                (remove (to)) // Remove King
            )
            (move    // Grab any other piece
                (from (to))
                (to (handSite // Place in an open site
                        (who at:(to))
                        (mapEntry "HandIndex" (what at:(to)))
                ))
                #1
            )
        )
    )
)

(define "GrabToPieceAndResetCounter"
    ("GrabToPiece" (then (set Counter)))
)

// Usage: ("SlideGrabMove" <directions> <then>)
(define "SlideGrabMove"
    (move Slide
        #1
        (to if:("IsEnemyAt" (to))
            (apply "GrabToPieceAndResetCounter")
        )
        #2
    )
)

// Usage: ("StepGrabMove" <directions> <then>)
(define "StepGrabMove"
    (move Step
        #1
        (to if:"IsToEmptyOrEnemy"
            (apply
                (if ("IsEnemyAt" (to))
                    "GrabToPieceAndResetCounter"
                )
            )
        )
        #2
    )
)

//----------------------------------------
// History (for castling)
//----------------------------------------

// Source: Chess.lud - PieceHasNeverMoved
// Usage: ("History_HasNeverMoved" <piece_name_key>)
(define "History_HasNeverMoved"
    (= (state at:(mapEntry #1 (mover))) 1)
)

// Source: Chess.lud - PieceHasMoved
(define "History_SaveMovement"
    (set State at:(last To) 0)
)

// Source: Chess.lud - RememberPieceHasMoved
(define "History_SaveMovementChange"
    (then
        (if (= (state at:(last To)) 1)
            "History_SaveMovement"
        )
    )
)

//----------------------------------------
// King movement: Castling
//----------------------------------------

(define "Castle_PreCheck"
    (and {
        ("IsPieceAt" "King" Mover (mapEntry "King" (mover))) // At Start Cell
        ("History_HasNeverMoved" "King")
        (not ("IsInCheck" "King" Mover))
    })
)

// Usage: ("KingSideSwap" <king_idx> <rook_idx>)
(define "KingSideSwap"
    (if (and 
            ("History_HasNeverMoved" "RookRight")
            (not ("IsInCheck" "King" Mover at:(mapEntry "RookRight" Mover)))
        )
        (move Swap Pieces #1 #2
            (then "History_SaveMovement")
        )
    )
)

// Usage: ("QueenSideSwap" <king_idx> <rook_idx>)
(define "QueenSideSwap"
    (if (and {
            ("History_HasNeverMoved" "RookLeft")
            (not ("IsInCheck" "King" Mover at:(mapEntry "RookLeft" Mover)))
            (not ("IsInCheck" "King" Mover at:(mapEntry "Queen" Mover)))
            (is In (mapEntry "Queen" Mover) (sites Empty))
        })
        (move Swap Pieces #1 #2
            (then "History_SaveMovement")
        )
    )
)

(define "Castle_KingSide_P1" ("KingSideSwap" 3 4))
(define "Castle_KingSide_P2" ("KingSideSwap" 61 51))
(define "Castle_KingSide_P3" ("KingSideSwap" 77 84))

(define "Castle_QueenSide_P1" ("QueenSideSwap" 3 1))
(define "Castle_QueenSide_P2" ("QueenSideSwap" 61 78))
(define "Castle_QueenSide_P3" ("QueenSideSwap" 77 60))

(define "Castle_KingSide"
    ("P123" "Castle_KingSide_P1" "Castle_KingSide_P2" "Castle_KingSide_P3")
)
(define "Castle_QueenSide"
    ("P123" "Castle_QueenSide_P1" "Castle_QueenSide_P2" "Castle_QueenSide_P3")
)

//----------------------------------------
// Pawn Movement
// Note: Counter is reset in (piece "Pawn" ...).
//----------------------------------------

// Usage: ("PawnGrab_Base" <directions>)
(define "PawnGrab_Base"
    (move Step
        #1
        (to if:("IsEnemyAt" (to))
            (apply ("GrabToPiece" ~))
        )
    )
)

(define "PawnGrab"
    ("PawnGrab_Base" ("Directions" {NNW NNE} {E SSE} {SSW W}))
)

// Usage: ("StepOrthoToEmpty_Base" <directions>)
(define "StepOrthoToEmpty_Base"
    ("StepToEmpty" #1)
)

(define "StepOrthoToEmpty"
    ("StepOrthoToEmpty_Base" ("Directions" {NNW NNE} {E SSE} {SSW W}))
)

//----------------------------------------
// Pawn promotion
//----------------------------------------

(define "IsRegionNonEmpty"
    (> (count Sites in:#1) 0) 
)

(define "PromoteFromHand"
    (move
        (from 
            (sites Occupied by:Mover container:"Hand"
                components:{"Queen" "Rook" "Knight"}
            )
        )
        (to (last To))
    )
)

(define "PromoteFromHandDelayed"
    (move
        (from (sites Occupied by:Mover container:"Hand"
                components:{"Queen" "Rook" "Knight"}
        ))
        (to (sites Mover "PromotionZone")
            if:("IsPieceAt" "Pawn" Mover (to))
        )
    )
)

//------------------------------------------------------------------------------

(game "Wellisch Chess"
    (players {(player N) (player ESE) (player WSW)})
    (equipment {
        (board (hex 6))
        
        (piece "King" Each // Moves in Orthogonal steps
            (or {
                ("StepGrabMove" Orthogonal "History_SaveMovementChange")
                (if "Castle_PreCheck"
                    (or {
                        "Castle_KingSide"
                        "Castle_QueenSide"
                    })
                )
            })
        )
        (piece "Queen" Each // Q = R + N
            (or
                ("SlideGrabMove" Orthogonal ~) // Rook move
                ("StepGrabMove" Diagonal ~) // Knight move
            )
        )
        (piece "Rook" Each ("SlideGrabMove" Orthogonal ~))
        (piece "Knight" Each // Different from other hexagonal chess variants
            ("StepGrabMove" Diagonal ~)
        )
        
        (piece "Pawn" Each
            (or {
                "StepOrthoToEmpty"
                "PawnGrab"
                }
                (then
                    (and
                        ("ReplayInMovingOn" (sites Mover "PromotionZone"))
                        (set Counter)
                    )
                )
            )
        )
        
        (map "King"  {(pair 1 "D1") (pair 2 "C8") (pair 3 "K9")})
        (map "RookLeft" {(pair 1 "B1") (pair 2 "E10") (pair 3 "K7")})
        (map "RookRight" {(pair 1 "E1") (pair 2 "B7") (pair 3 "K10")})
        
        (map "Queen" {(pair 1 2) (pair 2 70) (pair 3 69)})
        
        (hand Each size:3) // One for each of Queen, Rook, Knight
        
        (map "HandIndex" {
            (pair 4 0) (pair 7 1) (pair 10 2) // P1: Q, R, N
            (pair 5 0) (pair 8 1) (pair 11 2) // P2: Q, R, N
            (pair 6 0) (pair 9 1) (pair 12 2) // P3: Q, R, N
        })
        
        (regions "PromotionZone" P1 (sites Top))
        (regions "PromotionZone" P2 (sites {"K6" "J5" "I4" "H3" "G2" "F1"})) // Side ESE
        (regions "PromotionZone" P3 (sites {"A1" "A2" "A3" "A4" "A5" "A6"})) // Side WSW
        
        (regions "Region-Grey" (sites Phase 1))
        (regions "Region-Red" (sites Phase 2))
        (regions "Region-Yellow" (sites Phase 0))
    })
    
    (rules
        (start {
            (place "King1" coord:"D1" state:1)
            (place "Queen1" coord:"C1")
            (place "Rook1" {"B1" "E1"} state:1)
            (place "Knight1" {"A1" "D2" "F1"})
            
            (place "King3" coord:"K9" state:1)
            (place "Queen3" coord:"K8")
            (place "Rook3" {"K10" "K7"} state:1)
            (place "Knight3" {"K11" "J8" "K6"})
            
            (place "King2" coord:"C8" state:1)
            (place "Queen2" coord:"D9")
            (place "Rook2" {"B7" "E10"} state:1)
            (place "Knight2" {"A6" "D8" "F11"})
            
            (place "Pawn1" {"A2" "B2" "C2" "D3" "E3" "E2" "F2" "G2"})
            (place "Pawn3" {"J11" "J10" "J9" "I8" "I7" "J7" "J6" "J5"})
            (place "Pawn2" {"A5" "B6" "C7" "D7" "E8" "E9" "F10" "G11"})
        })
        phases:{
        (phase "Movement"
            (play
                (if ("SameTurn")
                    (if ("HandOccupied" Mover)
                        "PromoteFromHand"
                    )
                    (do
                        // First: Delayed promotion - no captured piece was available earlier.
                        (if (> (count in:(sites Hand Mover)) 0) 
                            "PromoteFromHandDelayed"
                        )
                        next:(do
                            (forEach Piece)
                            ifAfterwards:(not ("IsInCheck" "King" Mover))
                        )
                    )
                )
            )
            (end {
                (if (is Triggered "CapturedEnemyKing" P1) (result P1 Win))
                (if (is Triggered "CapturedEnemyKing" P2) (result P2 Win))
                (if (is Triggered "CapturedEnemyKing" P3) (result P3 Win))
                
                (if ("IsOffBoard" (where "King" P1)) (result P1 Loss))
                (if ("IsOffBoard" (where "King" P2)) (result P2 Loss))
                (if ("IsOffBoard" (where "King" P3)) (result P3 Loss))
                
                (if (= (counter) 100) (result Mover Draw)) // No available moves causes pass
            })
        )
        }
    )
)

//------------------------------------------------------------------------------

(metadata
    
    (info
        {
        (description "A 3-player chess variant played on a board made of hexagons invented by Siegmund Wellisch.")
        (aliases {"Wellisch's Chess"})
        (rules "Wellisch Chess is played on a hexagonal board with each side having length 6 and each space oriented vertically. The board has 91 spaces. The board spaces are traditionally coloured red, yellow, and either gray or black.
            
            Capture and Pawn Promotion:
            * When pieces other than Kings and Pawns are captured, they are set aside for later Pawn promotion. When a Pawn reaches the side of the board opposite its starting side, it is eligible for promotion.
            * When a Pawn is eligible for promotion, and there are pieces of that colour available from previous capture, then the Pawn is promoted to one of the captured pieces, as the player chooses.
            * If there are no pieces of the given colour when a Pawn reaches the far side, then the Pawn remains where it is (unless captured) until a piece of the given colour is captured. Then, on the player's next turn, the Pawn is promoted.
            
            Piece Movement:
            * Rooks move as in Glinski Chess.
            - They slide in any of the 6 adjacent direction.
            * There are no Bishops in Wellisch Chess.
            * Kings can move one space in any of the six adjacent directions from their current space---West, East, or 60 degrees off either of those. They castle by swapping locations with one of the Rooks belonging to the same player. Castling can only take place when neither the King nor the Rook being moved have moved before.
            * Knights move one space 'diagonally' (i.e., along an edge, to any of the six nearest spaces of the same colour). Note that a Knight always moves to a space of the same colour as the space it moved from.
            * Queens can make any move that would be available to a Rook or a Knight on the current space.
            * Pawns can advance with or without capturing by moving one space forward to an adjacent space slightly left or right of forward. Pawns can never advance more than one space. There is no en passant capture. As mentioned above, Pawns can be promoted upon reaching the side of the board farthest from their starting side, but can only be promoted to a piece (Queen, Rook, or Knight) of the same colour that has already been captured. If a Pawn reaches the farthest side without any captured pieces available, then it remains in that position until a piece becomes available for its delayed promotion, on the player's next turn. (Note: Currently, on a turn where the delayed promotion takes place, the possible post-promotion movement of the Pawn is displayed before the promotion visually takes place.)
            
            The game ends when a King is captured, or there is a stalemate due to turns elapsed without a capture or Pawn move.
            * When the game ends in checkmate, the checkmating player wins, the checkmated player loses, and the remaining player draws.
            * When the game ends in stalemate, all players draw. (Note: A player not being able to escape check passes the current move, This does not result in a stalemate.)
            
        Variations: In Wellisch's version of the game, the first player to capture another's King takes possession of the other player's pieces. (The Pawns keep their direction of movement.) In another variant, some people play with a rule that if Player 1's move exposes a threat by Player 2 against Player 3's King, then Player 2 may not capture Player 3's King until Player 3 has had a chance to move.")
        (id "852")
        (source "For an overview, see <a href=\"https://en.wikipedia.org/wiki/Hexagonal_chess\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>. For details, see The Classified Encyclopedia of Chess Variants, by D. B. Pritchard (2nd edition, completed and edited by John Beasley, 2007).")
        (version "1.3.11")
        (classification "board/war/replacement/checkmate/chess")
        (author "Siegmund Wellisch")
        (credit "Jay Coskey, with some small functions drawn from Chess.lud, by Eric Piette")
        (date "1912")
        }
    )
    
    (graphics {
        (piece Scale "Pawn" 0.7)
        (piece Scale "King" 0.8)
        (piece Scale "Knight" 0.8)
        (piece Scale "Queen" 0.8)
        (piece Scale "Rook" 0.8)
        (board Style Chess)
        
        (region Colour "Region-Grey" (colour "#acacac"))
        (region Colour "Region-Red" (colour "#ff7f7f"))
        (region Colour "Region-Yellow" (colour "#fff87f"))
        
        (player Colour P2 (colour Cyan))
        (player Colour P3 (colour Green))
        
    })
    (ai
        "Wellisch Chess_ai"
    )
)












(define "Size" <Board:size>)

(define "NonAdjacent"
    (not (is Within (id "Disc" P2) in:(sites Around (to))))
)

(define "WhiteVC" (is Full))

(define "BlackVC" (is Loop))

(define "HexCorners"
    (start 
        {
        (place "Disc2" 
            { 0 
            (- (/ (- (* {3 #1 #1}) #1) 2) 1) 
            (+ 1 (- (* {3 #1 #1}) (* 4 #1))) 
            }
        )
        (place "Disc2" 
            {(- #1 1) 
            (+ 1 (/ (- (* {3 #1 #1}) (* 5 #1)) 2)) 
            (- (* {3 #1 #1}) (* 3 #1)) 
            }
        )
        }
))

(define "Skip"
    (move Set NextPlayer (player (next)))
)

(define "LimpCorners"
    (start 
        {
        (place "Disc2" 
            { 0 
            (- (/ (+ (* {3 #1 #1}) #1) 2) 1) 
            (- (* 3 (* #1 #1)) #1) 
            }
        )
        (place "Disc2" 
            { #1
            (/ (- (* {3 #1 #1}) (* 3 #1)) 2)
            (- (* 3 (* #1 #1)) 1) 
            }
        )
        }
))

(define "IsPlayingPhase" (= 1 (var)))

(game "Coil" 
    (players 2) 
    (equipment { 
        (board (hex <Boundary:shape> <Board:size>)) 
        (piece "Disc" Each) 
    }) 
    (rules 
        <Boundary:cornerSetup>
        phases: {
        (phase "Opening"
            (play
                (or
                    (or
                        (move Add 
                            (piece (id "Disc" P2)) 
                            (to (sites Empty) if:"NonAdjacent")
                            (then (if (< (count MovesThisTurn) 2) (moveAgain)))
                        )
                        "Skip"
                    )
                    (if (= (count MovesThisTurn) 0)
                        (move Pass
                            (then
                                (if (is Mover P1)
                                    (swap Players P1 P2
                                        (then
                                            (note "Player 1 is now Black. Player 2 is now White." to:All)
                                        )
                                    )
                                    (note "Player 1 remains White. Player 2 remains Black." to:All)
                                    (then
                                        (do
                                            (set NextPlayer (player 1))
                                            next:(set Var 1) // (var) represents the phase here
                                        )
                                    )
                                )
                            )
                    ))
                )
            )
            (nextPhase ("IsPlayingPhase") "Playing")
        )
        (phase "Playing" (play (move Add (to (sites Empty)))))
        }
        (end 
            (forEach Player
                if:(and {("IsPlayingPhase") (= (id Player) (mover)) ("BlackVC")})
                (result Player Win)
            )
        )
    )
)

//------------------------------------------------------------------------------

(option "Board Shape" <Boundary> args: { <shape> <cornerSetup> }
    {
    (item "Hexhex-corners" <Hexagon> <("HexCorners" "Size")> "Played on a Hexagonal Board, pre-filled corners.")
    (item "Limping-corners" <Limping> <("LimpCorners" "Size")> "Played on a Hexagonal (N,N+1 edged) Board, pre-filled corners.")
    }
)

(option "Board Size" <Board> args:{ <size> } {
    (item "7" <7> "The game is played on a board with 7 hexes per side.")**
    (item "8" <8> "The game is played on a board with 8 hexes per side.")
    (item "9" <9> "The game is played on a board with 9 hexes per side.")
    (item "10" <10> "The game is played on a board with 10 hexes per side.")
    (item "11" <11> "The game is played on a board with 11 hexes per side.")
    (item "12" <12> "The game is played on a board with 12 hexes per side.")
})

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Coil is an asymmetrical but balanced 2-player connection game on a hexhex7 (or larger) board, where one player tries to form a loop of stones in his color, and the other tries to stop him.  There's a chicken ballot at the start to ensure that the two sides are balanced. Because loops come in a wide range of sizes and shapes, and have many degrees of freedom, the game has rich tactics and strategy.  Small loops threats force players to focus on local battles while large loop threats force them to think globally, and to consider how the local battles fit into the global war. Wise stone placements can contribute to the creation of multiple loops or to defense against multiple loops, leading to layered, multi-dimensional consequences for each turn.")
        (rules "This game is played on a hexagonal board made up of hexagonal cells, usually 7 cells per side, although bigger sizes may also be used. Initially the board is empty except for the six corner cells, upon which black stones are placed.  Then the players take it in turns to place 1-3 black stones each turn until one decides to pass; that player then becomes Black, and the other becomes White.  After that, players take it in turns to place one stone of their colour on the board on any empty hex.  If Black forms a continuous loop composed of their pieces, they win; if the board fills up with no loop of Black pieces being formed, White wins.
            
        During the initial chicken ballot phase, you may add stones by clicking on available spaces, or skip the rest of your placements (by choosing the Next Player action).  Alternatively, you may Pass at the start of your turn to take Black.  After that, you and your opponent will alternate playing one stone of your colour per turn, until the board is full or Black forms a loop.")
        (id "1390")
        (version "1.3.11")
        (classification "board/space/connection")
        (author "Nick Bentley (used with permission)")
        (credit "Eric Silverman")
        (date "2009")
        }
    )
    
    (graphics {
        (board Colour Phase0 (colour 223 178 110))
        (board Colour InnerEdges (colour Black))
        (board Colour OuterEdges (colour Black))
    })
    
    (ai
        "Coil_ai"
    )
)













(define "WhiteVC" 
    (is Connected All {(sites Side N) (sites Side S) (sites Side E) (sites Side W)})
)

(define "BlackVC"
    (or
        (is Connected Orthogonal {(sites Side N) (sites Side S)})
        (is Connected Orthogonal {(sites Side E) (sites Side W)})
    )
)

(define "IsPlayingPhase" (= 1 (var)))

(define "Skip"
    (move Set NextPlayer (player (next)))
)

//-----------------------------------------------------------------------------------

(game "Pippinzip" 
    (players 2) 
    (equipment { 
        (board (square <Board:size>) use:Vertex) 
        (piece "Disc" Each) 
    }) 
    (rules 
        phases:{
        (phase "Opening"
            (play
                (or
                    (or
                        (move Add 
                            (piece (id "Disc" P2)) 
                            (to (sites Empty))
                            (then (if (< (count MovesThisTurn) 2) (moveAgain)))
                        )
                        "Skip"
                    )
                    (if (= (count MovesThisTurn) 0)
                        (move Pass
                            (then
                                (if
                                    (is Mover P1)
                                    (swap Players P1 P2
                                        (then
                                            (note "Player 1 is now Black. Player 2 is now White." to:All)
                                        )
                                    )
                                    (note "Player 1 remains White. Player 2 remains Black." to:All)
                                    (then
                                        (do (set NextPlayer (player 1))
                                            next:(set Var 1) // (var) represents the phase here
                                        )
                                    )
                                )
                            )
                    ))
                )
            )
            (nextPhase ("IsPlayingPhase") "Playing")
        )
        (phase "Playing"
            (play (move Add (to (sites Empty))))
        )
        }
        (end {
            (if (and (not ("IsPlayingPhase")) ("BlackVC")) (result Mover Win))
            (if (and {(= (id P2) (mover)) ("BlackVC")}) (result P2 Win))
            (if (and {(= (id P1) (mover)) ("WhiteVC")}) (result P1 Win))
        })
    )
)

//------------------------------------------------------------------------------

(option "Board Size" <Board> args:{ <size> }
    {  
    (item "5" <5> "Played on a size 5 board.") 
    (item "6" <6> "Played on a size 6 board.") 
    (item "7" <7> "Played on a size 7 board.") 
    (item "8" <8> "Played on a size 8 board.") 
    (item "9" <9> "Played on a size 9 board.") 
    (item "10" <10> "Played on a size 10 board.") 
    (item "11" <11> "Played on a size 11 board.") 
    (item "12" <12> "Played on a size 12 board.") 
    (item "13" <13> "Played on a size 13 board.")** 
    (item "14" <14> "Played on a size 14 board.") 
    (item "15" <15> "Played on a size 15 board.") 
    (item "16" <16> "Played on a size 16 board.") 
    (item "17" <17> "Played on a size 17 board.") 
    (item "18" <18> "Played on a size 18 board.") 
    (item "19" <19> "Played on a size 19 board.") 
    }
)

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Pippinzip is a square-board connection game for two players.  This is the 'Pipline' variant, the standard version of the game.  The game starts with a chicken ballot phase similar to Unlur, in which players both place 1-3 Black stones per turn until one decides to pass their turn and take Black.  Subsequently, the players place one stone per turn of their colour on any empty point.  The Black player ('Pip') wins if they connect any two sides of the board with a single orthogonally-connected group of stones.  The White player ('Zip') wins if they connect all four sides of the board with a single group connected both orthogonally and diagonally.")
        (rules "This game is played on a square grid board of any size, though 13x13 or 19x19 are recommended. Then the players take it in turns to place 1-3 black stones each turn until one decides to pass; that player then becomes Black, and the other becomes White.  After that, players take it in turns to place one stone of their colour on the board on any empty point.  If Black connects any two sides of the board with a single orthogonally-connected group, they win; White wins if they connect all four sides with a group connected either orthogonally or diagonally.
            
        During the initial chicken ballot phase, you may add stones by clicking on available spaces, or skip the rest of your placements (by choosing the Next Player action).  Alternatively, you may Pass at the start of your turn to take Black.  After that, you and your opponent will alternate playing one stone of your colour per turn, until one player forms a connection (draws are impossible in Pippinzip).")
        (id "1404")
        (source "<a href=\"https://boardgamegeek.com/boardgame/298409/pippinzip\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />BGG</a>")
        (version "1.3.11")
        (classification "board/space/connection")
        (author "Craig Duncan, JoÃ£o Pedro Neto, Bill Taylor (used with permission)")
        (credit "Eric Silverman")
        (date "2020")
        }
    )
    
    (graphics {
        (board Style Go)
        (player Colour P1 (colour White))
        (player Colour P2 (colour Black))
    }) 
    (ai
        "Pippinzip_ai"
    )
)

)

















// #1,#2 - sides (S, N, NE, NW, SE, SW)
// #3 optional 3rd region
(define "IsSidesConnected"
    (is Connected {(sites Side #1) (sites Side #2) #3})
)

(define "WhiteVC" 
    (or {
        ("IsSidesConnected" S N)
        ("IsSidesConnected" SW NE)
        ("IsSidesConnected" SE NW)
    })
)

(define "BlackVC" 
    (or
        ("IsSidesConnected" S NW (sites Side NE))
        ("IsSidesConnected" N SW (sites Side SE))
    )
)

(define "IsPlayingPhase" (= 1 (var)))

(game "Unlur" 
    (players 2) 
    (equipment { 
        (board (hex <Board:size>)) 
        (piece "Disc" Each) 
    }) 
    (rules 
        phases:{
        (phase "Opening"
            (play
                (or
                    (move Add
                        (piece (id "Disc" P2))
                        (to <Edge:target_zone>)
                    )
                    (move Pass
                        (then
                            (if (is Mover P1)
                                (swap Players P1 P2
                                    (then
                                        (note "Player 1 is now Black. Player 2 is now White." to:All)
                                    )
                                )
                                (note "Player 1 remains White. Player 2 remains Black." to:All)
                                (then
                                    (do
                                        (set NextPlayer (player 1))
                                        next:(set Var 1) // (var) represents the phase here
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase ("IsPlayingPhase") "Playing")
        )
        (phase "Playing"
            (play (move Add (to (sites Empty))))
        )
        }
        (end {
            (if (and {("IsPlayingPhase") (= (id P1) (mover)) ("BlackVC") (not ("WhiteVC"))}) (result P1 Loss)) 
            (if (and {("IsPlayingPhase") (= (id P2) (mover)) ("WhiteVC") (not ("BlackVC"))}) (result P2 Loss)) 
            (if (and {("IsPlayingPhase") (= (id P1) (mover)) ("WhiteVC")}) (result P1 Win)) 
            (if (and {("IsPlayingPhase") (= (id P2) (mover)) ("BlackVC")}) (result P2 Win)) 
        })
    )
)

(option "Board Size" <Board> args:{ <size> } {
    (item "6" <6> "The game is played on a board with 6 hexes per side.")**
    (item "7" <7> "The game is played on a board with 7 hexes per side.")
    (item "8" <8> "The game is played on a board with 8 hexes per side.")
    (item "9" <9> "The game is played on a board with 9 hexes per side.")
    (item "10" <10> "The game is played on a board with 10 hexes per side.")
    (item "11" <11> "The game is played on a board with 11 hexes per side.")
})

(option "Edge Rule" <Edge> args:{ <target_zone> } {
    (item "No Restriction" <(sites Empty)> "You may place stones on the edge in the opening phase.")
    (item "Edge Restriction" <(intersection (sites Empty) (sites Inner))> "You cannot place stones on the edge in the opening phase.")**
})

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "Unlur is a game between two people taking turns placing tiles on a hexagonal board. Each player has a different objective to achieve victory. It is classified as an abstract, connecting and unequal forces board game.This game was the winner of the second Annual Game Design Competition in 2002, whose theme that year was the design of games of unequal forces (organized by Abstract Games magazine, About Board Games, and the Strategy Gaming Society). The name came from a symmetric ancestor game called 'Lur'. When the game was supported on Ludoteka, the Edge rule was added because placing on the edge is usually bad for Black. More information about the origins of the game can be found in Spanish on the designer's blog:<a href=\"http://mesadejuegos.blogspot.com/2005/12/unlur.html\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />mesadejuegos.blogspot.com</a> ")
        (rules "This game is played on a hexagonal board made up of hexagonal squares, usually 6 squares per side, although other sizes are possible. Initially the board is empty and black pieces are placed in turns until one player passes. The player who passed becomes Black. The other player becomes White and takes the next turn. Play continues, with each player in turn placing pieces of their colour on unoccupied squares on the board. White wins if they manage to connect two opposite sides of the board. Black wins if they manage to connect three non-adjacent sides of the board. To avoid ties, if a player meets the opponent's goal with their pieces, they lose the game.")
        (id "1226")
        (source "<a href=\"https://fr.wikipedia.org/wiki/Unlur\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (version "1.3.11")
        (classification "board/space/connection")
        (author "Jorge Gómez Arrausi")
        (credit "Nicholas Bamber")
        (date "2002")
        }
    )
    
    (graphics {
        (board Colour Phase0 (colour 223 178 110))
        (board Colour InnerEdges (colour Black))
        (board Colour OuterEdges (colour Black))
    })
    
    (ai
        "Unlur_ai"
    )
)














(define "FriendlyInSight" 
    (count Sites in:(intersection (sites Occupied by:Mover) (sites LineOfSight at:(last From))))
)

(define "PlayableSites" 
    (forEach
        (sites Board)
        if:(>
            (count Sites in:(intersection (sites Occupied by:Mover) (sites LineOfSight at:(site))))
            (size Stack at:(site))
        )
    )
)

(define "TerritoryP1"
    (+ 
        (count Sites 
            in:(sites Occupied by:P1)
        )
        (count Sites
            in:(forEach
                (sites Empty)
                if:(>
                    (count Sites in:(intersection (sites Occupied by:P1) (sites LineOfSight at:(site))))
                    (count Sites in:(intersection (sites Occupied by:P2) (sites LineOfSight at:(site))))
                )
            )
        )
    )
)

(define "TerritoryP2"
    (+ 
        (count Sites 
            in:(sites Occupied by:P2)
        )
        (count Sites
            in:(forEach
                (sites Empty)
                if:(>
                    (count Sites in:(intersection (sites Occupied by:P2) (sites LineOfSight at:(site))))
                    (count Sites in:(intersection (sites Occupied by:P1) (sites LineOfSight at:(site))))
                )
            )
        )
    )
)

//------------------------------------------------------------------------------

(game "Tumbleweed"
    (players 2)
    (equipment {
        (board (hex <Board>))
        (piece "Disc" Each)
        (piece "Disc" Neutral)
    })
    (rules
        (start (place Stack "Disc0" (centrePoint) count:2))
        phases:{
        (phase "Opening" 
            (play
                (if (= 0 (count Moves))
                    (move Add (piece "Disc1") (to (sites Empty)) (then (moveAgain)))
                    (if (= 1 (count Moves))
                        (move Add (piece "Disc2") (to (sites Empty)))
                        (move Select (from (union (sites Occupied by:P1) (sites Occupied by:P2)))
                            (then 
                                (if (= 1 (who at:(last From)))
                                    (do (swap Players 1 2) next:(set NextPlayer (player 1)))
                                    (pass)
                                )
                            )
                        )
                    )
                )
            )
            (nextPhase (= 3 (count Moves)) "Play")
        )
        (phase "Play"
            (play
                (or 
                    (move Select (from "PlayableSites")
                        (then
                            (add (to (last From)) count:(- "FriendlyInSight" ((size Stack at:(last From)))) stack:True)
                        )
                    )
                    (move Pass)
                )
            )
        )
        }
        (end
            (if
                (all Passed)
                (byScore {
                    (score P1 "TerritoryP1")
                    (score P2 "TerritoryP2")
                })
            )
        )
    )
)

//------------------------------------------------------------------------------

(option "Board Size" <Board> args:{ <size> }
    {
    (item "5" <5> "Played on a size 5 board.") 
    (item "6" <6> "Played on a size 6 board.") 
    (item "7" <7> "Played on a size 7 board.") 
    (item "8" <8> "Played on a size 8 board.")* 
    (item "9" <9> "Played on a size 9 board.")
    (item "10" <10> "Played on a size 10 board.") 
    (item "11" <11> "Played on a size 11 board.") 
    }
)

//------------------------------------------------------------------------------

(metadata
    
    (info
        {
        (description "Far-ranging stacks compete for all territory in sight.")
        (rules "Tumbleweed is played with stackable tokens on a hexhex board.
            
            A stack is said to be seen from a hex when they are connected by a straight line, with no stacks in between.
            
            The players take turns settling hexes by placing a stack of their tokens on a hex of their choice. The height of a new stack is equal to the number of friendly stacks seen from the settled hex. Removing a stack occupying a hex and re-settling it with a new stack is possible, only as long as the new stack is taller than the previous one. This works with opponent stacks (to capture), or your own stacks (to reinforce).
            
            The board is initially empty, except for a central neutral (blue) two-stack. The first player sets up initial one-stacks: White and Red. The second player then chooses which side he wants to play, by clicking on a stone. Red goes first.
            
        The game ends when no more moves can be made by either player, or after two successive passes. The player who occupies over half the board wins. The program automatically scores indirectly controlled territory.")
        (id "963")
        (version "1.3.11")
        (classification "board/space/territory")
        (author "Mike Zapawa")
        (publisher "Mike Zapawa")
        (credit "Designer: Mike Zapawa. Implemented by Michael Amundsen and Alek Erickson")
        (date "2020")
        }
    )
    
    (graphics {
        (player Colour Neutral (colour Blue))
        (player Colour P1 (colour Red))
        (player Colour P2 (colour Cream))
        (stackType Count)
    })
)




(define "ColumnSize" 6)

(define "EmptyTop" (intersection (sites Top) (sites Empty)))

(define "LastColumn" (sites Column (column of:(last To))))

(define "Distance" (count Sites in:(intersection (sites Empty) "LastColumn")))

(define "Drop" (slide (from (last To)) S (between (exact "Distance"))))

//------------------------------------------------------------------------------

(game "Connect Four" 
    (players 2) 
    (equipment { 
        <Model:board>
        (piece "Disc" Each)
    }) 
    
    (rules
        <Model:rules>
    )
)

//------------------------------------------------------------------------------

(option "Modelisation" <Model> args:{ <board> <rules> }
    {
    (item "1D"  
        <(board (rectangle 1 7))>
        < 
        (play 
            (move Add 
                (to 
                    (forEach 
                        (sites Board) 
                        if:(< (size Stack at:(site)) "ColumnSize")
                    ) 
                )
                stack:True
            )
        )
        (end (if (is Line 4 byLevel:True) (result Mover Win)))
        >
        ""
    )** 
    (item "2D"   
        <(board (rectangle 6 7))>
        <
        (play 
            (move Add 
                (to ("EmptyTop"))
                (then "Drop")
            )
        )
        (end (if (is Line 4 through:(last To afterConsequence:True)) (result Mover Win)))
        >
        ""
    ) 
})

(metadata
    
    (info
        {
        (description "Connect Four is a two-player connection game that was designed by Howard Wexler and Ned Strongin, and was first sold under this name by Milton Bradley in 1974.")
        (aliases {"Four Up" "Plot Four" "Find Four" "Four in a Row" "Four in a Line" "Drop Four" "Gravitrips"})
        (rules "Connect 4 is played on a vertically placed grid of 7x6, where colored disks are dropped from the top of the grid. Players alternate dropping discs, which fall to the bottom of the column in which they are dropped. The first player to create a row of four disks in their color wins.")
        (source "<a href=\"https://en.wikipedia.org/wiki/Connect_Four\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (id "87")
        (version "1.3.11")
        (classification "board/space/line")
        (author "Howard Wexler, Ned Strongin")
        (publisher "Milton Bradley / Hasbro")
        (credit "Eric Piette")
        (date "1974")
        }
    )
    
    (graphics {
        (player Colour P1 (colour Yellow))
        (player Colour P2 (colour Red))
        (useFor {"Modelisation/1D"} (stackType None))
        (useFor {"Modelisation/1D"} (board Style Connect4))
        (no Animation)
    })
    
    (ai 
        "Connect Four_ai"
    )
    
)












(game "Gobblet Gobblers"
    (players 2) 
    (equipment { 
        (board (square 3))
        (piece "Disc1" Each)
        (piece "Disc2" Each)
        (piece "Disc3" Each)
        (hand Each size:3)
    }) 
    (rules 
        (start {
            (place Stack "Disc11" (handSite P1) count:3)
            (place Stack "Disc12" (handSite P2) count:3)
            (place Stack "Disc21" (handSite P1 1) count:3)
            (place Stack "Disc22" (handSite P2 1) count:3)
            (place Stack "Disc31" (handSite P1 2) count:3)
            (place Stack "Disc32" (handSite P2 2) count:3)
        })
        (play
            (or
                ("MoveToEmptyOrOccupiedByLargerPiece" (sites Hand Mover) if:(is Occupied (from)))
                ("MoveToEmptyOrOccupiedByLargerPiece" (sites Occupied by:Mover top:True))
            )
        )
        
        (end 
            (forEach Player
                if:(is Line 3 Player top:True)
                (result Player Win)
            )
        )
    )
)

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "A variant of Tic-Tac-Toe using stacks.")
        (rules "Your goal in Gobblet Junior is to place three of your pieces in a horizontal, vertical or diagonal row. Your pieces can stack on top of each other, and they start the game nested, off the board. On a turn, you either play one exposed piece from your three off-the-board piles or move one piece on the board to any other spot on the board where it fits. A larger piece can cover any smaller piece.
            
        Your memory is tested as you try to remember which color one of your larger pieces is covering before you move it. As soon as a player has three like-colored pieces in a row, he wins.")
        (id "2000")
        (source "<a href=\"https://boardgamegeek.com/boardgame/13230/gobblet-gobblers\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />BGG</a>")
        (version "1.3.11")
        (classification "board/space/line")
        (author "Thierry Denoual")
        (credit "Eric Piette")
        (date "2003")
        }
    )
    
    (graphics {
        (player Colour P1 (colour Blue))
        (player Colour P2 (colour Red))
        (piece Scale "Disc11" 1.0)
        (piece Scale "Disc21" 0.6)
        (piece Scale "Disc31" 0.4)
        (piece Scale "Disc12" 1.0)
        (piece Scale "Disc22" 0.6)
        (piece Scale "Disc32" 0.4)
        (stackType None)
    })
)














(define "Select"
    (move Select
        (from (sites Occupied by:Mover top:True))
        (to
            (sites Direction from:(from) 
                Orthogonal
                stop:(= (next) (who at:(to)))
                stopIncluded:True
                distance:(size Stack at:(from))
            )
            if:(>=
                (count Steps (from) (to))
                (size Stack at:(to))
            ) 
        )
        #1
    )
)

(define "Move"
    (and
        (fromTo 
            (from (last From))
            (to (last To))
            count:(count Steps (last From) (last To))
            stack:True
        )
        (add 
            (to (last To)) 
            stack:True
        )
    )
)

//------------------------------------------------------------------------------

(game "Lava"
    (players 2)
    (equipment {
        (board (rotate 30 (hex <Board>)))
        (piece "Disc" Each)
    })
    (rules
        (start {
            (place "Disc1" (min (array (sites Board))))
            (place "Disc2" (max (array (sites Board))))
        })
        (play ("Select" (then ("Move"))))
        (end 
            (if (is Full) 
                (byScore {
                    (score P1 (count Sites in:(sites Occupied by:P1 top:True)))
                    (score P2 (count Sites in:(sites Occupied by:P2 top:True)))
                })
            )
        )
    )
)

//------------------------------------------------------------------------------

(option "Board Size" <Board> args:{ <board> }
    {
    (item "4" <4> "A size 4 board is currently selected")*
    (item "5" <5> "A size 5 board is currently selected")
    }
)

(option "Show Stack Size As Number" <Stack> args:{ <stack> }
    {
    (item "No" <Default 0.6> "The number of pieces in a stack is currently not shown on the top piece.")*
    (item "Yes" <DefaultAndCount 0.6> "The number of pieces in a stack is shown on the top piece.")
    }
)

//------------------------------------------------------------------------------

(metadata
    (info
        {
        (description "Lava is a territorial stacking game invented by Alek Erickson and Michael Amundsen in August 2021.")
        (rules "Lava is a territorial stacking game for two players, Red and Black. Play using a Hexhex board size 4 or 5, and a sufficient supply of Red/Black stacking checkers. To setup, place one Red and one Black checker in opposite corners of the hex hex board.
            
            Definitions:
            Stack: One or more checkers occupying the same cell.
            Control: You control a stack if your color is on top of it.
            
            Players take turns, with Black moving first.
            
            Each turn, take N checkers (where N is any number from 1 to stack size) from the top of a stack you control and move them N spaces in a straight line to a destination containing N or less checkers. Then, add a new checker of your color to the destination. Stacks may not jump over enemies, but may land on enemy or friendly stacks, thereby burying them.
            
            If you at any point cannot make a move, you must pass. This does not end the game, only your turn.
            
        When the board is full, the player controlling more stacks wins the game.")
        (id "1651")
        (version "1.3.11")
        (classification "board/space/territory")
        (author "Alek Erickson and Michael Amundsen")
        (credit "Michael Amundsen")
        (date "2021")
        }
    )
    
    (graphics {
        (player Colour P1 (colour DarkGrey))
        (player Colour P2 (colour Red))
        (region Colour (sites Board) (colour 250 210 148))
        (board Colour InnerEdges (colour 178 151 100))
        (board Colour OuterEdges (colour 178 151 100))
        (stackType <Stack>)
    })
)



















(define "Who" (= (id Mover) 1))
(define "RingsAreEmpty"  (no Pieces All in:(sites "Rings")))
(define "PlayerHasReserve" (not (no Pieces in:(sites Mover "Reserve"))))
(define "PlayerHasStarters" (not (no Pieces in:(sites Mover "Base"))))
(define "PlayerHasPrisoners" (not (no Pieces in:(sites Mover "Prison"))))
(define "PieceDef" (piece Foreground #1 image:"triangle" fillColour:(colour #2) edgeColour:(colour Black) scaleX:0.35 scaleY:0.65 offsetY:+0.94))
(define "Pips+-" (if "Who" (mapEntry <Starter:Pip1> #1)(mapEntry <Starter:Pip2> #1)))
(define "PipsCap"  (if "Who" (mapEntry <Starter:Pip2> (last To))(mapEntry <Starter:Pip1> (last To))))
(define "Captured" (>  (size Stack at:(last To)) (value Piece at:(last To)) ))
(define "StartAttack" (move (from (sites Mover "Base"))(to (intersection (sites #1 #2) (sites Empty))) "StartThen" )  )
(define "PrisTrans" (add (piece (id #1 Mover))(to (sites Mover #2 ))
count:(count Stack at:(last To) if:(= (id "Cone" #3)(what at:(to) level:(level)))) stack:True ))
(define "Extinction" (and { (no Moves Next)
        (= 0 (count Sites in:(intersection (sites Occupied by:Next) (sites "RingsplusBase") )) )
        (< (count Sites in:(sites Occupied by:Next)) 2)
    })
)
(define "StartMove" (if (= 1 (var "StartS")) (move (from (sites Mover "Base"))
        (to (difference (sites Mover "HomeRing") (mapEntry "SameColor" (last To)))) "StartThen")
        (if (and (= 2 (var "StartS")) (= 1 (var "CntrAttack")))
            ("StartAttack" ~ "Rings" )
            ("StartAttack" Mover "HomeRing" )
        )
    )
)

(define "StartThen"
    (then
        (and {
            (promote (last To) (piece {"Cone"}) Mover)
            (set Var "StartS" (+ 1 (var "StartS")))
            
            (if (= 0 (var "StartS")) (set Var "St1Pos" (last To)))
            (if (and (= 1 (var "StartS"))
                    (or (= (mapEntry "Attacks1" (last To)) (var "St1Pos"))
                    (= (mapEntry "Attacks2" (last To)) (var "St1Pos")) )
                )
                (set Var "CntrAttack" 1)
            )
            (if (> (var "StartS") 2) (set Var "CntrAttack" 0))
            (if (and {(is Friend (who at:(mapEntry "SameColor" (last To))))
                    (!= 1 (var "CntrAttack"))
                    "PlayerHasReserve"
                })
                (and (add (piece (id "Starter" Mover))(to (sites Mover "Base")) stack:True)
                    (remove (sites Mover "Reserve"))
                )
            )
            (set Value at:(last To) 1)
            (addScore Mover ("Pips+-" (last To)))
        })
    )
)
(define "MoveThen" (then (and { (set Var "StartS" 3) (set Var "CntrAttack" 0 )
            (if (= 15 (last To))
                (and {("PrisTrans" "Starter" "Base" Mover)
                    ("PrisTrans" "Prisoner" "Prison" Next)
                    (remove 15 count:(count Stack at:(last To)))
                })
                
                (if (and (is Friend (who at:(mapEntry "SameColor" (last To))))
                        "PlayerHasReserve"
                    )
                    (and (remove (sites Mover "Reserve"))
                        (add (piece (id "Starter" Mover))(to (sites Mover "Base")) stack:True)
                    )
                )
            )
            (set Value at:(last To) (count Stack at:(last To)))
            
            (addScore Mover (- ("Pips+-" (last To)) ("Pips+-" (last From)) ) )
            (if "Captured"(addScore Next (- 0 "PipsCap"  )))
        })
    )
)

(define "PrisonerExchange"
    (if (and (no Pieces in:(sites Mover "Base"))
            "PlayerHasReserve"
        )
        (move (from ) (to (sites Mover "Base")) )
        
        (then 
            (and {(promote (last To) (piece "Starter") Mover )
                (remove (sites Mover "Reserve"))
                (add (piece (id "Reserve" Next))(to (sites Next "Reserve")) stack:True)
                (moveAgain)
            })
        )
    )
)

(define "IsSelfStaleLastManLoop"
    (and { (no Moves Next)
        (no Pieces in:(sites Mover "Reserve"))
        (no Pieces in:(sites Mover "Base"))
        (= 1 (count Pieces Mover in:(intersection (sites "Rings")(sites Occupied by:Mover )) ) )
    })
)

(define "IsLastMan"
    (and { (no Pieces in:(sites Mover "Base") )
        (= 1 (count Sites in:(intersection (sites "Rings") (sites Occupied by:Mover))  ))
        (= 1 (size Stack at:(regionSite (intersection (sites Occupied by:Mover)(sites Mover "SitesLastMan")) index:0)) )
        "PlayerHasReserve"
    })
)
(define "LastMan"
    (move 
        (from ) (to 15)
        (then
            (and {(set Var "CntrAttack" 0)
                (set Score Mover 0)
                (remove 15 )
                (remove (sites Mover "Reserve"))
                (add (piece (id "Starter" Mover))(to (sites Mover "Base")) count:2 stack:True)
            })
    ))
)

(define "PiP" (board Foreground image:"disc" fillColour:(colour #1) edgeColour:(colour Black) scale:0.04 offsetX:#2 offsetY:#3) )
(define "DiscX" (board Foreground image:"disc" fillColour:#1 edgeColour:#2 scale:#3 offsetX:#4 offsetY:#5) )
(define "SquaS" (board Foreground image:"square" fillColour:#1 edgeColour:(colour Black) scale:0.138 offsetX:#2 offsetY:#3) )
(define "SquaX" (board Foreground image:"square" fillColour:#1 edgeColour:#2 scaleX:#3 scaleY:#4 offsetX:#5 offsetY:#6) )
(define "RectS" (board Foreground image:"rectangle" fillColour:(colour #1) edgeColour:(colour #2) scaleX:#3 scaleY:#4 offsetX:#5 offsetY:#6) )
(define "RectX" (board Foreground image:"rectangle" fillColour:#1 edgeColour:#2 scaleX:#3 scaleY:#4 offsetX:#5 offsetY:#6) )
(define "Minu" (board Foreground image:"minus" fillColour:#1 edgeColour:#2 scaleX:#3 scaleY:#4  rotation:#5 offsetX:#6 offsetY:#7) )
(define "G1" (colour 239 231 182)) (define "G2" (colour 210 189 048)) (define "LG" (colour LightGrey))
(define "Bl" (colour Black)) (define "Wh" (colour White))
(define "RingOrT"  (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT") )) 
(define "CaptPos"  (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty))(array {(mapEntry #1 (from)) }) ) index:0)))

(define "MoveSteps"
    (move (from)
        (to (union {
                (intersection { 
                    (difference "RingOrT" (from))
                    (sites Empty)
                    (sites { (mapEntry #1 (from)) (mapEntry #2 (from)) (mapEntry #3 (from)) (mapEntry #4 (from))
                    (mapEntry #5 (from)) (mapEntry #6 (from)) (mapEntry #7 (from)) (mapEntry #8 (from)) })
                })
                (intersection {
                    (sites "Rings")(sites Occupied by:Next)
                    (sites { ("CaptPos" #1) ("CaptPos" #2)("CaptPos" #3) ("CaptPos" #4)
                        ("CaptPos" #5) ("CaptPos" #6)("CaptPos" #7) ("CaptPos" #8) (mapEntry #9  (from))
                    })
                })
            })
        ) 
        stack:True   "MoveThen"
    )
)

(define "ConeMove"
    (if (< (score Mover) 16)
        (if (< (score Mover) 8)
            (if (< (score Mover) 4)
                (if (< (score Mover) 2)
                    (if (= (score Mover) 1)
                        ("MoveSteps"  "Step7a" "Step7b" "Step1c" ~   ~ ~ ~ ~     ~ )
                    )
                    (if (= (score Mover) 2)
                        ("MoveSteps"  "Step2a" "Step2b" "Step2c" ~   ~ ~ ~ ~        ~ )
                        ("MoveSteps"  "Step3a" "Step3b" "Step3c" "Step3d"   ~ ~ ~ ~        ~ )
                    )
                )
                (if (< (score Mover) 6)
                    (if (= (score Mover) 4)
                        ("MoveSteps"  "Step4a" "Step4b" "Step4c" ~   ~ ~ ~ ~             ~ )
                        ("MoveSteps"  "Step3a" "Step3b" "Step5c" "Step5d"  ~ ~ ~ ~          ~ )
                    )
                    (if (= (score Mover) 6)
                        ("MoveSteps"  "Step2a" "Step2b" "Step6c" "Step6d"  "Step6e"  ~ ~ ~     ~ )
                        ("MoveSteps"  "Step7a" "Step7b" "Step7c" "Step7d"  "Step7e"  ~ ~ ~      ~ )
                    )
                )
            )
            (if (< (score Mover) 12)
                (if (< (score Mover) 10)
                    (if (= (score Mover) 8)
                        ("MoveSteps"  "Step8a" "Step8b" "Step8c" "Step8d"  ~ ~ ~ ~        "SameColor" )
                        ("MoveSteps"  "Step7a" "Step7b" "Step9c" "Step9d"  "Step9e" "Step9f" ~ ~      ~ )
                    )
                    (if (= (score Mover) 10)
                        ("MoveSteps"  "Step2a" "Step2b" "Step10c" "Step10d"  "Step10e"  ~ ~ ~                 ~ )
                        ("MoveSteps"  "Step3a" "Step3b" "Step11c" "Step11d"  "Step11e" "Step11f" "Step11g" ~    ~ )
                    )
                )
                (if (< (score Mover) 14)
                    (if (= (score Mover) 12)
                        ("MoveSteps"  "Step4a" "Step12b" "Step12c" "Step12d"  "Step12e" "Step12f"  ~ ~      "Step12g" )
                        ("MoveSteps"  "Step3a" "Step3b" "Step13c" "Step13d"  "Step13e" "Step13f" "Step11g" ~      ~ )
                    )
                    (if (= (score Mover) 14)
                        ("MoveSteps"  "Step2a" "Step2b" "Step14c" "Step14d"  "Step14e" ~ ~ ~                    "Step14f" )
                        ("MoveSteps"  "Step7a" "Step7b" "Step15c" "Step15d"  "Step15e" "Step15f" "Step11f" "Step11g"   ~  )
                    )
                )
            )
        )  //  ( >= 16 ) :
        (if (< (score Mover) 20)
            (if (< (score Mover) 18)
                (if (= (score Mover) 16)
                    ("MoveSteps"  "Step8a" "Step8b" "Step16c" "Step16d"  "Step16e" "Step16f" "Step16g" ~    "SameColor" )
                    ("MoveSteps"  "Step7a" "Step7b" "Step17c" "Step17d"  "Step17e" "Step17f" "Step17g" "Step17h"   ~ )
                )
                (if (= (score Mover) 18)
                    ("MoveSteps"  "Step2a" "Step2b" "Step18c" "Step18d"  "Step18e" "Step18f" ~ ~     "Step18g" )
                    
                    (and ("MoveSteps"  "Step3a" "Step3b" "Step19c" "Step19d"  "Step19e" "Step19f" "Step19g" "Step19h" ~ )
                    ("MoveSteps"  "Step19i" ~ ~ ~  ~ ~ ~ ~  ~  )    )
                )
            )
            (if (= 20 (score Mover) )("MoveSteps"  "Step4a" "Step20b" "Step20c" "Step20d"  "Step20e" "Step20f" "Step20g" ~ "SameColor" ) ) // Max=20 !
        )
    )
)

(game "MensaSpiel"
    (players 2)
    (equipment { (board (remove (rectangle 5 7) cells:{2 4  7 8 9   11 12 13   17 31} )  )
        
        (regions "Base" P1   {<Starter:Bas1>})     (regions "Base" P2   {<Starter:Bas2>})
        (regions "Prison" P1 {<Starter:Pri1>})     (regions "Prison" P2 {<Starter:Pri2>})
        (regions "Reserve" P1 {<Starter:Res1>})    (regions "Reserve" P2 {<Starter:Res2>})
        (regions "HomeRing" P1 <Starter:Hom1>)     (regions "HomeRing" P2 <Starter:Hom2>)
        (regions "SitesLastMan" P1 <Starter:Las1>) (regions "SitesLastMan" P2 <Starter:Las2> )
        (regions "Rings" {6..12 14 16 18..24}) (regions "RingsplusT" {6..12 14 15 16 18..24}) (regions "RingsplusBase" {6..24})
        
        (map "PipsP1" {6..24} {4 1 3 2 2 1 2 0 3 0 1 0 1 3 2 2 2 0 3})
        (map "PipsP2" {6..24} {0 3 1 2 2 3 2 0 1 0 3 0 3 1 2 2 2 4 1})
        (map "Attacks1" {6..24} {10 23 9 12 8 6 9 0 16 0 7 0 12 11 11 16 7 21 6 })
        (map "Attacks2" {6..24} {10 18 22 14 19 19 24 0 23 0 14 0 20 24 22 18 20 21 8 })
        (map "SameColor" {6..24} {23 24 18 20 21 14 22 0 11 0 19 0 8 16 9 10 12 6 7 })
        (map "Step1c" {14 16 }{15 15})
        (map "Step2a" {6..24} {19 14 6 22 18 24 20 0 20 0 23 0 23 21 14 19 24 18 11 })
        (map "Step2b" {6..24} {8 12 21 11 16 9 7 0 7 0 10 0 10 6 12 8 9 16 22 })
        (map "Step2c" {8 14 21 16 9 22} {15 16 15 14 15 15 })
        (map "Step3a" {6..24} {20 19 12 23 22 23 21 0 19 0 24 0 9 14 8 12 10 9 10 })
        (map "Step3b" {6..24} {14 21 20 18 24 16 8 0 6 0 11 0 22 7 6 7 18 11 16 })
        (map "Step3c" {7..23} {15 16 14 15 0 0 0 22 0 8 0 0 0 15 16 14 15 }) 
        (map "Step3d" {14 16} {9 21 })
        (map "Step4a" {6..24} {21 20 19 24 23 22 14 0 12 0 18 0 16 8 7 6 11 10 9 })
        (map "Step4b" {6..24} {15 16 9 8 14 15 0 0 10 0 7 0 0 15 16 9 8 14 15 })
        (map "Step4c" {8 14 21 9 16 22} {22 23 22 21 20 21 })
        (map "Step5c" {6..24} {16 9 10 7 8 14 15 0 11 0 6 0 15 16 9 10 7 8 14 })
        (map "Step5d" {7..23} {22 23 20 21 0 0 0 24 0 19 0 0 0 22 23 20 21 })
        (map "Step6c" {6..24} {9 10 11 6 7 8 16 0 18 0 12 0 14 9 10 11 6 7 8 })
        (map "Step6d" {6..24} {22 23 24 19 20 21 0 0 0 0 0 0 0 22 23 24 19 20 21 })
        (map "Step6e" {6 19 11 24} {15 15 15 15 })
        (map "Step7a" {6..24} {7 8 14 10 11 18 6 0 8 0 9 0 11 12 19 14 16 22 18 })
        (map "Step7b" {6..24} {12 6 7 16 9 10 19 0 21 0 22 0 24 20 21 20 23 24 23 })
        (map "Step7c" {6..24} {10 11 18 12 6 7 9 0 11 0 6 0 8 10 11 18 12 6 7 })
        (map "Step7d" {6..24} {23 24 0 0 19 20 22 0 24 0 19 0 21 23 24 0 0 19 20  })
        (map "Step7e" {6 19 7 20 10 23 11 24} {16 16 15 15 15 15 14 14 })
        (map "Step8a" {6..24} {11 18 11 6 12 6 10 0 10 0 7 0 7 11 18 11 6 12 6 })
        (map "Step8b" {6..24} {24 16 24 19 14 19 23 0 23 0 20 0 20 24 16 24 19 14 19 })
        (map "Step8c" {6 19 8 21 9 22 11 24} {9 9 15 15 15 15 8 8 })
        (map "Step8d" {6 19 11 24} {22 22 21 21 })
        (map "Step9c" {6..24} {18 11 10 7 6 12 11 0 9 0 8 0 6 18 11 10 7 6 12 })
        (map "Step9d" {6..24} {10 24 23 20 19 7 24 0 22 0 21 0 19 23 24 23 20 19 7 })
        (map "Step9e" {6..24} {23 9 16 14 8 20 0 0 15 0 15 0 0 10 9 16 14 8 20 })
        (map "Step9f" {20 7 10 23} {22 22 21 21 })
        (map "Step10c" {6..24} {11 10 9 8 7 6 18 0 16 0 14 0 12 11 10 9 8 7 6 })
        (map "Step10d" {6..24} {24 23 22 21 20 19 0 0 0 0 0 0 0 24 23 22 21 20 19 })
        (map "Step10e" {21 8 9 22} {15 15 15 15 })
        (map "Step11c" {6..24} {10 11 10 7 6 7 11 0 9 0 8 0 6 10 11 10 7 6 7 })
        (map "Step11d" {6..24} {23 24 23 20 19 20 24 0 22 0 21 0 19 23 24 23 20 19 20 })
        (map "Step11e" {6..24} {18 9 16 14 8 12 0 0 15 0 15 0 0 18 9 16 14 8 12 })
        (map "Step11f" {7 10 20 23} {22 21 22 21 })
        (map "Step11g" {7 10 20 23} {15 15 15 15 })
        (map "Step12b" {6..24} {11 18 11 6 12 6 10 0 10 0 7 0 7 11 18 11 6 12 6 })
        (map "Step12c" {6..24} {24 16 24 19 14 19 23 0 23 0 20 0 20 24 16 24 19 14 19 })
        (map "Step12d" {6 19 8 21 9 22 11 24} {9 9 9 9 8 8 8 8 })
        (map "Step12e" {6 19 8 21 9 22 11 24} {22 22 22 22 21 21 21 21 })
        (map "Step12f" {6 19 8 21 9 22 11 24} {15 15 15 15 15 15 15 15 })
        (map "Step12g" {14 16} {11 19 })
        (map "Step13c" {6..24} {10 11 10 7 6 7 9 0 11 0 6 0 8 10 11 10 7 6 7 })
        (map "Step13d" {6..24} {23 24 23 20 19 20 22 0 24 0 19 0 21 23 24 23 20 19 20 })
        (map "Step13e" {6..24} {16 9 14 16 8 14 15 0 8 0 9 0 15 16 9 14 16 8 14 })
        (map "Step13f" {7..23} {22 18 12 21 0 0 0 21 0 22 0 0 0 22 18 12 21 })
        (map "Step14c" {6..24} {9 10 11 6 7 8 16 0 18 0 12 0 14 9 10 11 6 7 8 })
        (map "Step14d" {6..24} {22 23 24 19 20 21 0 0 0 0 0 0 0 22 23 24 19 20 21 })
        (map "Step14e" {6 19 11 24} {15 15 15 15 })
        (map "Step14f" {8 9 21 22} {18 20 10 12 })
        (map "Step15c" {6..24} {10 11 18 12 6 7 9 0 11 0 11 0 8 10 11 18 12 6 7 })
        (map "Step15d" {6..24} {23 24 20 23 19 20 22 0 24 0 24 0 21 23 24 7 10 19 20 })
        (map "Step15e" {6..24} {16 21 10 7 22 16 15 0 6 0 6 0 15 16 8 10 7 9 16 })
        (map "Step15f" {6..24} {14 9 23 20 8 14 0 0 19 0 19 0 0 14 9 23 20 8 14 })
        (map "Step16c" {6..24} {9 20 15 15 23 8 14 0 12 0 18 0 16 9 7 15 15 10 8 })
        (map "Step16d" {6 19 8 21 9 22 11 24} {22 22 6 6 11 11 21 21 })
        (map "Step16e" {6 19 8 21 9 22 11 24} {8 8 9 9 8 8 9 9 })
        (map "Step16f" {6 19 8 21 9 22 11 24} {21 21 19 19 21 21 22 22 })
        (map "Step16g" {6 19 8 21 9 22 11 24} {15 15 22 22 24 24 15 15 })
        (map "Step17c" {6..24} {10 11 10 7 6 7 8 0 6 0 11 0 6 10 6 10 7 6 7 })
        (map "Step17d" {6..24} {23 9 12 14 8 12 11 0 9 0 8 0 9 23 9 12 14 8 10 })
        (map "Step17e" {6..24} {18 15 16 18 15 16 21 0 15 0 15 0 19 18 11 16 18 11 16 })
        (map "Step17f" {6..24} {14 19 23 20 19 20 24 0 19 0 21 0 22 14 15 23 20 15 12 })
        (map "Step17g" {6..24} {20 22 0 0 21 23 0 0 22 0 24 0 0 7 22 0 0 19 20 })
        (map "Step17h" {7 10 20 23} {24 24 24 21 })
        (map "Step18c" {6..24} {11 10 9 8 7 6 18 0 16 0 14 0 12 8 10 6 8 7 6 })
        (map "Step18d" {6..24} {21 23 15 15 20 19 0 0 0 0 0 0 0 11 23 9 11 20 9 })
        (map "Step18e" {6 19 8 21 22 9 11 24} {24 24 19 15 15 21 22 19 })
        (map "Step18f" {8 21 22 9} {22 22 21 24 })
        (map "Step18g" {6 19 11 24} {23 16 14 7 })
        (map "Step19c" {6..24} {7 6 7 7 6 7 6 0 8 0 8 0 6 10 9 10 7 6 7} )
        (map "Step19d" {6..24} {10 8 10 10 8 10 11 0 9 0 9 0 11 12 11 14 14 8 12} )
        (map "Step19e" {6..24} {12 9 14 14 9 12 19 0 15 0 15 0 19 18 15 16 16 15 18} )
        (map "Step19f" {6..24} {18 11 16 16 11 18 24 0 21 0 21 0 24 20 19 20 20 19 20} )
        (map "Step19g" {6..24} {23 15 23 20 15 20 0 0 22 0 22 0 0 23 21 23 23 21 23} )
        (map "Step19h" {7 10 20 23} {22 19 22 22 } )
        (map "Step19i" {7 10 20 23} {24 21 24 24 } )
        (map "Step20b" {6..24} {9 16 9 6 12 6 10 0 10 0 7 0 7 6 16 8 6 12 6} )
        (map "Step20c" {6..24} {11 18 11 8 14 8 23 0 23 0 20 0 20 9 18 9 8 14 8} )
        (map "Step20d" {6..24} {15 0 15 15 0 15 0 0 0 0 0 0 0 11 0 11 9 0 11} )
        (map "Step20e" {6..24} {19 0 21 19 0 19 0 0 0 0 0 0 0 15 0 15 15 0 15} )
        (map "Step20f" {6..24} {22 0 22 21 0 21 0 0 0 0 0 0 0 22 0 22 19 0 19} )
        (map "Step20g" {6..24} {24 0 24 22 0 24 0 0 0 0 0 0 0 24 0 24 21 0 21} )
        
        (piece "Prisoner" Each  "PrisonerExchange" )
        (piece "Starter"  Each  "StartMove" ) (piece "Reserve"  Each )
        (piece "Cone"  Each (if "IsLastMan" (or "LastMan" "ConeMove" ) "ConeMove" ))
    })
    
    (rules
        (start {
            (place Stack "Starter1" <Starter:Bas1> count:3 )
            (place Stack "Starter2" <Starter:Bas2> count:3 )
            (place Stack "Reserve1" <Starter:Res1> count:6 )
            (place Stack "Reserve2" <Starter:Res2> count:6 )
        })
        
        (play   (do   (if "RingsAreEmpty" (and {(set Var "StartS" 0 ) (set Var "CntrAttack"  0 )   }))
                next:(if ( "SameTurn") "StartMove"
                    (forEach Piece top:True )
                )
            )
        )
        
        (end  { (if "Extinction" (result Mover Win) )
            (if (>= (count Pieces Mover in:(sites "Prison")) <Num:pris>) (result Mover Win) )
            //     (if "IsSelfStaleLastManLoop" (result Mover Draw) )  // only theoretical, waste of cpu time.
        })
    )
)

(option "Start Order" <Starter> args:{ <Pip1> <Pip2> <Bas1> <Bas2> <Pri1> <Pri2> <Res1> <Res2> <Hom1> <Hom2>              <Las1> <Las2>             <color1> <color2> }
    {
    (item "White begins" <"PipsP1"> <"PipsP2"> <13> <17> <0> <4> <1> <3> <{6 7 8 12 14 19 20 21}> <{9 10 11 16 18 22 23 24}> <{6 9 16 21 22}> <{7 9 14 21 22}> <White> <VeryDarkGrey>  "White player starts the game.")*
    (item "Black begins" <"PipsP2"> <"PipsP1"> <17> <13> <4> <0> <3> <1> <{9 10 11 16 18 22 23 24}> <{6 7 8 12 14 19 20 21}> <{7 9 14 21 22}> <{6 9 16 21 22}> <VeryDarkGrey> <White>  "Black player starts the game.")
}   )

(option "End Rules" <Num> args:{ <pris> }
    { (item "Get 1 Prisoner"   <1>  "Sudden Death Match: 1 Prisoner ends it all.")
    (item "Get 2 Prisoners"  <2>  "Transfer 2 enemy-pieces to your prison-cell.")
    (item "Get 3 Prisoners"  <3>  "Transfer 3 enemy-pieces to your prison-cell.")*
    (item "Get 4 Prisoners"  <4>  "Transfer 4 enemy-pieces to your prison-cell.")
    (item "Get 5 Prisoners"  <5>  "Transfer 5 enemy-pieces to your prison-cell.")
    (item "Get 6 Prisoners"  <6>  "Transfer 6 enemy-pieces to your prison-cell.")
    (item "Get 7 Prisoners"  <7>  "Transfer 7 enemy-pieces to your prison-cell.")
} )

//-------------
(metadata
    (info
        {
        (description "After starting from the centres of the rings there are three important rules:    # STEP-Length: Sum of the pips of your color on occupied sites on the track of colored ring-sites. Each step moves orthogonal forward, left or right.    # STARTER-Generation: Reach same color of friendly piece in opposite ring to get an additional Starter to your base.    # CAPTURE-Move: Reach same color of enemy piece in opposite ring to capture it directly. Captured pieces form a stack and have to be brought to the centre between the rings to send them to jail.    WIN = Get 3 Prisoners or Extinction of opponent. See details in rules section.")
        (rules "Pieces start from the centres of the rings to the colored positions and later move orthogonal forward, left or right. The total STEP-length is equal to the sum of the pips of a player's color on all the positions occupied by their pieces.
            If you can move you have to do so, even if it is a bad move.
            If you stalemate yourself, the other player can move until you can move again.
            
            STARTER-generation: If you reach the same color of one of your own pieces in the opposite ring, you get a new starter to your base (center of the rings) from your reserve. This also works from the base with a start-move (base to own ring).
            
            To CAPTURE an enemy, you need to be able to reach the same color of the enemy-piece in the opposite ring, then the possibility to directly capture the enemy on its board-position will be available.
            Capturing is not mandatory, you can also just go to the opposite-color position (move 'into the shadow'). Capturing with a start-move from the base is not possible.
            Ring Capture: with step lenght 8 you could theoretically move in a circle to your own position, but as normal move this is not allowed.
            But if there is an enemy-piece on the opposite same color, the (ring-)capture-move is not allowed! For step lengths of 12 or 14 etc this is also possible from some other positions.
            
            The captured pieces remain under the attacker in a stack and have to be brought to the Transmitter (field in the middle of the board) with the according step length.
            If you reach the transmitter, your pieces in the stack go back to base as starters, and the enemies land in your prison.
            First player to make 3 prisoners wins.
            
            Only pieces with a captured enemy can land on the Transmitter for prisoner transport. (Exception: #LastMan)
            Single pieces just step over it. With high step length you can move in circles or to the other side and back, but not turn 180 degrees.
            
            Special Rules to balance the Start:
            From the Start-situation (or later, when there are temporarily no pieces on colored positions) you cannot copy the move of the enemy, ie move to the same color with your first piece.
            
            #CounterAttack: If your first starter is attacked immediately (by the first enemy move), you are allowed to start also to the colors in the enemy-ring with your second starter. In this case, there is no Starter generation, if you move to the opposite color of your first piece (to protect it from capturing).
            
            Special Rules for Endgame:
            #LastMan: If you are left with just a single piece on the colored board positions (and no starter on your base), you may enter the Transmitter to move the piece to your base and get a second starter (if you still have one in your reserve)!
            
            #PrisonerExchange: Move a prisoner to your (empty) homebase, and you get an additional Starter taken from your reserve & the prisoner goes back to his reserve. You have to move this new starter immediately: the Prisoner Exchange itself counts not as a full move.
            
            History : 'Mensa Spiel' invented by Andreas Pichler (Mensa Austria).
            Ludii file implemented by Franz Pichler. (June 2022)
            
            Strategy : Early starter-generation is important to have more options.
            Indirect or dynamic defence is sometimes best: if you are captured, to be able to capture back or dominate the opponent with controlling many positions is vital.
            In general, a move that attacks an enemy-piece and would make possible a Starter-Generation in the next move simultaneously, is good.
            
            But be aware: almost all moves change the step length and attack & defence-patterns, ie. the whole situation.
        This makes it complicated to calculate, but entertaining to play.")
        (id "2002")
        (version "1.3.11")
        (classification "board/war/replacement/eliminate/all")
        (author "Andreas Pichler")
        (credit "Franz Pichler")
        (date "2010")
        }
    )
    
    (graphics {
        ("RectX" "G1" "G2" 1.07 1.26 0 0) ("RectX" "G1" "G1" 1.06 1.24 0 0)
        ("SquaX" "G1" "Bl" 0.31 0.304 -0.287 -0.140) ("SquaX" "G1" "Bl" 0.31 0.304  0.282 -0.140)
        ("RectS" LightGrey LightGrey 0.012 0.6 -0.285 0.072 )("RectS" LightGrey LightGrey 0.012 0.6 0.285 0.072 )
        ("RectS" LightGrey LightGrey 0.05 0.02 -0.35 0.284 ) ("RectS" LightGrey LightGrey 0.05 0.02  0.35 0.284 )
        ("RectS" Black Black 0.158 0.02 0.001 -0.142 )
        
        ("SquaS" (colour 0 230 230) -0.43 -0.286 )("PiP" White -0.4682 -0.322 )
        ("PiP" White -0.4682 -0.25 )("PiP" White -0.3905 -0.322 )("PiP" Black -0.3905 -0.25 )
        ("SquaS" (colour 52 64 200) -0.285 -0.286 )("PiP" Black -0.3232 -0.322 )
        ("PiP" Black -0.3232 -0.25 )("PiP" White -0.2455 -0.322 )("PiP" White -0.2455 -0.25 )
        ("SquaS" (colour 87 99 51) -0.14 -0.286 )("PiP" Black -0.1782 -0.322 )
        ("PiP" White -0.1782 -0.25 )("PiP" White -0.1005 -0.322 )("PiP" Black -0.1005 -0.25 )
        ("SquaS" (colour 163 73 163) -0.43 -0.144 )("PiP" White -0.4682 -0.18 )
        ("PiP" Black -0.4682 -0.108 )("PiP" White -0.3905 -0.18 )("PiP" Black -0.3905 -0.108 )
        ("SquaS" (colour 0 232 0) -0.14 -0.144 )("PiP" White -0.1782 -0.18 )
        ("PiP" Black -0.1782 -0.108 )("PiP" White -0.1005 -0.18 )("PiP" White -0.1005 -0.108 )
        ("SquaS" (colour 230 0 0) -0.43 -0.001 )("PiP" White -0.4682 -0.037 )
        ("PiP" White -0.4682 0.035 )("PiP" White -0.3905 -0.037 )("PiP" White -0.3905 0.035 )
        ("SquaS" (colour 255 127 0) -0.285 -0.001 )("PiP" Black -0.3232 -0.037 )
        ("PiP" Black -0.3232 0.035 )("PiP" White -0.2455 -0.037 )("PiP" Black -0.2455 0.035 )
        ("SquaS" (colour 254 242 0) -0.14 -0.001 )("PiP" Black -0.1782 -0.037 )
        ("PiP" White -0.1782 0.035 )("PiP" White -0.1005 -0.037 )("PiP" White -0.1005 0.035 )
        
        ("SquaS" (colour 255 127 0) 0.43 -0.286 )("PiP" Black 0.4682 -0.322 )
        ("PiP" White 0.4682 -0.25 )("PiP" White 0.3905 -0.322 )("PiP" White 0.3905 -0.25 )
        ("SquaS" (colour 254 0 0) 0.285 -0.286 )("PiP" Black 0.3232 -0.322 )
        ("PiP" Black 0.3232 -0.25 )("PiP" Black 0.2455 -0.322 )("PiP" Black 0.2455 -0.25 )
        ("SquaS" (colour 163 73 163) 0.14 -0.286 )("PiP" Black 0.1782 -0.322 )
        ("PiP" White 0.1782 -0.25 )("PiP" Black 0.1005 -0.322 )("PiP" White 0.1005 -0.25 )
        ("SquaS" (colour 254 242 0) 0.43 -0.144 )("PiP" Black 0.4682 -0.18 )
        ("PiP" Black 0.4682 -0.108 )("PiP" White 0.3905 -0.18 )("PiP" Black 0.3905 -0.108 )
        ("SquaS" (colour 0 230 230) 0.14 -0.144 )("PiP" Black 0.1782 -0.18 )
        ("PiP" White 0.1782 -0.108 )("PiP" Black 0.1005 -0.18 )("PiP" Black 0.1005 -0.108 )
        ("SquaS" (colour 0 232 0) 0.43 -0.001 )("PiP" Black 0.4682 -0.037 )
        ("PiP" Black 0.4682 0.035 )("PiP" Black 0.3905 -0.037 )("PiP" White 0.3905 0.035 )
        ("SquaS" (colour 87 99 51) 0.285 -0.001 )("PiP" Black 0.3232 -0.037 )
        ("PiP" White 0.3232 0.035 )("PiP" White 0.2455 -0.037 )("PiP" Black 0.2455 0.035 )
        ("SquaS" (colour 52 64 200) 0.14 -0.001 )("PiP" Black 0.1782 -0.037 )
        ("PiP" Black 0.1782 0.035 )("PiP" White 0.1005 -0.037 )("PiP" White 0.1005 0.035 )
        
        ("SquaX" "LG" "Bl" 0.137 0.137 0.001 -0.142)
        ("DiscX" "LG" "Wh" 0.125 0.001 -0.142) ("DiscX" "LG" "Bl" 0.10 0.001 -0.142)
        ("DiscX" "LG" "Wh" 0.06 0.001 -0.142) ("DiscX" "LG" "Bl" 0.02 0.001 -0.142)
        ("DiscX" "Wh" "LG" 0.01 0.001 -0.142)
        ("SquaX" "Bl" "Bl" 0.138 0.138 0.285 0.286) ("SquaX" "LG" "LG" 0.11 0.11 0.285 0.286)
        ("SquaX" "Wh" "Wh" 0.138 0.138 -0.285 0.286) ("SquaX" "LG" "LG" 0.11 0.11 -0.285 0.286)
        
        ("SquaX" "Wh" "Wh" 0.138 0.138 -0.285 -0.144) ("SquaX" "LG" "LG" 0.11 0.11 -0.285 -0.144)
        ("SquaX" "Bl" "Bl" 0.138 0.138 0.285 -0.144) ("SquaX" "LG" "LG" 0.11 0.11 0.285 -0.144)
        
        ("SquaX" "Wh" "Wh" 0.138 0.138 -0.43 0.286) ("SquaX" "LG" "LG" 0.11 0.11 -0.43 0.286 )
        ("RectS"  White White 0.13  0.007 -0.43 0.305) ("RectS" White White 0.13 0.007 -0.43 0.265)
        ("RectS"  White White 0.006 0.17 -0.41 0.284) ("RectS" White White 0.006 0.17 -0.45 0.284)
        
        ("SquaX" "Bl" "Bl" 0.138 0.138 0.43 0.286) ("SquaX" "LG" "LG" 0.11 0.11 0.43 0.286 )
        ("RectS"  Black Black 0.13  0.007 0.43 0.305) ("RectS" Black Black 0.13 0.007 0.43 0.265)
        ("RectS"  Black Black 0.006 0.17 0.41 0.284) ("RectS" Black Black 0.006 0.17 0.45 0.284)
        
        ("DiscX" "G1" "G2" 0.06 0.01 0.16) ("DiscX" "G1" "G2" 0.06 -0.01 0.16)("DiscX" "G1" "G2" 0.06 0.01 0.14) // Mensa_Logo
        ("DiscX" "G1" "G2" 0.06 -0.01 0.14) ("RectX" "G1" "G1" 0.02 0.2 0.0 0.15) ("RectX" "G1" "G1" 0.2 0.02 0.0 0.15)
        ("DiscX" "G1" "G1" 0.075 0.0 0.15) ("SquaX" "G2" "G2" 0.03 0.005 0.0 0.187) ("SquaX" "G2" "G2" 0.03 0.005 0.0 0.113)
        ("SquaX" "G2" "G2" 0.005 0.03 0.037 0.15) ("SquaX" "G2" "G2" 0.005 0.03 -0.037 0.15) ("Minu" "G2" "G2" 0.036 0.043 90 -0.004 0.168)
        ("Minu" "G2" "G2" 0.03 0.045 90 -0.031 0.16)("Minu" "G2" "G2" 0.03 0.045 90 0.014 0.16) ("Minu" "G2" "G2" 0.03 0.045 30 -0.014 0.152)
        ("Minu" "G2" "G2" 0.03 0.045 330 0.006 0.149) ("DiscX" "G2" "G2" 0.025 0.0 0.131)("DiscX" "G1" "G2" 0.016 0.0 0.131)
        
        (player Colour P1 (colour <Starter:color1>)) (player Colour P2 (colour <Starter:color2>)) (stackType Default 0.5 )
        (piece Scale "Cone" 0.1 ) (piece Scale "Prisoner" 0.1 ) (piece Scale "Starter" 0.07 ) (piece Scale "Reserve" 0.07 )
        ("PieceDef" "Cone1"   <Starter:color1>) ("PieceDef" "Cone2" <Starter:color2>)
        ("PieceDef" "Starter1" <Starter:color1>) ("PieceDef" "Starter2" <Starter:color2>)
        ("PieceDef" "Reserve1"  <Starter:color1>) ("PieceDef" "Reserve2" <Starter:color2>)
        ("PieceDef" "Prisoner1"  <Starter:color2>) ("PieceDef" "Prisoner2" <Starter:color1>)
        (show Score " Steps")
    })
    (ai (alphaBeta (heuristics (influenceAdvanced))))
)







// Simple implementation Suicide allowed
//-----------------------------------
// Connection graphics

(define "SharedCells" (intersection (sites Around Cell #1) (sites Around Cell #2)))

(define "HalfWayEdge" 
    (regionSite
        (difference
            (sites Incident Edge of:Cell at:(regionSite ("SharedCells" #1 #2) index:0))
            (difference
                (sites Incident Edge of:Cell at:(regionSite ("SharedCells" #1 #2) index:0))
                (sites Incident Edge of:Cell at:(regionSite ("SharedCells" #1 #2) index:1))
            )
        )
        index:0
    )
)

(define "BetweenEdge"
    (regionSite
        (difference
            (sites Incident Edge of:Cell at:#1)
            (difference
                (sites Incident Edge of:Cell at:#1)
                (sites Incident Edge of:Cell at:#2)
            )
        )
        index:0
    )
)

(define "EdgeIsOriented"  
    (= 
        (regionSite (sites Incident Cell of:Edge at:#1) index:0) 
        (ahead Cell (regionSite (sites Incident Cell of:Edge at:#1) index:1) #2)
    )
) 

(define "EdgeOrientationInteger" (if (or ("EdgeIsOriented" #1 E) ("EdgeIsOriented" #1 W)) 0 2)) // of an edge

(define "AddConnector"
    (if 
        (can Move (leap (from Cell (last To)) {{F F #2 F}} (to Cell (sites Occupied by:Mover) if:("NeedsConnection"))))
        (forEach Value
            (results
                from:(last To)
                to:(sites To 
                    (leap
                        (from Cell (last To))
                        {{ F F #2 F }} 
                        (to Cell (sites Occupied by:Mover)
                            if:("NeedsConnection")
                        )
                    )
                )
                ("HalfWayEdge" (to) (last To))
            ) 
            (add
                (piece (id "I" Mover))
                (to
                    Edge
                    (value)
                    (apply (set Var "ToEdge" (value))) 
                )
                stack:True
                (then (set State Edge at:(var "ToEdge") (+ #1 ("EdgeOrientationInteger" (var "ToEdge")))))
            )
        )
    )
)

(define "RemoveConnector"
    (and {
        (forEach Site // edge between friends may not have opponent break.
            (sites Around Cell (last To) Orthogonal)
            (apply if:(is Mover (who at:(site)))
                (remove Edge ("BetweenEdge" (site) (last To)) count:2)
        ))
        (forEach Site // edge friend break not needed at edge around placement
            (sites Incident Edge of:Cell at:(last To)) 
            (apply if:(= (mover) (who Edge at:(site)))
                (remove Edge (site) count:2)
            )
        )
    })
)

(define "NeedsConnection"
    (and {
        (is Mover (who at:(to)))
        (not
            (is Within
                (id "Ball" Mover) 
                in:(intersection
                    (sites Around Cell (to))
                    (sites Around Cell (last To))
                )
            )
        )
        (> 2
            (count Pieces All
                in:(intersection
                    (sites Around Cell (to) Adjacent)
                    (sites Around Cell (last To) Adjacent)
                )
            )
        )
    })
)

//-------------------------------------------------- 
// Connectivity

(define "Twist"
    (if 
        (= #2 (ahead Cell #1 E)) (sites Around #3 N)
        (if 
            (= #2 (ahead Cell #1 N)) (sites Around #3 W)
            (if 
                (= #2 (ahead Cell #1 W)) (sites Around #3 S)
                (sites Around #3 E)
            )
        )
    )
)

(define "Break"
    (or
        (and
            (!= 0 (count Pieces of:("Opponent" #3) in:("Twist" #2 #1 #1)))
            (!= 0 (count Pieces of:("Opponent" #3) in:("Twist" #1 #2 #2)))
        )
        (and
            (!= 0 (count Pieces of:("Opponent" #3) in:("Twist" #2 #1 #2)))
            (!= 0 (count Pieces of:("Opponent" #3) in:("Twist" #1 #2 #1)))
        )
    )
)

(define "Opponent"
    (- 3 (id #1))
)

(define "NotCrossingConnector" 
    (or {
        (= (to) (from))
        (and
            (is #1 (who at:(from)))  
            (is #1 (who at:(to))) 
        ) 
        (not ("Break" (from) (to) #1))
    })
)

//-----------------------------------
// End condition tests

(define "Liberties" (intersection (sites "Marked") (sites Empty)))

(define "IsDeadSiteValueofPlayer"
    (or
        (= 0 (count Sites in:(difference ("Liberties" #2) #1)))
        (= Infinity
            (count Steps
                (step
                    (from (from))
                    Orthogonal
                    (to 
                        if:(and
                            //  {
                            (or
                                (is Empty (to))
                                (is #2 (who at:(to)))  
                            )
                            ("NotCrossingConnector" #2) 
                            //  }
                        )
                    )
                )
                (#1) 
                (difference ("Liberties" #2) #1)
            )
        )
    )
)

(define "Scoring"
    (and
        (do
            "CheckMoverLoss"
            next:(set Score Mover (- 0 (count Pieces Cell Mover in:(sites State Cell 1))))
        )
        (do
            "CheckOpponentLoss"
            next:(set Score Next (- 0 (count Pieces Cell Next in:(sites State Cell 1))))
        )
    )
)

(define "CheckMoverLoss"
    (if
        ("IsDeadSiteValueofPlayer" (last To) Mover)
        (and {
            (trigger "Enmeshed" Mover)
            (set State at:(last To) 1) 
            (forEach Value
                (array (sites Occupied by:Mover on:Cell))
                (if
                    ("IsDeadSiteValueofPlayer" (value) Mover)
                    (set State at:(value) 1)
                )
            )
        })
    )
) 

(define "CheckOpponentLoss"
    (forEach Value
        (array (sites Occupied by:Next on:Cell))
        (if
            ("IsDeadSiteValueofPlayer" (value) Next)
            (and
                (trigger "Enmeshed" Next)
                (set State at:(value) 1)
            )
        )
    )
)

//-------------------------------
// Move definitions

(define "Add2EmptyWithConsequenses"
    (move Add 
        (piece (id "Ball" Mover))
        (to (sites Empty))
        (then 
            (and {
                ("AddConnector" 1 L)
                ("AddConnector" 2 R)
                ("RemoveConnector")
                ("Scoring")
            })
        )
    )
)

//-----------------------------------------------
// Main routine

(game "N-Mesh"
    (players 2)
    (equipment {
        "SquareGrid"
        (regions "Marked" ("LibertyRegions")) 
        (piece "Ball" P1 maxState:1)
        (piece "Ball" P2 maxState:1)
        (piece "I" P1 maxState:5)
        (piece "I" P2 maxState:5)
    })
    (rules
        (play
            (or
                (if
                    (= 0 (counter))
                    (move Add
                        (to
                            (sites Occupied by:Next)
                            (apply (remove (to)))
                        )
                    )
                )
                ("Add2EmptyWithConsequenses")
            )
        )
        (end 
            (if 
                (or
                    (is Triggered "Enmeshed" Mover)
                    (is Triggered "Enmeshed" Next)
                )
                { 
                (if
                    (= (score Mover) (score Next))
                    (result Next Win)
                )
                (if
                    (!= (score Mover) (score Next))
                    (byScore)
                ) 
                }
                (byScore)
            )
        )
    )
)

//-------------------------------------------------
// Defines for Options

(define "SquareGrid" (board (square <BoardSize:smallSide>) use:Cell))
(define "LibertyRegions" 
    // Asymmetrical board maximizes pie offering choices. 
    //-- if no pie, board should be symmetrical.
    (forEach
        (sites Board) 
        if:(= 0
            (%
                (+ {
                    (if (= 0 (% (- <BoardSize:smallSide> 1) 5)) 1 0) // prevents a symmetrical board.
                    (site)
                    (*
                        (- 7 <BoardSize:smallSide>)
                        (/ (site) <BoardSize:smallSide>)
                    )
                })
                5
            )
        )
    )
)

// (define "LibertyRegions" (forEach (sites Board) if:(= 0 (% (site) <BoardSize:regionSpacing>)))) 

//-----------------------------------------
// Options

(option "Board Size" <BoardSize> args:{<smallSide> <regionSpacing>} 
    {
    (item "Order 3" <3> <5> "Order 3 board")*
    (item "Order 4" <4> <3> "Order 4 board")
    (item "Order 5" <5> <4> "Order 5 board")
    (item "Order 6" <6> <5> "Order 6 board")**
    (item "Order 7" <7> <5> "Order 7 board")
    (item "Order 8" <8> <7> "Order 8 board")
    (item "Order 9" <9> <6> "Order 9 board")
    (item "Order 10" <10> <8> "Order 10 board")
    (item "Order 11" <11> <5> "Order 11 board")
    (item "Order 19" <19> <6> "Order 19 board")
    }
)

//---------------------------------------------

(define "ColourBackground" (colour 241 232 199))
(define "Invisible" (colour 0 0 0 0))

(metadata
    (info
        {
        (description "N-Mesh is a game on a square grid that evolved from Netted, an enclosure game on a hex grid.       The game is a race to deprive the opponent of liberties by surrounding the opponent's stones and or by destroying the liberties by placing stones on them.       If the players surround each other, the player with fewer captured stones wins, and where the result is still undetermined, the last to play loses. This latter rule prevents players from simply racing to cover up the liberties.  -------------   The main differences from Netted is that life in N-Mesh requires only a single liberty for a region, and the liberties are specific cells distributed across the board. (Netted liberties were the edge cells and each stone required its own exclusive liberty)    The difference in geometry also causes differences in connectivity:    Both feature 3 types of connectivity used strategically to separate the opponent's stones from liberties.    These include adjacency, as well as a short type of connection that can permanently cross the other player's connections and a longer type of connection that can be broken.    In N-Mesh the long connections are at knight's move distance, and are broken by a pair of stones placed in between, and the crossing connections are diagonals.-------------      Surrounding is done by nets. A net is made of adjacent stones as well as stones connected by diagonals and single empty spaces. Thus opponent's nets can cross each other and a portion of a net may be surrounded without surrounding the whole net. Having a connection to a living stone does not guarantee life to another stone: what provides life to a stone is having an empty liberty cell in the same region defined by the opponent's surrounding net.             Offensive tactics include:    - Threatening to capture over-extended pieces,     -- especially to pick off a single stone in diagonal-plus-double-knight's-move triangle,    -- covering liberties in uncontrolled areas to capture a larger group or to make group life harder to achieve,    -- or by creating forks.        - Using knight's moves to quickly fence off large territory.     -- enclosing more liberties and spaces to place on so that ones groups can survive longest    - Reinforcing threatened knight's connections by adding a stone there.        Defensive tactics include: Blocking threats by     - breaking a knight's move connection by extending a line of stones across it.     - placing on the site the opponent needs to complete the threat,    - encircling the threat location, or for edges sites,     - reducing the cut-off region to one empty edge site.        Notes:     -- Spacing of the liberties is arbitrary, but has been standardized to a regular spacing that can work on small and large boards, in order to allow the transfer of tactical knowledge from size to size.    -- The distribution is purposefully asymmetrical to allow the greatest variety of pie offerings.     -- If the game is to be played without a pie rule, a symmetrical arrangement is preferred for greater balance.    The pie rule means that the game is a proven 2nd-player win, and the quality of the AI can be judged accordingly.")
        (rules "Goal: 
            Deprive any of your opponent's stones access to an empty shaded Liberty cell, by surrounding or 'Enmeshing' them.  
            
            Play:
            -- Black starts with an empty board.
            -- White has the option to convert Black's first stone to white instead of placing elsewhere. (pie move)
            -- Turns alternate.
            -- On your turn place one of your stones on an empty site.
            
            Ending the game:
            -- The game ends as soon as any stone is enmeshed. (see definitions below).
            
            -- If both player's stones are simultaneously 'enmeshed', the player with the most 'enmeshed' stones loses. 
            -- If this is still equal, the moving player loses.
            
            Definitions:
            A stone is 'Enmeshed' if it has no path in the play area to an empty shaded liberty cell without crossing a connection between the opponent's stones.
            
            There is a connection between stones of the same color if they: 
            -- 1. are on adjacent squares, 
            -- 2. are diagonally adjacent, (player's connections can cross each other)
            -- 3. are at knight's distance, with at least one empty space between. 
            
            Notes: 
            Knight's connections can cross each other, but cease to exist when 2 pieces are placed in between.
        When a stone is placed on a shaded cell, that cell no longer serves as a liberty for either player.")
        (id "1666")
        (version "1.3.11")
        (classification "experimental")
        (author "Dale W. Walton")
        (credit "Dale W. Walton")
        (date "17-09-2021")
        }
    )
    
    (graphics 
        {
        (player Colour P1 (colour DarkGrey))
        (player Colour P2 (colour White))
        (piece Colour P1 "Ball" state:0 fillColour:(colour DarkGrey))
        (piece Colour P2 "Ball" state:0 fillColour:(colour White))
        (piece Colour P1 "Ball" state:1 fillColour:(colour DarkRed))
        (piece Colour P2 "Ball" state:1 fillColour:(colour LightRed))
        (piece Scale "Ball" 0.78)
        
        (piece Colour P1 "I" state:0 fillColour:(colour Red) strokeColour:(colour Red)) 
        (piece Colour P2 "I" state:0 fillColour:(colour Red) strokeColour:(colour Red)) 
        (piece Rotate P1 "I" state:0 degrees:90) // debug test: state 0 only occurs in intermediate graphics processing
        (piece Rotate P2 "I" state:0 degrees:90) // debug test: state 0 only occurs in intermediate graphics processing
        
        (piece Colour P1 "I" state:1 fillColour:(colour 0 0 0 150) strokeColour:(colour 0 0 0 150)) 
        (piece Colour P2 "I" state:1 fillColour:(colour 50 50 50 100) strokeColour:(colour 50 50 50 100)) 
        (piece Colour P1 "I" state:2 fillColour:(colour 0 0 0 150) strokeColour:(colour 0 0 0 150)) 
        (piece Colour P2 "I" state:2 fillColour:(colour 50 50 50 100) strokeColour:(colour 50 50 50 100)) 
        (piece Colour P1 "I" state:3 fillColour:(colour 0 0 0 150) strokeColour:(colour 0 0 0 150)) 
        (piece Colour P2 "I" state:3 fillColour:(colour 50 50 50 100) strokeColour:(colour 50 50 50 100)) 
        (piece Colour P1 "I" state:4 fillColour:(colour 0 0 0 150) strokeColour:(colour 0 0 0 150)) 
        (piece Colour P2 "I" state:4 fillColour:(colour 50 50 50 100) strokeColour:(colour 50 50 50 100)) 
        (piece Rotate P1 "I" state:1 degrees:155) 
        (piece Rotate P1 "I" state:2 degrees:205) 
        (piece Rotate P1 "I" state:3 degrees:65) 
        (piece Rotate P1 "I" state:4 degrees:115) 
        (piece Rotate P2 "I" state:1 degrees:155) 
        (piece Rotate P2 "I" state:2 degrees:205) 
        (piece Rotate P2 "I" state:3 degrees:65) 
        (piece Rotate P2 "I" state:4 degrees:115) 
        (piece Scale "I" 1.55)
        (board Colour Phase0 "ColourBackground")
        (board StyleThickness InnerEdges 0.4)
        (board StyleThickness OuterEdges 0.6)
        (board StyleThickness InnerVertices 0.45)
        (board StyleThickness OuterVertices 0.45)
        (board Colour InnerVertices (colour Grey))
        (board Colour OuterVertices (colour Grey))
        (board Colour InnerEdges (colour Black))
        (board Colour OuterEdges (colour Black))
        (show Edges Diagonal Hidden (colour DarkGrey))
        (stackType None)
        (region Colour "Marked" (colour Grey))
        // (show Piece State "I")
        }
    )
    
)











(define "Swap"
    (do 
        (add (piece (who at:(last From)))
            (to
                (last To)
                (apply
                    (do
                        (set Var "StateToBeAtLastFrom" (state at:(to)))
                        next:(remove (to))
                    )
                )
            )
        )
        next:(add (piece 3 state:(var "StateToBeAtLastFrom"))
            (to
                (last From)
                (apply
                    (remove (to))
                )
            )
        )
    )
)

(define "BalanceProtocol"
    (phase "Swapping"
        (play
            (or
                (move Pass
                    (then (set Var "Passed" 1))
                )
                (move Select
                    (from 
                        (sites Board)
                        if:(and
                            (!= 3 (who at:(from)))
                            (not 
                                (is In (from) (values Remembered))
                            )
                        )
                    )
                    (to
                        (sites Board)
                        if:(= 3 (who at:(to)))
                    )
                    (then
                        (and {
                            (remember Value (last To))
                            ("Swap")
                            (if
                                (!= 3 (size Array (values Remembered)))
                                (moveAgain)
                            )
                        })
                    )
                )
            )
        )
        (nextPhase
            (or
                (= 1 (var "Passed"))
                (= 4 (size Array (values Remembered)))
            )
            "Choose"
        )
    )
    (phase "Choose"
        (play
            (or
                (move Swap Players P1 P2
                    (then (set NextPlayer (player 1)))
                )
                (move Pass)
            )
        )
        (nextPhase "Play")
    )
)

//-------------------------------------------------------------------------

(game "Paintscape"
    (players 2)
    (equipment {
        (board (square 8))
        (piece "Disc" Each)
        (piece "Square" Shared maxState:5)
    })
    (rules
        (start {
            (place Random (sites Empty) {"Disc1" "Disc2"} count:2)
            (place Random (sites Empty) {"Square"} count:12 state:1)
            (place Random (sites Empty) {"Square"} count:12 state:2)
            (place Random (sites Empty) {"Square"} count:12 state:3)
            (place Random (sites Empty) {"Square"} count:12 state:4)
            (place Random (sites Empty) {"Square"} count:12 state:5)
        })
        phases:{
        <Balance>
        (phase "Play"
            (play
                (move Add
                    (to 
                        (sites Around 
                            (sites Occupied by:Mover)
                            Orthogonal
                        )
                        if:(not
                            (or
                                (= (mover) (who at:(to)))
                                (= (next) (who at:(to)))
                            )
                        )
                    )
                    stack:True
                    (then
                        (if 
                            (and
                                (= 3 (who at:(last To) level:0))
                                (= 6
                                    (count Sites
                                        in:(forEach
                                            (sites Occupied by:Mover)
                                            if:(= 
                                                (state at:(last To) level:0)
                                                (state at:(site) level:0)
                                            )
                                        )
                                    )
                                )
                            )
                            (and
                                (remove
                                    (forEach
                                        (sites Board)
                                        if:(= 
                                            (state at:(last To) level:0)
                                            (state at:(site) level:0)
                                        )
                                    )
                                    count:2
                                )
                                (addScore Mover 1)
                            )
                        )
                    )
                )
            )
        )
        }
        (end
            (if
                (or
                    (= 3 (score P1))
                    (= 3 (score P2))
                )
                (byScore)
            )
        )
    )
)

//-------------------------------------------------------------------------

(option "Balance Phase" <Balance> args:{ <balance> }
    {
    (item "On" <("BalanceProtocol")> "The balance protocol is currently in force.")*
    (item "Off" <> "The balance protocol is currently not in force.")
    }
)

//-------------------------------------------------------------------------

(metadata
    (info
        {
        (description "Paintscape is a colorful territory game played on a Chess board with colored tiles and black and white stones. It was invented by Michael Amundsen fall 2022.")
        (rules "Paintscape is a game for two players â€“ Black and White â€“ played on the squares (cells/faces) of a square grid with 8 squares per side (e.g. a Chess board). 
            You also need a large supply of black and white stones and 5 distinguishable (e.g. by color) shared sets of 12 tiles. That is, each of the 5 sets contain 12 tiles, for 60 tiles in total.
            
            Setup:
            Before play begins, all 60 tiles and 2 white and 2 black stones are distributed randomly on the 64 squares of the board.
            A short balancing phase then ensues:
            
            One player swaps the position of any number of stones with a tile. That is, for 0, 1, 2, 3, or 4 of the stones, swap its position with any tile.
            When all stones have been swapped, or the swapping player passes, indicating that they do not wish to swap any more stones, the other player choses to play first as Black or second as White in the proper playing phase.
            (To show the button for swapping in Ludii, you might have to click the three dots next to the pass button.)
            
            The balancing phase can be skipped by new players, or you can agree on a fixed setup for the 4 initial stones.
            
            Play:
            In this phase (the proper playing phase), players take turns, starting with Black, placing stones of their own color.
            On your turn, place a stone of your color on a square adjacent to one of your stones already on the board.
            You may not place a stone on a square occupied by a stone. I.e. the square you place at must be empty or only occupied by a tile.
            Stones placed on tiles normally just stack on top of them, however:
            If a placement makes you have a stone on half of the tiles of a certain color, remove all tiles of that color along with the stones stacked on top of them (regardless of whether they're friendly or enemy).
            
            The goal:
        You win if you remove 3 of the 5 colors.")
        (id "2040")
        (version "1.3.11")
        (classification "board/space/territory")
        (author "Michael Amundsen")
        (credit "Michael Amundsen")
        (date "2022")
        }
    )
    
    (graphics {
        (player Colour P1 (colour Dark))
        (player Colour P2 (colour White))
        (piece Colour P1
            fillColour:(colour Dark)
            strokeColour:(colour Dark)
        )
        (piece Colour P2
            fillColour:(colour White)
            strokeColour:(colour Dark)
        )
        (piece Scale P1 .67)
        (piece Scale P2 .67)
        (piece Colour  Shared state:1
            fillColour:(colour Yellow)
            strokeColour:(colour White)
        )        
        (piece Colour Shared state:2
            fillColour:(colour Red)
            strokeColour:(colour White)
        )
        (piece Colour Shared state:3
            fillColour:(colour Cyan)
            strokeColour:(colour White)
        )
        (piece Colour Shared state:4
            fillColour:(colour Pink)
            strokeColour:(colour White)
        )
        (piece Colour Shared state:5
            fillColour:(colour DarkBrown)
            strokeColour:(colour White)
        )
        (region Colour (sites Board) (colour 250 210 148))
        (board Colour InnerEdges (colour 178 151 100))
        (board Colour OuterEdges (colour 178 151 100))
        (stackType Default 0.0)
    })
)
















(define "NumberOfDiscs" 10)

(define "AllDiscsPlaced"
    (>= 
        (count Turns) 
        (- (* (count Players) ("NumberOfDiscs")) 1)
    ) 
)

(define "AddDisc" 
    (move Add 
        (piece (id "Disc" Mover)) 
        (to 
            (sites Occupied by:All component:"Ring") 
            level:0
            if:("IsSingletonStack" (to))
        ) 
        stack:True
        (then (moveAgain))
    )
)

(define "MoveRing"
    (move
        (from (last To))
        (to 
            (sites Around 
                (difference (sites Occupied by:All component:"Ring") (last To))
                Orthogonal
                if:(is Empty (to)) 
            )
        )
    )		
)

(define "MoveDisc" 
    (move
        (from 
            (from) 
            level:(level)
        ) 
        (to 
            (sites Occupied by:All component:"Ring") 
            level:0
            if:("IsSingletonStack" (to))
        ) 
        (then (moveAgain))
    )
)

//------------------------------------------------------------------------------

(game "Ringo" 
    (players 2) 
    (equipment { 
        (boardless Square) 
        (piece "Disc" Each ("MoveDisc")) 
        (piece "Ring" Each) 
    }) 
    (rules 
        (start {
            (place "Ring1" (ahead (centrePoint) NE)) 
            (place "Ring1" (ahead (centrePoint) SE)) 
            (place "Ring1" (ahead (centrePoint) SW)) 
            (place "Ring1" (ahead (centrePoint) NW)) 
            (place "Ring2" (ahead (centrePoint) N))
            (place "Ring2" (ahead (centrePoint) E))
            (place "Ring2" (ahead (centrePoint) S))
            (place "Ring2" (ahead (centrePoint) W))
        })
        phases:{
        (phase "PlacePhase"
            (play
                (do 
                    (if ("NewTurn") 
                        ("AddDisc") 
                        ("MoveRing") 
                        
                    )
                    ifAfterwards:(= 1 (count Groups))
                )
            )
            (nextPhase Mover 
                (and ("NewTurn") ("AllDiscsPlaced")) 
                "MovePhase"
            )
        )
        (phase "MovePhase"
            (play
                (do 
                    (if ("NewTurn") 
                        (forEach Piece) 
                        ("MoveRing")
                    )
                    ifAfterwards:(= 1 (count Groups))
                )
            )
        )
        }
        (end {
            (if (is Line 4 what:(id "Disc" P1)) (result P1 Win))
            (if (is Line 4 what:(id "Ring" P1)) (result P1 Win))
            (if (is Line 4 what:(id "Disc" P2)) (result P2 Win))
            (if (is Line 4 what:(id "Ring" P2)) (result P2 Win))
        })
    )
)

//------------------------------------------------------------------------------

(metadata 
    
    (info
        {
        (description "An original n-in-row game with discs and rings.")
        (rules "Players complete two actions in turns:
            1. Place a disc of their colour inside any ring.
            2. Pick up the ring in which they placed their disc and move it somewhere else:
            â€“ It must be placed horizontally or vertically adjacent to at least another ring.
            â€“ It must be placed on an empty space (i.e. not over a disc or ring that was placed before).
            - If a player has used up his/her stock of discs, he/she continues by removing one of his/her discs from anywhere on the table and places it in a ring as usual.
            
            However rings and discs must always remain (orthogonally or diagonally) connected to form one unique group. 
            
        The winner is the first player who succeeds in placing four of his/her discs or four of his/her rings in a horizontal, vertical or diagonal row. ")
        (id "676")
        (source "<a href=\"https://boardgamegeek.com/boardgame/261490/ringo\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />BGG</a>")
        (version "1.3.11")
        (classification "board/space/line")
        (author "Julien Griffon")
        (publisher "Steffen-Spiele")
        (credit "Eric Piette and Cameron Browne.")
        (date "2018")
        }
    )
    
    (graphics {
        (player Colour P1 (colour Red))
        (player Colour P2 (colour Blue))
        (piece Scale "Disc" 0.8)
        (piece Scale "Ring" 1.025)
        (stackType None)
    })
    
    (ai
        "Ringo_ai"
    )
)




(define "OwnerInLastStack" 
    (results 
        from:(last To) 
        to:(forEach Level at:(last To)) 
        (who at:(last To) level:(to))
    )		
)

(define "AllActivePlayersInLastStack" 
    (and {
        (or (not (is Active P1)) (is In 1 ("OwnerInLastStack")))
        (or (not (is Active P2)) (is In 2 ("OwnerInLastStack")))
        (or (not (is Active P3)) (is In 3 ("OwnerInLastStack")))
        (or (not (is Active P4)) (is In 4 ("OwnerInLastStack")))
    })
)

(define "MostRecentPlayedChip"
    (results 
        from:(last To) 
        to:(forEach Level at:(last To) FromBottom 
            if:(not 
                (is In 
                    (who at:(last To) level:(level))
                    (results 
                        from:(last To) 
                        to:(forEach Level at:(last To) FromBottom startAt:(+ 1 (level)))
                        (who at:(last To) level:(to))
                    )
                )
            )
        )
        (who at:(last To) level:(to))
    )		
)

(define "PlayerInMostRecentPlayedChip"
    (arrayValue 
        ("MostRecentPlayedChip")
        index:#1
    )
)

(define "OwnerMostRecentPlayedChip"
    (if (is Active ("PlayerInMostRecentPlayedChip" 0))
        ("PlayerInMostRecentPlayedChip" 0)
        (if (is Active ("PlayerInMostRecentPlayedChip" 1))
            ("PlayerInMostRecentPlayedChip" 1)
            (if (is Active ("PlayerInMostRecentPlayedChip" 2))
                ("PlayerInMostRecentPlayedChip" 2)
                ("PlayerInMostRecentPlayedChip" 3)
            )
        )
    )
)

(define "ACaptureIsMade"
    (and
        (> (size Stack at:(last To)) 1)
        (= 
            (who at:(last To) level:(- (size Stack at:(last To)) 1))
            (who at:(last To) level:(- (size Stack at:(last To)) 2))
        )
    )	
)

(define "ACaptureWasMade"
    (= (var "CaptureWasMade") 1)
)

(define "NoChip"
    (and {
        (is Empty (handSite Mover))
        (is Empty (handSite Mover 1))
        (is Empty (handSite Mover 2))
        (is Empty (handSite Mover 3))
        (is Empty (handSite Mover 4))
    })
)

(define "APlayerCanLose" 
    (and
        (!= Undefined (var "CanBeDefeated"))
        (not (is Mover (var "CanBeDefeated")))
    )
)

//-------------------------------------------------------------------------

(game "So Long Sucker" 
    (players 4) 
    (equipment { 
        (board (rectangle 4 7))
        (hand Each size:5)
        (piece "Marker" Each)
    }) 
    (rules
        (start {
            (place Stack "Marker1" (handSite P1) count:7)
            (place Stack "Marker2" (handSite P2) count:7)
            (place Stack "Marker3" (handSite P3) count:7)
            (place Stack "Marker4" (handSite P4) count:7)
        })
        
        (play 
            (if ("APlayerCanLose")
                (or 
                    (move Set NextPlayer (player (next)) (then (note "Fuck You Buddy!")))
                    (move
                        (from
                            (forEach (sites Hand Mover) 
                                if:(and 
                                    (!= (site) (handSite Mover 0))
                                    (is Occupied (site))
                                )
                            )
                        )
                        (to (handSite Player (var "CanBeDefeated")))
                        (then
                            (and {
                                (set NextPlayer (player (var "CanBeDefeated")))
                                (set Var "CanBeDefeated" Undefined)		
                                (set Var "PrevWas" Undefined)
                            })
                        )
                    )
                )
                (if ("ACaptureWasMade")
                    (forEach Level (last To)
                        (move Remove (last To) level:(level))
                        (then
                            (and {
                                (forEach Level (last To)
                                    (fromTo
                                        (from (last To) level:(level))
                                        (to 
                                            (if (is Mover (who at:(last To) level:(level)))
                                                (handSite Mover 0)
                                                (handSite Mover (who at:(last To) level:(level)))
                                            )
                                        )
                                    )
                                )
                                (moveAgain)
                                (set Pending)
                                (set Var "CaptureWasMade" 0)
                            })
                        )
                    )
                    (if (and (not (is Pending)) ("SameTurn"))
                        (if ("AllActivePlayersInLastStack")
                            (move Set NextPlayer (player ("OwnerMostRecentPlayedChip")))
                            (forEach Player
                                (if (and (is Active (player)) (not (is In (player) ("OwnerInLastStack"))))
                                    (move Set NextPlayer (player (player)))
                                )
                            )
                            (then (set Pending))
                        )
                        (if ("NoChip")
                            (if (= Undefined (var "CanBeDefeated"))
                                (move Pass 
                                    (then
                                        (and
                                            (set Var "CanBeDefeated" (mover))
                                            (set Var "PrevWas" (prev))
                                        )
                                    )
                                )
                                (move Pass 
                                    (then 
                                        (and {
                                            (set Var "Defeat" (mover))
                                            (set Var "CanBeDefeated" Undefined)
                                            (if (is Active (var "PrevWas"))
                                                (set NextPlayer (player (var "PrevWas")))
                                                (set NextPlayer (player (next)))
                                            )
                                            (set Var "PrevWas" Undefined)
                                        })
                                    )
                                )
                            )
                            (or {
                                (move 
                                    (from (sites Hand Mover))
                                    (to (sites Board))
                                    (then
                                        (if ("ACaptureIsMade")
                                            (if (is Active (who at:(last To) level:(- (size Stack at:(last To)) 1)))
                                                (and
                                                    (set Var "CaptureWasMade" 1)
                                                    (set NextPlayer (player (who at:(last To))))
                                                )
                                                (and {
                                                    (forEach Level (last To)
                                                        (remove (last To) level:(level))
                                                    )
                                                    (moveAgain)
                                                    (set Pending)
                                                })
                                            )
                                            (moveAgain)
                                        )
                                    )
                                ) 
                                (move Remove
                                    (forEach (sites Hand Mover) 
                                        if:(and 
                                            (!= (site) (handSite Mover 0))
                                            (is Occupied (site))
                                        )
                                    )
                                )
                                (forEach Player 
                                    (if (not (is Mover Player))
                                        (move
                                            (from
                                                (forEach (sites Hand Mover) 
                                                    if:(and 
                                                        (!= (site) (handSite Mover 0))
                                                        (is Occupied (site))
                                                    )
                                                )
                                            )
                                            (to (handSite Player (who at:(from))))
                                        )
                                    )
                                )
                            })
                        )
                    )
                )
            )
        )
        
        (end 
            (if (is Mover (var "Defeat")) (result Mover Loss))
        )
    )
)

//-------------------------------------------------------------------------

(metadata
    (info
        {
        (description "So Long Sucker is a board game invented in 1950 by John Forbes Nash, Mel Hausner, Lloyd S. Shapley and Martin Shubik. It is a four-person bargaining/economic strategy game. Each player begins the game with 7 chips, and in the course of play, attempts to acquire all the other players' chips.")
        (aliases {"Fuck You Buddy"})
        (rules "The rules are as follows:
            
            1. Starting a game:
            - Each player takes 7 chips of one color.
            - No two players may start with the same color chips.
            - This player places a chip onto the playing area, and selects any other player to be the next person to move.
            
            2. Playing the game:
            - Move by playing a chip of any color onto the playing area (starting a new pile), or on top of any existing chip(s) in the playing area.
            - If no chips are captured (see below), the player selects the next person to move, so long as that person's starting chip color is not in the stack just played on (this may be the same person, if that person used a captured chip). However, if all four colors are in the stack just played on, the next person must be the player whose most-recently played chip (by color) is furthest down in the stack
            - Chips are captured by playing two chips of the same color consecutively on one pile. The player designated by that color must kill one chip of their choice out of that pile, and take the rest. Then they get the next move. Killed chips are taken out of the game.
            - A chip is a prisoner when held by a player other than the original owner.
            - Any prisoner in a player's possession may be killed or transferred to another player at any time. Such transfers are unconditional and cannot be retracted. A player may not transfer or kill chips of their own color.
            - A player is defeated when given the move, but has no chips in their possession (and hence is unable to play).
            a. Defeat is not final until every player holding prisoners has refused to rescue the defeated player by transferring chips.
            b. After defeat, the move returns to the player who gave the defeated player the move.
            c. The defeated player's chips remain in play as prisoners, but are ignored in determining the order of play.
            d. If a pile is captured by the chips of a defeated player, the entire pile is killed, and the move rebounds to the capturing player.
            
            3. Order of play:
            - If a capture occurs: the player whose color made the capture gets the next move.
            - If a player is defeated: move returns to the player who gave the defeated player the move. If this should also defeat that player in turn, whoever gave that player the move will get the next turn, etc.
            - Otherwise, the next player to move is decided by last player to have moved as follows:
            a. They may give the move to any player (including themselves) whose color is not represented in the pile just played upon.
            b. If all players are represented in that pile, the move goes to the player whose most-recently played chip is furthest down in the pile.
            
            4.Winning the game:
            - The winner is the last surviving player (after the others have been defeated).
        - A player can win even if they hold no chips and all of their chips have been killed.")
        (id "1772")
        (source "<a href=\"https://en.wikipedia.org/wiki/So_Long_Sucker\" target=\"_blank\" class=\"style1\" style=\"color: #0000EE\" />Wikipedia</a>")
        (version "1.3.11")
        (classification "math")
        (author "John Forbes Nash, Mel Hausner, Lloyd S. Shapley and Martin Shubik")
        (credit "Eric Piette")
        (date "1950")
        }
    )
    
    (graphics {
        (no Board)
        (stackType 0 Default 0.5)
        (stackType 1 Count)
        (stackType 2 Count)
        (stackType 3 Count)
        (stackType 4 Count)
    })
    
)
